<!DOCTYPE html>





<html class="theme-next muse use-motion" lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="generator" content="Hexo 3.9.0">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=7.3.0">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32.ico?v=7.3.0">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16.ico?v=7.3.0">
  <link rel="mask-icon" href="/images/logo.svg?v=7.3.0" color="#222">

<link rel="stylesheet" href="/css/main.css?v=7.3.0">


<link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css?v=4.7.0">


<script id="hexo-configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Muse',
    version: '7.3.0',
    exturl: false,
    sidebar: {"position":"right","display":"post","offset":12,"onmobile":false},
    back2top: {"enable":true,"sidebar":false,"scrollpercent":false},
    save_scroll: false,
    copycode: {"enable":false,"show_result":false,"style":null},
    fancybox: false,
    mediumzoom: false,
    lazyload: false,
    pangu: false,
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    },
    localsearch: {"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},
    path: '',
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    translation: {
      copy_button: '复制',
      copy_success: '复制成功',
      copy_failure: '复制失败'
    }
  };
</script>

  <meta property="og:type" content="website">
<meta property="og:title" content="c萌怪谈">
<meta property="og:url" content="cmeng001.github.io/index.html">
<meta property="og:site_name" content="c萌怪谈">
<meta property="og:locale" content="zh-CN">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="c萌怪谈">
  <link rel="canonical" href="cmeng001.github.io/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome: true,
    isPost: false,
    isPage: false,
    isArchive: false
  };
</script>

  <title>c萌怪谈</title>
  








  <noscript>
  <style>
  .use-motion .motion-element,
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-title { opacity: initial; }

  .use-motion .logo,
  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-CN">

  <div class="container sidebar-position-right">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta">

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">c萌怪谈</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
        <p class="site-subtitle">奇葩事迹、奇趣怪谈、记录一切新奇怪异。</p>
      
  </div>

  <div class="site-nav-toggle">
    <button aria-label="切换导航栏">
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>


<nav class="site-nav">
  
  <ul id="menu" class="menu">
      
      
      
        
        <li class="menu-item menu-item-home">
      
    

    <a href="/" rel="section"><i class="menu-item-icon fa fa-fw fa-home"></i> <br>首页</a>

  </li>
      
      
      
        
        <li class="menu-item menu-item-categories">
      
    

    <a href="/categories/" rel="section"><i class="menu-item-icon fa fa-fw fa-th"></i> <br>分类</a>

  </li>
      
      
      
        
        <li class="menu-item menu-item-archives">
      
    

    <a href="/archives/" rel="section"><i class="menu-item-icon fa fa-fw fa-archive"></i> <br>归档</a>

  </li>
      
      
      
        
        <li class="menu-item menu-item-tags">
      
    

    <a href="/tags/" rel="section"><i class="menu-item-icon fa fa-fw fa-tags"></i> <br>标签</a>

  </li>
      
      
      
        
        <li class="menu-item menu-item-about">
      
    

    <a href="/about/" rel="section"><i class="menu-item-icon fa fa-fw fa-user"></i> <br>关于</a>

  </li>
  </ul>

    

</nav>
</div>
    </header>

    


    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content page-home">
            
  <section id="posts" class="posts-expand">
      

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="cmeng001.github.io/2020/08/17/JVM/jvm-memory-model/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="cmeng">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="c萌怪谈">
    </span>
      <header class="post-header">

        
          <h1 class="post-title" itemprop="name headline">
              
              <a href="/2020/08/17/JVM/jvm-memory-model/" class="post-title-link" itemprop="url">JVM内存模型</a>
            
          </h1>
        

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              
                
              

              <time title="创建时间：2020-08-17 16:13:12" itemprop="dateCreated datePublished" datetime="2020-08-17T16:13:12+08:00">2020-08-17</time>
            </span>
          
            

            
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-08-18 16:31:20" itemprop="dateModified" datetime="2020-08-18T16:31:20+08:00">2020-08-18</time>
              </span>
            
          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/JVM/" itemprop="url" rel="index"><span itemprop="name">JVM</span></a></span>

                
                
              
            </span>
          

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          
            <h1 id="JVM内存"><a href="#JVM内存" class="headerlink" title="JVM内存"></a>JVM内存</h1><h3 id="一-概述"><a href="#一-概述" class="headerlink" title="一 概述"></a>一 概述</h3><p><strong>内存</strong> 是硬盘和CPU的中间仓库及桥梁，承载着操作系统和应用程序的实时运行。JVM内存布局规定了Java在运行过程中内存申请、分配、管理的策略，保证了JVM的高效稳定运行.</p>
<p>在JVM自动内存管理机制，开发人员不需要去考虑内存的delete/free操作，不容易出现内存溢出和泄露问题。</p>
<h3 id="二-运行时数据区域-内存布局"><a href="#二-运行时数据区域-内存布局" class="headerlink" title="二 运行时数据区域/内存布局"></a>二 运行时数据区域/内存布局</h3><p>1.8之前和之后略有区别，主要体现在为1.8之前存在方法区(Method Area)，1.8之后去掉方法区，增加元空间(MetaSpace)</p>
<p><img src="/image/JVM/Java虚拟机运行时数据区_水印.jpg" alt="Java内存布局"></p>
<h4 id="2-1-虚拟机栈"><a href="#2-1-虚拟机栈" class="headerlink" title="2.1 虚拟机栈"></a>2.1 虚拟机栈</h4><ol>
<li><p>Java 虚拟机栈（Java Virtual Machine Stacks）也就是我们平时所说的 <strong>栈内存</strong>，或者指的就是虚拟机栈中的 <strong>局部变量表</strong> 部分。<br>虚拟机栈描述的是Java方法的内存模型：即每个方法在执行的同时都会创建一个 <strong>栈帧</strong>，用于存储局部变量表、操作数栈、动态链接、方法出口等信息。所以虚拟机栈是线程私有的，生命周期与线程相同。  </p>
</li>
<li><p><strong>栈针（Stack Frame）</strong> ：用于支持虚拟机进行方法调用和方法执行的数据结构。每一个方法从调用至执行完成的过程，都对应着一个栈帧在虚拟机栈里从入栈到出栈的过程。  </p>
</li>
<li><p><strong>局部变量表</strong>：存放编译期方法内部的各种基本数据类型（boolean、byte、char、short、int、float、long、double）、对象引用（reference）类型等。<br>局部变量表所需空间是在编译期间完成分配的，当进入方法，该方法需要的栈针分配的空间是固定，在方法运行期间不会改变.   </p>
<p><strong>操作数栈</strong>：Java虚拟机的解释执行引擎称为“基于栈的执行引擎”，其中所指的“栈”就是操作数栈。当JVM为方法创建栈帧的时候，在栈帧中为方法创建一个操作数栈，保证方法内指令可以完成工作。</p>
<p><strong>动态链接</strong>： 每个栈帧中包含一个在常量池中对当前方法的引用， 目的是支持方法调用过程的动态连接。</p>
<p><strong>方法返回地址</strong>： 退出的两种形式，1、正常退出；2、抛出异常。</p>
</li>
<li><p>虚拟机栈在JVM中存在两种异常</p>
<ul>
<li>StackOverflowError：若线程请求的栈深度大于当前虚拟机所允许的深度，抛出此异常</li>
<li>OutOfMemoryError：若虚拟机栈可动态扩展，当扩展时无法申请到足够的内存，抛出此异常</li>
</ul>
</li>
</ol>
<h4 id="2-2-本地方法栈"><a href="#2-2-本地方法栈" class="headerlink" title="2.2 本地方法栈"></a>2.2 本地方法栈</h4><p>本地方法栈Native Method Stack）与虚拟机栈的作用是相似。区别是：<strong>虚拟机栈为虚拟机执行 Java 方法 （也就是字节码）服务，而本地方法栈则为虚拟机使用到的 Native 方法服务。</strong>   </p>
<p>此外，对于此区域出现的异常，和虚拟机栈是相同的。</p>
<h4 id="2-3-程序计数器"><a href="#2-3-程序计数器" class="headerlink" title="2.3 程序计数器"></a>2.3 程序计数器</h4><p>程序计数器（Program Counter Register）是当前线程所执行的字节码的行号指示器，它占用一块较小的内存空间。<strong>字节码解释器通过改变该计数器的值来选取下一条需要执行的字节码指令，其中包括分支、循环、跳转、异常处理、线程恢复等基础功能。</strong>  </p>
<p>Java多线程是处理器的时间片转轮的策略的实现的，任一确定时刻，一个处理器只执行一条线下中的命令，为了切换线程后可恢复到正确的执行位置，程序计数器为线程私有。</p>
<p><strong>程序计数器是唯一一个在 Java 虚拟机规范中没有规定任何 OutOfMemoryError 情况的区域。</strong></p>
<h4 id="2-4-堆"><a href="#2-4-堆" class="headerlink" title="2.4 堆"></a>2.4 堆</h4><ol>
<li><p>堆（Heap）是JVM最重要的也是最大的一块内存，在虚拟机启动时创建。对于堆来说，它可以位于物理上不连续而逻辑上连续的内存空间中。在实际情况下也可以通过调整虚拟机参数的方式对堆进行扩展，即通过 -Xmx 和 -Xms 控制。</p>
</li>
<li><p>该区域的主要作用: <strong>为对象实例及数组分配内存</strong>，几乎存储了所有对象实例。同时也是垃圾回收器管理的主要区域，因此也被称作GC 堆（Garbage Collected Heap）。 <br><br><br>Java堆还可以细分为：新生代和老年代。再细致一点的有Eden空间、From Survivor空间、To Survivor空间等。具体如下图：<br><img src="/image/JVM/Heap.jpg" alt="堆Heap详细分布">1.8后去除永生代，用元空间替代。<br><br><br>查看虚拟机默认配置命令：</p>
<figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java -XX:+PrintFlagsFinal -<span class="built_in">version</span></span><br></pre></td></tr></table></figure>
</li>
</ol>
<h4 id="2-5-方法区-Method-Area"><a href="#2-5-方法区-Method-Area" class="headerlink" title="2.5 方法区(Method Area)"></a>2.5 方法区(Method Area)</h4><ol>
<li><p>方法区（Method Area）用于存储已被虚拟机加载的 类信息、常量、静态变量、即时编译器编译后的代码等数据。虽然 <strong>Java 虚拟机规范把方法区描述为堆的一个逻辑部分，但是它却有一个别名叫做 Non-Heap（非堆）</strong>，目的应该是与 Java 堆区分开来。</p>
</li>
<li><p>方法区也被成为永生代，二者关系分析起来比较容易混淆，引用下面个人认为比较好的释义：</p>
<blockquote>
<p>《Java 虚拟机规范》只是规定了有方法区这么个概念和它的作用，并没有规定如何去实现它。那么，在不同的 JVM 上方法区的实现肯定是不同的了。<strong>方法区和永久代的关系很像 Java 中接口和类的关系，类实现了接口，而永久代就是 HotSpot 虚拟机对虚拟机规范中方法区的一种实现方式。</strong> 也就是说，永久代是 HotSpot 的概念，方法区是 Java 虚拟机规范中的定义，是一种规范，而永久代是一种实现，一个是标准一个是实现，其他的虚拟机实现并没有永久代这一说法。</p>
</blockquote>
</li>
<li><p>方法区或者称为永生代，<strong>在1.8中被去除</strong>。并用元空间（Metaspace）替换。</p>
</li>
</ol>
<h4 id="2-5-元空间（Metaspace）"><a href="#2-5-元空间（Metaspace）" class="headerlink" title="2.5 元空间（Metaspace）"></a>2.5 元空间（Metaspace）</h4><ol>
<li>元空间替换方法区的原因：<ul>
<li>因为PermGen/(Method Area)经常内存溢出。</li>
<li>促进HotSpot和JRockit VM融合，因为 JRockit 没有永久代。<br>详细原因：<a href="http://openjdk.java.net/jeps/122" target="_blank" rel="noopener">JEP 122:Remove the Permanent Generation</a></li>
</ul>
</li>
<li>根据上面的原因方法区被移除，方法区中类元信息、字段、静态属性、方法、常量等移至元空间，<strong>并在1.7时将运行时常量池从方法区中移了出来，在 Java 堆（Heap）中开辟了一块区域存放运行时常量池。</strong></li>
<li>元空间和方法区本质类似，主要区别在于：<strong>元空间使用本地内存，方法区存在于虚拟机中。</strong> 所以元空间的大小取决于本地内存的容量。  </li>
</ol>
<p>元空间对应的JVM调参：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:left">参数</th>
<th style="text-align:left">作用</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">-XX:MaxMetaspaceSize</td>
<td style="text-align:left">分配给Metaspace 的最大值，超过此值就会触发Full GC，此值默认没有限制，但应取决于系统内存的大小。JVM会动态地改变此值。</td>
</tr>
<tr>
<td style="text-align:left">-XX:MinMetaspaceFreeRatio</td>
<td style="text-align:left">在GC之后，最小的Metaspace剩余空间容量的百分比，减少为分配空间所导致的垃圾收集</td>
</tr>
<tr>
<td style="text-align:left">-XX:MaxMetaspaceFreeRatio</td>
<td style="text-align:left">在GC之后，最大的Metaspace剩余空间容量的百分比，减少为释放空间所导致的垃圾收集</td>
</tr>
<tr>
<td style="text-align:left">-XX:MetaspaceSize</td>
<td style="text-align:left">分配给Metaspace（以字节计）的初始大小</td>
</tr>
</tbody>
</table>
</div>
<h4 id="2-6-直接内存（Direct-Memory）"><a href="#2-6-直接内存（Direct-Memory）" class="headerlink" title="2.6 直接内存（Direct Memory）"></a>2.6 直接内存（Direct Memory）</h4><p>直接内存并不属于Java内存的一员，但这部分也经常被使用并也会出现OutOfMemoryError 异常。<br>虽然直接内存不受Java堆大小的限制，但还是会受到本机总内存的大小及处理器寻址空间的限制。如果内存区域总和大于物理内存的限制，也会出现OOM。</p>
<hr>
<h5 id="参考："><a href="#参考：" class="headerlink" title="参考："></a>参考：</h5><ul>
<li><a href="https://dyfloveslife.github.io/2019/11/18/java-memory-areas" target="_blank" rel="noopener">https://dyfloveslife.github.io/2019/11/18/java-memory-areas</a></li>
</ul>

          
        
      
    </div>

    
    
    
      <footer class="post-footer">
          <div class="post-eof"></div>
        
      </footer>
  </div>
  
  
  
  </article>

    
      

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="cmeng001.github.io/2020/08/17/algorithm/时间复杂度/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="cmeng">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="c萌怪谈">
    </span>
      <header class="post-header">

        
          <h1 class="post-title" itemprop="name headline">
              
              <a href="/2020/08/17/algorithm/时间复杂度/" class="post-title-link" itemprop="url">算法-时间复杂度</a>
            
          </h1>
        

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              
                
              

              <time title="创建时间：2020-08-17 16:13:12" itemprop="dateCreated datePublished" datetime="2020-08-17T16:13:12+08:00">2020-08-17</time>
            </span>
          
            

            
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-08-18 17:00:25" itemprop="dateModified" datetime="2020-08-18T17:00:25+08:00">2020-08-18</time>
              </span>
            
          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/算法/" itemprop="url" rel="index"><span itemprop="name">算法</span></a></span>

                
                
              
            </span>
          

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          
            <h2 id="算法-时间复杂度"><a href="#算法-时间复杂度" class="headerlink" title="算法-时间复杂度"></a>算法-时间复杂度</h2><h3 id="1、数据结构-算法"><a href="#1、数据结构-算法" class="headerlink" title="1、数据结构-算法"></a>1、数据结构-算法</h3><p>数据结构和算法是相辅相成的，<strong>数据结构是为算法服务的，算法要作用在特定的数据结构之上</strong>。所以二者的学习不能互相孤立。</p>
<h3 id="2、算法复杂度分析"><a href="#2、算法复杂度分析" class="headerlink" title="2、算法复杂度分析"></a>2、算法复杂度分析</h3><ol>
<li>时间复杂度： 指算法需要消耗的时间资源。计算机算法是问题规模n 的函数f(n)，算法的时间复杂度也因此记做。<br>T(n)=Ο(f(n))</li>
<li>空间复杂度：算法需要消耗的空间资源。其计算和表示方法与时间复杂度类似，一般都用复杂度的渐近性来表示。同时间复杂度相比，空间复杂度的分析要简单得多。</li>
</ol>
<h4 id="2-1、事后统计法"><a href="#2-1、事后统计法" class="headerlink" title="2.1、事后统计法"></a>2.1、事后统计法</h4><p>事后统计法：通过统计、分析等，计算出算法的实际执行时间和实际内存占用，从而得到算法的时间复杂度。</p>
<ul>
<li>测试结果非常依赖测试环境。（服务器资源配置）</li>
<li>测试结果受限于数据规模</li>
</ul>
<h4 id="2-2、大O复杂度表示法"><a href="#2-2、大O复杂度表示法" class="headerlink" title="2.2、大O复杂度表示法"></a>2.2、大O复杂度表示法</h4><p>时间复杂度通俗来讲，就是代码运行的时间。大O表示法就是在不运算代码的情况下来分析一段代码的时间复杂度。<br>看下面的例子：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">calculate</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> (;i&lt;n;++i)&#123;</span><br><span class="line">    sum = sum + i;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>从CPU的角度来看，代码的每一行都执行着类似的操作：<strong>读操作-运算-写操作</strong>。这里我们假设每行代码的执行时间一样，为unit_time，那么2，3行执行了1个unit_time，3，4行n个unit_time，总的执行时间就是（2n+2）*unit_time。<br>按照这个思路再来看下面一段代码：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">cal</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">int</span> j = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> (;i&lt;n;i++)&#123;</span><br><span class="line">    j = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (;j&lt;=n;j++)&#123;</span><br><span class="line">      sum += sum + i * j;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>依旧假设单位时间为unit_time，2、3、4行执行时间分别为1unti_time，5、6加起来就是2n。7、8加起来就是2n²unit_time;总的时间就为(2n²+2n+3)unit_time.<br>这两段代码分析我们可得到一个重要的规律，那就是<strong>代码的执行时间T(n)和每段代码的执次数成正比</strong>，所以就得到了以下公式：</p>
<blockquote>
<font color="orange">T(n)=O(f(n))</font>

</blockquote>
<p>其中T(n)代表了代码的执行时间，n代表数据规模，f(n)代表每行代码执行的次数总和。因为是公式，所以用f(n)表达。公式中的O则表示代码执行时间T(n)和表达式f(n)成正比。   </p>
<p>两个例子中的T(n)=O(2n+2)和T(n)=O(2n²+2n+3)就是大O时间复杂度表示法，它并不代表具体的执行时间，而是代表<strong>代码的执行时间随着数据规模增加的变化趋势</strong>，所以也叫渐进时间复杂度（asymptotic time complexity），简称时间复杂度。  </p>
<p>当n很大时，表达式中的低阶、常量、系数等部分并不左右增长趋势，所以大O表示法可记为：T(n)=O(n)、T(n)=O(n²)。</p>
<h4 id="2-3-常见复杂度分析方法"><a href="#2-3-常见复杂度分析方法" class="headerlink" title="2.3 常见复杂度分析方法"></a>2.3 常见复杂度分析方法</h4><ol>
<li><p>单段代码看高频：如循环</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">calculate</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> (;i&lt;n;++i)&#123;</span><br><span class="line">    sum = sum + i;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>多段代码取最高：如一段代码中存在单重循环和多重循环，则取多重循环。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">cal</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> temp = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">int</span> a = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> (;a&lt;n;++a)&#123;</span><br><span class="line">    temp = temp + i;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">int</span> j = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> (;i&lt;n;i++)&#123;</span><br><span class="line">    j = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (;j&lt;=n;j++)&#123;</span><br><span class="line">      sum += sum + i * j;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>嵌套循环取乘积：比如多重循环，递归等。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">cal</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">int</span> j = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> (;i&lt;n;i++)&#123;</span><br><span class="line">    j = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (;j&lt;=n;j++)&#123;</span><br><span class="line">      sum += sum + i * j;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>多数据规模取和：O(n+m)。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">cal</span><span class="params">(<span class="keyword">int</span> n,<span class="keyword">int</span> m)</span></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> temp = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">int</span> a = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> (;a&lt;n;++a)&#123;</span><br><span class="line">    temp = temp + i;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (;i&lt;m;i++)&#123;</span><br><span class="line">    sum += sum + i * j;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h4 id="2-4-常见的时间复杂度"><a href="#2-4-常见的时间复杂度" class="headerlink" title="2.4 常见的时间复杂度"></a>2.4 常见的时间复杂度</h4><p><img src="/image/algorithm/常见时间复杂度.jpg" alt="常见时间复杂度"></p>
<ol>
<li>多项式阶，随着数据规模的增长，算法的执行时间和空间占用，按照多项式的比例增长。  </li>
</ol>
<ul>
<li>O(1)（常数阶）<br>常数阶的概念并不是只执行一行代码，一般情况下算法中不存在循环、递归等语句，即使有成千上万行代码，复杂度也是O(1)</li>
<li><p>O(logn)（对数阶）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> i =<span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span>(i&lt;n)&#123;</span><br><span class="line">  i = i * <span class="number">2</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当2^x&gt;=n时，循环结束，所以这段代码的执行次数就是x= $log_2n$;大O法记作：$O(log_2n)$。那么再看下面这段代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> i =<span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span>(i&lt;n)&#123;</span><br><span class="line">  i = i * <span class="number">3</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>按照上面的逻辑，这段的复杂度为$O(log_3n)$。二者之间是可以转换的$log_3n=log_32 * log_2n$；基于大O法的理论：在采用大O计数法时可以忽略系数等。则此类复杂度可统一记为O(logn)。   </p>
</li>
<li>O(n)（线性阶）</li>
<li>O(nlogn)（线性对数阶）<br>基于O(logn)，那么O(nlogn)就容易理解了，就相当于上面的嵌套取乘积规则一样，就是O(logn)执行的n遍。</li>
<li>O(n^2)（平方阶）、O(n^3)（立方阶）….、O(n^k)(K次方阶)</li>
</ul>
<ol>
<li>非多项式阶：随着数据规模的增长，算法的执行时间和空间占用暴增，这类算法性能极差。</li>
</ol>
<ul>
<li>O(2^n)（指数阶）</li>
<li>O(n!)（阶乘阶）</li>
</ul>
<h3 id="3-小结"><a href="#3-小结" class="headerlink" title="3 小结"></a>3 小结</h3><p>虽然上面说的事后统计法有一定的缺点，但时间复杂度的分析与其并不是对立冲突的。时间复杂度是一个理论上的模型，可以比较直观的给我们一个算法的效率上的感性认知，只能提供粗略的分析。它是与宿主平台无关的，并不是说O(n)的效率一定就优于O(n²)。针对不同的宿主平台环境，不同的数据集，不同的数据规模，在实际应用上性能可能会各有不同，所以实际应用中进行一定的性能基准测试是有必要的。<br>综上所述，时间复杂度分析和性能测试是相辅相成的。但一个低阶的时间复杂度确实有极大的可能优于高阶的时间复杂度，所以在编程中时刻关心复杂度的趋势走向是很有必要的，而且能很大幅度的提升输出质量。因此在编程中具有这种复杂度分析的思维还是十分有必要的。</p>

          
        
      
    </div>

    
    
    
      <footer class="post-footer">
          <div class="post-eof"></div>
        
      </footer>
  </div>
  
  
  
  </article>

    
      

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="cmeng001.github.io/2020/08/17/zookeeper/zk-watcher/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="cmeng">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="c萌怪谈">
    </span>
      <header class="post-header">

        
          <h1 class="post-title" itemprop="name headline">
              
              <a href="/2020/08/17/zookeeper/zk-watcher/" class="post-title-link" itemprop="url">JVM内存模型</a>
            
          </h1>
        

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              
                
              

              <time title="创建时间：2020-08-17 16:13:12" itemprop="dateCreated datePublished" datetime="2020-08-17T16:13:12+08:00">2020-08-17</time>
            </span>
          
            

            
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-03-25 11:15:05" itemprop="dateModified" datetime="2021-03-25T11:15:05+08:00">2021-03-25</time>
              </span>
            
          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/zookeeper/" itemprop="url" rel="index"><span itemprop="name">zookeeper</span></a></span>

                
                
              
            </span>
          

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          
            <h1 id="Zookeeper之Watcher机制"><a href="#Zookeeper之Watcher机制" class="headerlink" title="Zookeeper之Watcher机制"></a>Zookeeper之Watcher机制</h1><p>watcher机制是zookeeper的三大特性之一，它是很多应用场景的前提，比如：集群配置、管理，发布、订阅，资源抢占协调等等。</p>
<h3 id="watcher原理"><a href="#watcher原理" class="headerlink" title="watcher原理"></a>watcher原理</h3><p>原理框架图：<br><img src="../../image/zookeeper/zookeeper-watcher原理框架.jpeg" alt="zookeeper原理框架">   </p>
<h3 id="注册和通知"><a href="#注册和通知" class="headerlink" title="注册和通知"></a>注册和通知</h3><p>zookeeper的watcher机制主要由client、server和watcherManager组成，包含注册和通知两个阶段。  </p>
<h4 id="注册表"><a href="#注册表" class="headerlink" title="注册表"></a>注册表</h4><h6 id="客户端注册表"><a href="#客户端注册表" class="headerlink" title="客户端注册表"></a>客户端注册表</h6><p>在 client 端注册表为 ZkWatchManager，ZkWatchManager的存储机制为三种</p>
<ul>
<li>dataWatches：针对节点的数据监听。</li>
<li>existWatches：客户端独有的存储方式，因为节点是否存在需要客户端自己判断。</li>
<li>childWatches：子节点监听。<br>源码：<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//客户端  其中Set&lt;Watcher&gt;实际复制对象类型为HashSet&lt;Watcher&gt;</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">ZKWatchManager</span> <span class="keyword">implements</span> <span class="title">ClientWatchManager</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Map&lt;String, Set&lt;Watcher&gt;&gt; dataWatches =</span><br><span class="line">        <span class="keyword">new</span> HashMap&lt;String, Set&lt;Watcher&gt;&gt;();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Map&lt;String, Set&lt;Watcher&gt;&gt; existWatches =</span><br><span class="line">        <span class="keyword">new</span> HashMap&lt;String, Set&lt;Watcher&gt;&gt;();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Map&lt;String, Set&lt;Watcher&gt;&gt; childWatches =</span><br><span class="line">        <span class="keyword">new</span> HashMap&lt;String, Set&lt;Watcher&gt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//创建Zoookeeper链接时传入的watcher会赋值到：defaultWatcher</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> Watcher defaultWatcher;</span><br><span class="line">......</span><br><span class="line">&#125;</span><br><span class="line">```  </span><br><span class="line">三种存储机制中，Set&lt;Watcher&gt;的实现都是HashSet&lt;Watcher&gt;，由此可得出：</span><br><span class="line">  * 同一路径下的同一watcher实例，无论注册多少次都只会记录一次，即触发后只通知一次。</span><br><span class="line">  * 同一路径注册多个不同的watcher，会通知多次。即每个注册watcher都会被通知。</span><br><span class="line"></span><br><span class="line">###### 服务端注册表</span><br><span class="line">在 server 端注册表为 WatcherWatchManager，WatcherWatchManager的存储机制分为两种：</span><br><span class="line">  * dataWatches：针对节点的数据监听。</span><br><span class="line">  * childWatches：子节点监听。  </span><br><span class="line"></span><br><span class="line">与 client 比少的 existWatches 也很容易理解，因为节点是否存在需要客户端去判断。  </span><br><span class="line">两种机制均由 WatchManager 类来实现，WatchManager中包含两个重要的数据结构，分别是：</span><br><span class="line">  * watchTable：从数据节点(即路径)的粒度来维护  </span><br><span class="line">  * watch2Paths：从watcher的粒度来维护。  </span><br><span class="line"></span><br><span class="line">注意这里的watcher含义表示远程连接，所以watchTable表示一个目录下可能有多个消费者的监听连接，而watch2Paths表示一个消费者可能会对多个目录建立监听，显然多目录的监听会复用一个连接。</span><br><span class="line">源码：</span><br><span class="line">```Java</span><br><span class="line"><span class="comment">//服务端</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DataTree</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Logger LOG = LoggerFactory.getLogger(DataTree.class);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * This hashtable provides a fast lookup to the datanodes. The tree is the</span></span><br><span class="line"><span class="comment">     * source of truth and is where all the locking occurs</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ConcurrentHashMap&lt;String, DataNode&gt; nodes =</span><br><span class="line">        <span class="keyword">new</span> ConcurrentHashMap&lt;String, DataNode&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> WatchManager dataWatches = <span class="keyword">new</span> WatchManager();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> WatchManager childWatches = <span class="keyword">new</span> WatchManager();</span><br><span class="line">    ....</span><br><span class="line">  &#125;</span><br><span class="line"><span class="comment">//dataWatches和childWatches是同一类的不同实例。即：</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WatchManager</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Logger LOG = LoggerFactory.getLogger(WatchManager.class);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> HashMap&lt;String, HashSet&lt;Watcher&gt;&gt; watchTable =</span><br><span class="line">        <span class="keyword">new</span> HashMap&lt;String, HashSet&lt;Watcher&gt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> HashMap&lt;Watcher, HashSet&lt;String&gt;&gt; watch2Paths =</span><br><span class="line">        <span class="keyword">new</span> HashMap&lt;Watcher, HashSet&lt;String&gt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">int</span> <span class="title">size</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> result = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(Set&lt;Watcher&gt; watches : watchTable.values()) &#123;</span><br><span class="line">            result += watches.size();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">    ......</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="注册"><a href="#注册" class="headerlink" title="注册"></a>注册</h3><h6 id="注册方式"><a href="#注册方式" class="headerlink" title="注册方式"></a>注册方式</h6><p>创建Zookeeper链接时会传入的watcher，这个watcher即为注册表中的defaultWatcher。<br>其它注册方式：</p>
<ul>
<li>getChildren(String path, Watcher watcher)</li>
<li>getChildren(String path, boolean watch)</li>
<li>getData(String path, boolean watch, Stat stat)</li>
<li>getData(String path, Watcher watcher, AsyncCallback.DataCallback cb, Object ctx)</li>
<li>exists(String path, boolean watch)</li>
<li>exists(String path, Watcher watcher)   </li>
</ul>
<p>其中Boolean watch表示是否使用上下文中默认的watcher，即创建zk实例时设置的watcher. getData 和 exists 请求可以注册服务端注册表-dataWatches，getChilden 可以注册服务端注册表-childWatches。<br>每个客户端都会维护 2 个线程，SendThread 负责处理客户端与服务端的请求通信，比如发送 getDataRequest，而 EventThread 则负责处理服务端的事件通知，即 watcher 的事件。</p>
<h6 id="注册流程"><a href="#注册流程" class="headerlink" title="注册流程"></a>注册流程</h6><ol>
<li>客户端注册流程<br>几种客户端注册的流程大致相同，我们以exists为例。源码：<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Stat <span class="title">exists</span><span class="params">(<span class="keyword">final</span> String path, Watcher watcher)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> KeeperException, InterruptedException</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        ......</span><br><span class="line"></span><br><span class="line">        RequestHeader h = <span class="keyword">new</span> RequestHeader();</span><br><span class="line">        h.setType(ZooDefs.OpCode.exists);</span><br><span class="line">        ExistsRequest request = <span class="keyword">new</span> ExistsRequest();</span><br><span class="line">        request.setPath(serverPath);</span><br><span class="line">        request.setWatch(watcher != <span class="keyword">null</span>);</span><br><span class="line">        SetDataResponse response = <span class="keyword">new</span> SetDataResponse();</span><br><span class="line">        ReplyHeader r = cnxn.submitRequest(h, request, response, wcb);</span><br><span class="line"></span><br><span class="line">        ......</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p><img src="../../image/zookeeper/zookeeper客户端watcher注册流程.jpeg" alt="zookeeper原理框架"><br>总的来说就是针对不同API进行类似的请求标记，watcher封装，然后将请求放入队列等待(SendThread)调度后发送到服务端。  </p>
<ol>
<li>服务端注册流程<br>server端接收到请求后的处理流程：<br><img src="../../image/zookeeper/zookeeper注册server端流程.jpeg" alt="zookeeper原理框架">   </li>
</ol>
<p><em>FinalRequestProcessor</em><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * This Request processor actually applies any transaction associated with a</span></span><br><span class="line"><span class="comment"> * request and services any queries. It is always at the end of a</span></span><br><span class="line"><span class="comment"> * RequestProcessor chain (hence the name), so it does not have a nextProcessor</span></span><br><span class="line"><span class="comment"> * member.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * This RequestProcessor counts on ZooKeeperServer to populate the</span></span><br><span class="line"><span class="comment"> * outstandingRequests member of ZooKeeperServer.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FinalRequestProcessor</span> <span class="keyword">implements</span> <span class="title">RequestProcessor</span> </span>&#123;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">```  </span><br><span class="line">由源码可知：FinalRequestProcessor为服务端统一处理类，客户端所有操作及请求最终都会在此进行相应流程处理。以exists为例：</span><br><span class="line">```Java</span><br><span class="line"><span class="keyword">case</span> OpCode.exists: &#123;</span><br><span class="line">    lastOp = <span class="string">"EXIS"</span>;</span><br><span class="line">    <span class="comment">// TODO we need to figure out the security requirement for this!</span></span><br><span class="line">    ExistsRequest existsRequest = <span class="keyword">new</span> ExistsRequest();</span><br><span class="line">    ByteBufferInputStream.byteBuffer2Record(request.request,</span><br><span class="line">            existsRequest);</span><br><span class="line">    String path = existsRequest.getPath();</span><br><span class="line">    <span class="keyword">if</span> (path.indexOf(<span class="string">'\0'</span>) != -<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> KeeperException.BadArgumentsException();</span><br><span class="line">    &#125;</span><br><span class="line">    Stat stat = zks.getZKDatabase().statNode(path, existsRequest</span><br><span class="line">            .getWatch() ? cnxn : <span class="keyword">null</span>);</span><br><span class="line">    rsp = <span class="keyword">new</span> ExistsResponse(stat);</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>由源码可知，watcher最后会经由ZKDatabase的statNode进行操作。根据源码追寻可知：</p>
<p><em>ZKDatabase</em><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * This class implements a simple standalone ZooKeeperServer. It sets up the</span></span><br><span class="line"><span class="comment"> * following chain of RequestProcessors to process requests:</span></span><br><span class="line"><span class="comment"> * PrepRequestProcessor -&gt; SyncRequestProcessor -&gt; FinalRequestProcessor</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ZooKeeperServer</span> <span class="keyword">implements</span> <span class="title">SessionExpirer</span>, <span class="title">ServerStats</span>.<span class="title">Provider</span></span>&#123;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Stat <span class="title">statNode</span><span class="params">(String path, ServerCnxn serverCnxn)</span> <span class="keyword">throws</span> KeeperException.NoNodeException </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> dataTree.statNode(path, serverCnxn);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Stat <span class="title">statNode</span><span class="params">(String path, Watcher watcher)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> KeeperException.NoNodeException </span>&#123;</span><br><span class="line">    Stat stat = <span class="keyword">new</span> Stat();</span><br><span class="line">    DataNode n = nodes.get(path);</span><br><span class="line">    <span class="keyword">if</span> (watcher != <span class="keyword">null</span>) &#123;</span><br><span class="line">        dataWatches.addWatch(path, watcher);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (n == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> KeeperException.NoNodeException();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">synchronized</span> (n) &#123;</span><br><span class="line">        n.copyStat(stat);</span><br><span class="line">        <span class="keyword">return</span> stat;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>ZKDatabase是在zookeeper运行时的数据库，server端注册表就存储在此，最后通过dataTree将watcher存储到dataWatches中。  </p>
<p>server端正常存储后返回客户端，在 ClientCnxn$SendThread 类的 readResponse-&gt;finishPacket 方法中会对watcher进行存储。<br>可以看到这边调用了 watchRegistration 的 register 方法，而它就是根据请求类型来装入对应的 watchManager 中了(dataWatches、existWatches、childWatches)。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">finishPacket</span><span class="params">(Packet p)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (p.watchRegistration != <span class="keyword">null</span>) &#123;</span><br><span class="line">            p.watchRegistration.register(p.replyHeader.getErr());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (p.cb == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (p) &#123;</span><br><span class="line">                p.finished = <span class="keyword">true</span>;</span><br><span class="line">                p.notifyAll();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            p.finished = <span class="keyword">true</span>;</span><br><span class="line">            eventThread.queuePacket(p);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="通知-watcher触发"><a href="#通知-watcher触发" class="headerlink" title="通知/watcher触发"></a>通知/watcher触发</h3><h6 id="通知状态和事件类型"><a href="#通知状态和事件类型" class="headerlink" title="通知状态和事件类型"></a>通知状态和事件类型</h6><p>server端通知时主要内容为通知状态(org.apache.zookeeper.Watcher.Event.KeeperState)和事件类型(org.apache.zookeeper.Watcher.Event.EventType)，二者均于WatchedEvent对象内进行传输。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *  A WatchedEvent represents a change on the ZooKeeper that a Watcher</span></span><br><span class="line"><span class="comment"> *  is able to respond to.  The WatchedEvent includes exactly what happened,</span></span><br><span class="line"><span class="comment"> *  the current state of the ZooKeeper, and the path of the znode that</span></span><br><span class="line"><span class="comment"> *  was involved in the event.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WatchedEvent</span> </span>&#123;</span><br><span class="line">  ......</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></p>
<ol>
<li>通知状态   </li>
</ol>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:left">连接状态</th>
<th style="text-align:left">描述  </th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">KeeperState.Disconnected</td>
<td style="text-align:left">当客户端断开连接（与集群中的任何一台断开连接）时的状态就是Disconnected  </td>
</tr>
<tr>
<td style="text-align:left">KeeperState.SyncConnected</td>
<td style="text-align:left">当客户端与zookeeper集群中的任意一台建立连接，这时的事件状态就是SyncConnected  </td>
</tr>
<tr>
<td style="text-align:left">KeeperState.AuthFailed</td>
<td style="text-align:left">客户端进行连接认证失败时，事件状态为AuthFailed</td>
</tr>
<tr>
<td style="text-align:left">KeeperState.ConnectedReadOnly</td>
<td style="text-align:left">当前客户端连接到的zookeeper服务是只读的，此时事件状态是ConnectedReadOnly，这时的客户端只可以进行读操作，而不能进行写操作</td>
</tr>
<tr>
<td style="text-align:left">KeeperState.SaslAuthenticated</td>
<td style="text-align:left">用于通知客户端它们是SASL认证的</td>
</tr>
<tr>
<td style="text-align:left">KeeperState.Expired</td>
<td style="text-align:left">客户端与zookeeper服务端建立连接后每隔一定时间会发送一次心跳检测，当心跳检测没有收到服务端的响应时即认定断开连接，session失效，此时的事件状态就是Expired，如果客户端想访问服务端，需要重新建立连接。  </td>
</tr>
</tbody>
</table>
</div>
<p><font color="red">注意：</font>zookeeper上述状态在触发时，除了SyncConnected会存在包含所有事件的情况，其它状态记录的事件类型都是：EventType.None</p>
<ol>
<li>事件类型</li>
</ol>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:left">zookeeper事件</th>
<th style="text-align:left">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">EventType.NodeCreated</td>
<td style="text-align:left">当节点被创建时，该事件被触发</td>
</tr>
<tr>
<td style="text-align:left">EventType.NodeChildrenChanged</td>
<td style="text-align:left">当节点的直接子节点被创建、被删除、子节点数据发生变更时，该事件被触发</td>
</tr>
<tr>
<td style="text-align:left">EventType.NodeDataChanged</td>
<td style="text-align:left">当节点的数据变化或版本变化时，该事件被触发</td>
</tr>
<tr>
<td style="text-align:left">EventType.NodeDeleted</td>
<td style="text-align:left">当节点被删除时，该事件被触发</td>
</tr>
<tr>
<td style="text-align:left">EventType.None</td>
<td style="text-align:left">当zookeeper客户端的连接状态发生变更时（上面连接状态表格中所列），描述的事件类型为EventType.None</td>
</tr>
</tbody>
</table>
</div>
<ol>
<li>API方法与触发事件关联关系<br>我们以test节点为例</li>
</ol>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:left">注册方式</th>
<th style="text-align:left">NodeCreated</th>
<th style="text-align:left">NodeChildrenChanged</th>
<th style="text-align:left">NodeDataChanged</th>
<th style="text-align:left">NodeDeleted</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">zk.getChildren(“/test”,watcher)</td>
<td style="text-align:left"></td>
<td style="text-align:left">可监控</td>
<td style="text-align:left"></td>
<td style="text-align:left">可监控</td>
</tr>
<tr>
<td style="text-align:left">zk.exists(“/test”,watcher)</td>
<td style="text-align:left">可监控</td>
<td style="text-align:left"></td>
<td style="text-align:left">可监控</td>
<td style="text-align:left">可监控</td>
</tr>
<tr>
<td style="text-align:left">zk.getData(“/test”,watcher)</td>
<td style="text-align:left"></td>
<td style="text-align:left"></td>
<td style="text-align:left">可监控</td>
<td style="text-align:left">可监控</td>
</tr>
</tbody>
</table>
</div>
<p>客户端只能收到服务器发过来的相关事件通知，并不能获取到对应数据节点变化前后的数据。</p>
<h6 id="触发"><a href="#触发" class="headerlink" title="触发"></a>触发</h6><p>我们以setDate方法为例。server端所有的处理均在FinalRequestProcessor里，当请求处理完成后会进行watcher事件的触发。我们以setDate为例追踪下触发的流程。</p>
<p>在FinalRequestProcessor中有这么一段代码：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (request.hdr != <span class="keyword">null</span>) &#123;</span><br><span class="line">   TxnHeader hdr = request.hdr;</span><br><span class="line">   Record txn = request.txn;</span><br><span class="line"></span><br><span class="line">   rc = zks.processTxn(hdr, txn);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>追踪下去就会找到 DataTree 类处理 setData 请求的具体逻辑。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Stat <span class="title">setData</span><span class="params">(String path, <span class="keyword">byte</span> data[], <span class="keyword">int</span> version, <span class="keyword">long</span> zxid,</span></span></span><br><span class="line"><span class="function"><span class="params">            <span class="keyword">long</span> time)</span> <span class="keyword">throws</span> KeeperException.NoNodeException </span>&#123;</span><br><span class="line">    ......</span><br><span class="line">    dataWatches.triggerWatch(path, EventType.NodeDataChanged);</span><br><span class="line">    <span class="keyword">return</span> s;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> Set&lt;Watcher&gt; <span class="title">triggerWatch</span><span class="params">(String path, EventType type, Set&lt;Watcher&gt; supress)</span> </span>&#123;</span><br><span class="line">    WatchedEvent e = <span class="keyword">new</span> WatchedEvent(type,</span><br><span class="line">            KeeperState.SyncConnected, path);</span><br><span class="line">    HashSet&lt;Watcher&gt; watchers;</span><br><span class="line">    <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">        watchers = watchTable.remove(path);</span><br><span class="line">        <span class="keyword">if</span> (watchers == <span class="keyword">null</span> || watchers.isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">if</span> (LOG.isTraceEnabled()) &#123;</span><br><span class="line">                ZooTrace.logTraceMessage(LOG,</span><br><span class="line">                        ZooTrace.EVENT_DELIVERY_TRACE_MASK,</span><br><span class="line">                        <span class="string">"No watchers for "</span> + path);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (Watcher w : watchers) &#123;</span><br><span class="line">            HashSet&lt;String&gt; paths = watch2Paths.get(w);</span><br><span class="line">            <span class="keyword">if</span> (paths != <span class="keyword">null</span>) &#123;</span><br><span class="line">                paths.remove(path);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (Watcher w : watchers) &#123;</span><br><span class="line">        <span class="keyword">if</span> (supress != <span class="keyword">null</span> &amp;&amp; supress.contains(w)) &#123;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        w.process(e);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> watchers;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>可以看到逻辑处理完会调用triggerWatch方法，此方法的作用就是从server端的watchManager中获取watcher并在watchTable 和 watch2Paths 中移除自身，所以 watcher 是单次的。  </p>
<p>最后将封装好的通知即源码中的 e 对象放入watcher的process方法中，process的作用其实就是去发送通知。以 Watcher的一个实现类NioServerCnxn 为例就是调用了其 sendResponse 方法将通知事件发送到客户端，发送前会将 watchedEvent 转换成 watcherEvent 进行发送。</p>
<p>客户端最后会将通知交由EventThread进行对应watcher的process方法调用。</p>
<p>至此，zookeeper 的整个 watcher 交互逻辑就已经结束了。</p>

          
        
      
    </div>

    
    
    
      <footer class="post-footer">
          <div class="post-eof"></div>
        
      </footer>
  </div>
  
  
  
  </article>

    
      

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="cmeng001.github.io/2020/08/17/algorithm/浅析最好、最坏、平均、均摊时间复杂度/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="cmeng">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="c萌怪谈">
    </span>
      <header class="post-header">

        
          <h1 class="post-title" itemprop="name headline">
              
              <a href="/2020/08/17/algorithm/浅析最好、最坏、平均、均摊时间复杂度/" class="post-title-link" itemprop="url">浅析最好、最坏、平均、均摊时间复杂度</a>
            
          </h1>
        

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              
                
              

              <time title="创建时间：2020-08-17 16:13:12" itemprop="dateCreated datePublished" datetime="2020-08-17T16:13:12+08:00">2020-08-17</time>
            </span>
          
            

            
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-08-27 21:20:48" itemprop="dateModified" datetime="2020-08-27T21:20:48+08:00">2020-08-27</time>
              </span>
            
          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/算法/" itemprop="url" rel="index"><span itemprop="name">算法</span></a></span>

                
                
              
            </span>
          

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          
            <p>对大O复杂度分析有一定基础的情况，可以进一步了解 <strong>最好情况时间复杂度</strong>（best case time complexity）、 <strong>最坏情况时间复杂度</strong>（worst case time complexity）、 <strong>平均情况时间复杂度</strong>（average case time complexity）、 <strong>均摊时间复杂度</strong>（amortized time complexity）。如果这几个概念你都能掌握，那对你来说，复杂度分析这部分内容就没什么大问题了。</p>
<h2 id="1、最好、最坏时间复杂度"><a href="#1、最好、最坏时间复杂度" class="headerlink" title="1、最好、最坏时间复杂度"></a>1、最好、最坏时间复杂度</h2><p>先分析下下面的例子：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">find</span> <span class="params">(<span class="keyword">int</span>[] array,<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> pos = -<span class="number">1</span>;</span><br><span class="line">  <span class="keyword">for</span> (i=<span class="number">0</span>;i&lt;array.length;i++)&#123;</span><br><span class="line">    <span class="keyword">if</span>(array[i] == x) &#123;</span><br><span class="line">      pos = i;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>按照大O分析法，这段代码的复杂度就为O(n)；n代表数组的长度。但其实我们在查找数组中某个元素时，不一定非要把整个数组都遍历一遍，可以进行简单优化，如：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">find</span> <span class="params">(<span class="keyword">int</span>[] array,<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> pos = -<span class="number">1</span>;</span><br><span class="line">  <span class="keyword">for</span> (i=<span class="number">0</span>;i&lt;array.length;i++)&#123;</span><br><span class="line">    <span class="keyword">if</span>(array[i] == x) &#123;</span><br><span class="line">      pos = i;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>优化后的代码的时间复杂度还是O(n)吗？其实看一下也不尽然。这样就可以引进三个新的概念：最好时间复杂度、最坏时间复杂度和平均时间复杂度。<br>可以比较直观的分析得到两种情况：</p>
<ul>
<li>当x位于数组的最前面的下标，极端一些就在下标0的位置，那么时间复杂度就为O(1)，这就是最好时间复杂度。</li>
<li>另一种情况则是所查询的x不存在与数组之中，那么就要遍历整个数组，这样时间复杂度就为O(n)。这种极度糟糕的情况对应的就是最坏时间复杂度。</li>
</ul>
<h2 id="2、平均时间复杂度"><a href="#2、平均时间复杂度" class="headerlink" title="2、平均时间复杂度"></a>2、平均时间复杂度</h2><p>依旧拿上面例子为主，发生最好和最坏的情况的概率还是很小的。为了更好的表示平均情况下的时间复杂度，就需要引入一个新的概念：平均情况时间复杂度，简称平均时间复杂度。</p>
<p>我们知道要找的x在数组和不在数组的准确概率计算是极其复杂的，我们概括性的假设二者的概率均为1/2。另外查找的x出现在0~(n-1)这n个位置的概率为1/n。那么考虑在数组或不在数组的概率，根据概率乘积法则，x出现在0~(n-1)这n个位置的概率为1/2n，由此可以推到出以下公式：<br><img src="/image/algorithm/平均时间复杂度.jpg" alt="推到公式">  </p>
<p>这个值就是概率论中的加权平均值，也叫作期望值，所以平均时间复杂度的全称应该叫加权平均时间复杂度或者期望时间复杂度。用大 O 表示法来表示，去掉系数和常量，这段代码的加权平均时间复杂度仍然是 O(n)。  </p>
<p>平均时间复杂度看起来很复杂，又是引入概率又是需要推导。不过平常情况下只需要一种复杂度就可以满足需求。除非是在同一个代码块因不同情况出现，时间复杂度有量级上的差距，才需要用这三种时间复杂度进行分析。  </p>
<h2 id="3、均摊时间复杂度"><a href="#3、均摊时间复杂度" class="headerlink" title="3、均摊时间复杂度"></a>3、均摊时间复杂度</h2><p>均摊复杂度听起来和平均时间复杂度十分相似，而且也经常容易混淆。那具体均摊复杂度是什么呢？我们还是通过具体例子来了解一下，以及它的分析方法：摊还分析/平摊分析.<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span>[] array = <span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line"><span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">(<span class="keyword">int</span> element)</span></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> sum;</span><br><span class="line">  <span class="keyword">if</span>(count==array.length)&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;array.length;i++)&#123;</span><br><span class="line">      sum = sum + array[i];</span><br><span class="line">    &#125;</span><br><span class="line">    array[<span class="number">0</span>] = sum;</span><br><span class="line">    count = <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  array[count] = element;</span><br><span class="line">  count++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>上面是一个很简单的数组插入数据的代码块，当数组满了时，将数组所有内容求和放入下标为0的位置，再继续插入数据。按照大O分析法，我们进行最好、最坏和平均时间复杂度分析。</p>
<p>通过分析代码，我们可知。只有在数组满时才会进行数组遍历并求和，此时的时间复杂度为O(n)，其余时间的复杂度均为O(1)。所以最坏时间复杂度为O(n)，最好时间复杂度为O(1)。<br>那么接下来进行平均时间复杂度分析。假设插入的数组位于0~(n-1)间位置的概率是一样的均为1/n，由此推导出平均时间复杂度为O(1)，以下为推导过程：<br><img src="/image/algorithm/平均时间复杂度-1.jpg" alt="推到公式">    </p>
<p>到此最好、最坏、平均时间复杂度进阶推导出来，其实这个例子的时间复杂度大可不必如此麻烦，还引入概率。我们仔细分析一下find()和insert()两个方法的区别。</p>
<ul>
<li>O(n)的出现是小概率事件，O(1)反而出现的概率很大。</li>
<li>O(n)和O(1)出现是极其有规律的。当出现一次O(n)后，后面就会跟着n-1个O(1)。循环往复。  </li>
</ul>
<p>这种情况其实就没必要引入概率来进行平均时间复杂度的计算。针对这种特殊的场景，引入一种更简单的分析方法：摊还分析法，由此引出新的时间复杂度：摊还时间复杂度。具体分析如下：在了解O(n)和O(1)出现的规律后，可以把耗时多的O(n)的时间均摊到接下来的n-1次操作上，这样下来，摊还时间复杂度就为O(1)。</p>
<p>摊还时间复杂度可以针对特殊的场景进行简单化的分析，如：针对特殊的数据结构，在一段连续操作的代码块中，其中大多数操作耗时很短，只有极少数的操作耗时较长，就可以针对性的适用摊还分析进行时间复杂度分析。个人认为摊还时间复杂度可以算作一种特殊的评价时间复杂度</p>

          
        
      
    </div>

    
    
    
      <footer class="post-footer">
          <div class="post-eof"></div>
        
      </footer>
  </div>
  
  
  
  </article>

    
      

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="cmeng001.github.io/2019/08/12/Redis/redis持久化/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="cmeng">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="c萌怪谈">
    </span>
      <header class="post-header">

        
          <h1 class="post-title" itemprop="name headline">
              
              <a href="/2019/08/12/Redis/redis持久化/" class="post-title-link" itemprop="url">redis持久化</a>
            
          </h1>
        

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              
                
              

              <time title="创建时间：2019-08-12 15:25:11" itemprop="dateCreated datePublished" datetime="2019-08-12T15:25:11+08:00">2019-08-12</time>
            </span>
          
            

            
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-08-18 16:04:32" itemprop="dateModified" datetime="2020-08-18T16:04:32+08:00">2020-08-18</time>
              </span>
            
          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/Redis/" itemprop="url" rel="index"><span itemprop="name">Redis</span></a></span>

                
                
              
            </span>
          

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          
            <h1 id="Redis"><a href="#Redis" class="headerlink" title="Redis"></a>Redis</h1><ul>
<li>Redis作为一个键值对内存数据库(Nosql)，它的强大性能很大程度上是因为所有数据都存储在内存当中，很显然<br>如果服务器重启(各种因素导致)，内存中存储的所有数据都会丢失，而且不光是重启，守护进程退出，数据一样会<br>丢失，现在Redis用作存储的业务场景变多，数据丢失对业务是致命的影响，如：<ol>
<li>缓存的应用场景，如果大量缓存数据丢失，往往导致后端存储组件”打死“，应用程序雪崩的情况。</li>
<li>Redis存储的应用场景，数据丢失是不能接受的;</li>
</ol>
</li>
</ul>
<h1 id="Redis持久化方案"><a href="#Redis持久化方案" class="headerlink" title="Redis持久化方案"></a>Redis持久化方案</h1><h3 id="redis提供了两种持久化的方案，分别是RDB和AOF"><a href="#redis提供了两种持久化的方案，分别是RDB和AOF" class="headerlink" title="redis提供了两种持久化的方案，分别是RDB和AOF"></a>redis提供了两种持久化的方案，分别是RDB和AOF</h3><h2 id="RDB："><a href="#RDB：" class="headerlink" title="RDB："></a>RDB：</h2><h5 id="RDB是一种快照存储持久化方式，将Redis内存中的数据保存到硬盘的文件中，生产的RDB文件是一个经过压缩的二进制文件，默认保存的文件名为dump-rdb，redis启动时会自动载入。"><a href="#RDB是一种快照存储持久化方式，将Redis内存中的数据保存到硬盘的文件中，生产的RDB文件是一个经过压缩的二进制文件，默认保存的文件名为dump-rdb，redis启动时会自动载入。" class="headerlink" title="RDB是一种快照存储持久化方式，将Redis内存中的数据保存到硬盘的文件中，生产的RDB文件是一个经过压缩的二进制文件，默认保存的文件名为dump.rdb，redis启动时会自动载入。"></a>RDB是一种快照存储持久化方式，将Redis内存中的数据保存到硬盘的文件中，生产的RDB文件是一个经过压缩的二进制文件，默认保存的文件名为dump.rdb，redis启动时会自动载入。</h5><h6 id="RDB实现方式有两种，手动执行和服务器配置定期执行"><a href="#RDB实现方式有两种，手动执行和服务器配置定期执行" class="headerlink" title="RDB实现方式有两种，手动执行和服务器配置定期执行"></a>RDB实现方式有两种，手动执行和服务器配置定期执行</h6><ul>
<li>手动执行有两个命令可用于生成RDB文件，SAVE和BGSAVE<ol>
<li>SAVE命令，但SAVE命令会阻塞服务进程，阻塞其它命令，直到RDB文件创建完成，才执行。如若数据量较大不建议使用该命令。</li>
<li>BGSAVE命令，与SAVE不同，BGSAVE是通过派生子进程来实现的，主进程依旧可以接收命令，但派生子进程是同步的，所以派生子进程过程较长(一版很快)也会出现阻塞的情况。</li>
</ol>
</li>
<li>BGSAVE命令执行过程中，无法同时执行SAVE和BESAVE，避免产生竞争条件。</li>
<li><p>服务器配置定时执行</p>
<figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">save <span class="number">900</span> <span class="number">1</span>      <span class="comment">// 900内,有1条写入,则产生快照 </span></span><br><span class="line">save <span class="number">300</span> <span class="number">1000</span>   <span class="comment">// 如果300秒内有1000次写入,则产生快照</span></span><br><span class="line">save <span class="number">60</span> <span class="number">10000</span>  <span class="comment">// 如果60秒内有10000次写入,则产生快照</span></span><br></pre></td></tr></table></figure>
<p>通过配置文件进行触发，如上所示，根据操作次数进行触发，redis服务器的周期性函数serverCorn会每一百毫秒进行一次，它的工作之前就是判断是否满足配置参数条件，如果满足就执行BGSAVE命令。<br>RDB其它相关配置</p>
<figure class="highlight gams"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">stop-writes-on-bgsave-error <span class="keyword">yes</span>  <span class="comment">// 后台备份进程出错时,主进程停不停止写入?</span></span><br><span class="line">   rdbcompression <span class="keyword">yes</span>    <span class="comment">// 导出的rdb文件是否压缩</span></span><br><span class="line">   Rdbchecksum   <span class="keyword">yes</span> <span class="comment">//  导入rbd恢复时数据时,要不要检验rdb的完整性</span></span><br><span class="line">   dbfilename dump.rdb  <span class="comment">//导出来的rdb文件名</span></span><br><span class="line">   dir ./  <span class="comment">//rdb的放置路径</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="AOF"><a href="#AOF" class="headerlink" title="AOF"></a>AOF</h2><h5 id="AOF-Append-Only-File-，与RDB某个时刻的快照不同，AOF持久化会记录每次操作，形成后缀为aof的文件，类似mysql的binlog。在重启后会通过运行aof文件，以达到回复文件的目的。相较而言会对redis性能有些影响，但大部分情况是可接受的"><a href="#AOF-Append-Only-File-，与RDB某个时刻的快照不同，AOF持久化会记录每次操作，形成后缀为aof的文件，类似mysql的binlog。在重启后会通过运行aof文件，以达到回复文件的目的。相较而言会对redis性能有些影响，但大部分情况是可接受的" class="headerlink" title="AOF(Append-Only File)，与RDB某个时刻的快照不同，AOF持久化会记录每次操作，形成后缀为aof的文件，类似mysql的binlog。在重启后会通过运行aof文件，以达到回复文件的目的。相较而言会对redis性能有些影响，但大部分情况是可接受的."></a>AOF(Append-Only File)，与RDB某个时刻的快照不同，AOF持久化会记录每次操作，形成后缀为aof的文件，类似mysql的binlog。在重启后会通过运行aof文件，以达到回复文件的目的。相较而言会对redis性能有些影响，但大部分情况是可接受的.</h5><ul>
<li><p>Redis默认不开启AOF持久化方式，我们可以在配置文件中开启</p>
  <figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">appendonly</span> <span class="literal">no</span> <span class="comment"># 是否打开 aof日志功能</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>AOF持久化的实现可分为三步，追加(append)、文件写入、文件同步(sync)</p>
<ol>
<li><p>命令追加，服务器每次操作都会以redis的协议方式形成二进制文件，追加到aof_buf缓冲区的末尾。</p>
<figure class="highlight thrift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">redisServer</span></span>&#123;</span><br><span class="line">    sds aof_buf;<span class="comment">/* AOF buffer, written before entering the event loop */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>文件写入与同步<br>redis服务器进程就是一个事件循环函数，每次循环结束前，都会调用<br>flushAppendOnlyFile()，考虑是否将aof缓冲区中的内容写入到aof文件当中，flushAppendOnlyFile()函数的行为由配置appendfsync参数控制，一共如下三种策略，缺省情况下默认为everysec策略。<br>缓冲区确实提高了效率，但也存在一定安全问题，如果发生停机，那么缓冲区的数据也会丢失，为此redis提供了两个同步函数，fsync和fdatasync，强制将缓冲区的数据写入到硬盘文件。</p>
<figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">appendfsync</span> always   <span class="comment"># 每1个命令,都立即同步到aof. 安全,速度慢</span></span><br><span class="line">appendfsync everysec <span class="comment"># 折衷方案,每秒写1次</span></span><br><span class="line">appendfsync <span class="literal">no</span> <span class="comment">#写入工作交给操作系统,由操作系统判断缓冲区大小,统一写入到aof. 同步频率低,速度快</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>AOF文件载入与还原<br>aof文件已经包含所有操作命令，所以数据还原其实就是再次执行一次aof中的命令。步骤：<br>1) 创建一个不带网络伪客户端，因为redis命令只能在客户端执行，并且执行命令来源于aof文件。<br>2) 从aof文件中读取一条命令<br>3) 在伪客户端执行<br>4) 反复执行二三步，直至aof文件中的命令执行完毕</p>
</li>
</ol>
</li>
<li><p>AOF重写</p>
<ol>
<li><p>因为aof会把每一步操作都记录到文件，aof文件会越来越大，数据还原时间会越来越长。<br>如下命令操作为了记录list键的状态，aof文件就保存了五条命令，为了解决aof文件膨胀的问题，redis提供了重写(rewrite)机制，通过重写aof，可以生成一个恢复当前redis中数据的最少命令集，比如上面五条就可以合为一条。虽然功能命名为”aof文件重写”，但实际不会对aof文件进行分析处理，而是根据数据库状态来实现的。</p>
<figure class="highlight q"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">RPUSH <span class="built_in">enlist</span> <span class="string">"A"</span> <span class="string">"B"</span></span><br><span class="line">RPUSH <span class="built_in">enlist</span> <span class="string">"C"</span> <span class="string">"V"</span></span><br><span class="line">RPUSH <span class="built_in">enlist</span> <span class="string">"D"</span> <span class="string">"G"</span></span><br><span class="line">LPOP <span class="built_in">enlist</span> <span class="string">"G"</span></span><br><span class="line">LPOP list <span class="string">"A"</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>重写策略<br>2.1配置文件方式：<br>默认情况下是不开启重写的,打开后每次fsync都会进行rewrite</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="literal">no</span><span class="bullet">-appendfsync-on-rewrite</span> <span class="literal">no</span></span><br></pre></td></tr></table></figure>
<p>当然单独配置会比较影响服务器性能，所以可以与另外两个参数一起配置，三个参数一起配置就可以控制rewrite的运行时机，此逻辑也是通过serverCron()函数进行判断控制的</p>
<figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span>-aof-rewrite-percentage <span class="number">100</span> <span class="meta">#aof文件大小比起上次重写时的大小</span></span><br><span class="line">                                增长率<span class="number">100</span>%时,重写</span><br><span class="line"><span class="keyword">auto</span>-aof-rewrite-<span class="built_in">min</span>-<span class="built_in">size</span> <span class="number">64</span>mb <span class="meta">#aof文件,至少超过64M时,重写</span></span><br></pre></td></tr></table></figure>
<p>2.2 手动触发<br>客户端向服务器发送BGREWRITEAOF命令，也可以让服务器进行AOF重写。并且是异步进行<br>注：BGREWRITEAOF正在执行，客户端发送BGSAVE命令会被服务器拒绝，BGSAVE正在执行，客户端发送BGREWRITEAOF，两者在操作上没有冲突，只是都是由子进程进行工作，不能同时执行只是性能方面的考虑——并发两个线程，并且都是大量磁盘写入工作。</p>
</li>
</ol>
</li>
<li><p>AOF文件破损<br>因服务宕机会造成aof文件格式紊乱，这种情况下服务会拒绝加载aof文件，出现文件损坏的情况可以通过以下命令进行修复</p>
  <figure class="highlight gams"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">$</span> redis-check-aof -fix <span class="keyword">file</span>.aof</span><br></pre></td></tr></table></figure>
<p>  重启服务后可重新载入aof文件进行数据恢复。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2></li>
<li>RDB<ol>
<li>RDB相较AOF而言，恢复数据快，数据紧凑</li>
<li>SAVE命令容易阻塞服务器，影响性能，BGSAVE虽然由子进行进行工作，但数据量较大时，也会有影响</li>
<li>容易造成某时间段数据丢失</li>
</ol>
</li>
<li>AOF<ol>
<li>AOF为追加操作记录形式，对服务器影响小，速度快</li>
<li>数据量大时，AOF文件体积太大，恢复慢，即使通过重写，文件体积依然较大。</li>
</ol>
</li>
<li>具体选择哪种方式就需要根据具体场景需求进行选择，当然也可以两种方式配合进行，但redis会优先使用AOF文件方式恢复数据，因为AOF文件保存数据比较完整。</li>
</ul>
<p><img src="https://user-gold-cdn.xitu.io/2019/6/26/16b918cd860b0ffd?imageslim" alt="Alt"></p>
<hr>
<h3 id="源码资料"><a href="#源码资料" class="headerlink" title="源码资料"></a>源码资料</h3><p><a href="https://github.com/huangz1990/redis-3.0-annotated.git" target="_blank" rel="noopener">https://github.com/huangz1990/redis-3.0-annotated.git</a></p>
<h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><p><a href="https://juejin.im/post/5d09a9ff51882577eb133aa9#heading-7" target="_blank" rel="noopener">https://juejin.im/post/5d09a9ff51882577eb133aa9#heading-7</a></p>

          
        
      
    </div>

    
    
    
      <footer class="post-footer">
          <div class="post-eof"></div>
        
      </footer>
  </div>
  
  
  
  </article>

    
  </section>

  


          </div>
          

        </div>
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      <div class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">

          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image"
      src="/images/avatar.jpg"
      alt="cmeng">
  <p class="site-author-name" itemprop="name">cmeng</p>
  <div class="site-description motion-element" itemprop="description"></div>
</div>
  <nav class="site-state motion-element">
      <div class="site-state-item site-state-posts">
        
          <a href="/archives/">
        
          <span class="site-state-item-count">5</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
    
      
      
      <div class="site-state-item site-state-categories">
        
        
        
          
        
          
        
          
        
          
        
        <span class="site-state-item-count">4</span>
        <span class="site-state-item-name">分类</span>
        
      </div>
    
      
      
      <div class="site-state-item site-state-tags">
        
          
            <a href="/tags/">
          
        
        
        
          
        
          
        
          
        
          
        
        <span class="site-state-item-count">4</span>
        <span class="site-state-item-name">标签</span>
        </a>
      </div>
    
  </nav>



        </div>
      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2021</span>
  <span class="with-love" id="animate">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">cmeng</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io" class="theme-link" rel="noopener" target="_blank">Hexo</a> 强力驱动 v3.9.0</div>
  <span class="post-meta-divider">|</span>
  <div class="theme-info">主题 – <a href="https://theme-next.org" class="theme-link" rel="noopener" target="_blank">NexT.Muse</a> v7.3.0</div>

        








        
      </div>
    </footer>
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
      </div>

    

  </div>

  
  <script src="/lib/jquery/index.js?v=3.4.1"></script>
  <script src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  <script src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>

<script src="/js/utils.js?v=7.3.0"></script>
  <script src="/js/motion.js?v=7.3.0"></script>


  <script src="/js/schemes/muse.js?v=7.3.0"></script>


<script src="/js/next-boot.js?v=7.3.0"></script>




  




























  

  
    
      
    
      
        
      
    
      
    
      
    
      
    
  
    
      <script type="text/x-mathjax-config">

  MathJax.Hub.Config({
    tex2jax: {
      inlineMath: [ ['$', '$'], ['\\(', '\\)'] ],
      processEscapes: true,
      skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
    },
    TeX: {
      equationNumbers: {
        autoNumber: 'AMS'
      }
    }
  });

  MathJax.Hub.Register.StartupHook('TeX Jax Ready', function() {
    MathJax.InputJax.TeX.prefilterHooks.Add(function(data) {
      if (data.display) {
        var next = data.script.nextSibling;
        while (next && next.nodeName.toLowerCase() === '#text') {
          next = next.nextSibling;
        }
        if (next && next.nodeName.toLowerCase() === 'br') {
          next.parentNode.removeChild(next);
        }
      }
    });
  });

  MathJax.Hub.Queue(function() {
    var all = MathJax.Hub.getAllJax(), i;
    for (i = 0; i < all.length; i += 1) {
      element = document.getElementById(all[i].inputID + '-Frame').parentNode;
      if (element.nodeName.toLowerCase() == 'li') {
        element = element.parentNode;
      }
      element.classList.add('has-jax');
    }
  });
</script>
<script>
  NexT.utils.getScript('//cdn.jsdelivr.net/npm/mathjax@2/MathJax.js?config=TeX-AMS-MML_HTMLorMML', function() {
    MathJax.Hub.Typeset();
  }, window.MathJax);
</script>

    
  

  

  


  
</body>
</html>
