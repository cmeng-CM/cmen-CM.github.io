<!DOCTYPE html>





<html class="theme-next muse use-motion" lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="generator" content="Hexo 3.9.0">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=7.3.0">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32.ico?v=7.3.0">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16.ico?v=7.3.0">
  <link rel="mask-icon" href="/images/logo.svg?v=7.3.0" color="#222">

<link rel="stylesheet" href="/css/main.css?v=7.3.0">


<link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css?v=4.7.0">


<script id="hexo-configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Muse',
    version: '7.3.0',
    exturl: false,
    sidebar: {"position":"right","display":"post","offset":12,"onmobile":false},
    back2top: {"enable":true,"sidebar":false,"scrollpercent":false},
    save_scroll: false,
    copycode: {"enable":false,"show_result":false,"style":null},
    fancybox: false,
    mediumzoom: false,
    lazyload: false,
    pangu: false,
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    },
    localsearch: {"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},
    path: '',
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    translation: {
      copy_button: '复制',
      copy_success: '复制成功',
      copy_failure: '复制失败'
    }
  };
</script>

  <meta property="og:type" content="website">
<meta property="og:title" content="c萌怪谈">
<meta property="og:url" content="cmeng001.github.io/index.html">
<meta property="og:site_name" content="c萌怪谈">
<meta property="og:locale" content="zh-CN">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="c萌怪谈">
  <link rel="canonical" href="cmeng001.github.io/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome: true,
    isPost: false,
    isPage: false,
    isArchive: false
  };
</script>

  <title>c萌怪谈</title>
  








  <noscript>
  <style>
  .use-motion .motion-element,
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-title { opacity: initial; }

  .use-motion .logo,
  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-CN">

  <div class="container sidebar-position-right">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta">

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">c萌怪谈</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
        <p class="site-subtitle">奇葩事迹、奇趣怪谈、记录一切新奇怪异。</p>
      
  </div>

  <div class="site-nav-toggle">
    <button aria-label="切换导航栏">
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>


<nav class="site-nav">
  
  <ul id="menu" class="menu">
      
      
      
        
        <li class="menu-item menu-item-home">
      
    

    <a href="/" rel="section"><i class="menu-item-icon fa fa-fw fa-home"></i> <br>首页</a>

  </li>
      
      
      
        
        <li class="menu-item menu-item-categories">
      
    

    <a href="/categories/" rel="section"><i class="menu-item-icon fa fa-fw fa-th"></i> <br>分类</a>

  </li>
      
      
      
        
        <li class="menu-item menu-item-archives">
      
    

    <a href="/archives/" rel="section"><i class="menu-item-icon fa fa-fw fa-archive"></i> <br>归档</a>

  </li>
      
      
      
        
        <li class="menu-item menu-item-tags">
      
    

    <a href="/tags/" rel="section"><i class="menu-item-icon fa fa-fw fa-tags"></i> <br>标签</a>

  </li>
      
      
      
        
        <li class="menu-item menu-item-about">
      
    

    <a href="/about/" rel="section"><i class="menu-item-icon fa fa-fw fa-user"></i> <br>关于</a>

  </li>
  </ul>

    

</nav>
</div>
    </header>

    


    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content page-home">
            
  <section id="posts" class="posts-expand">
      

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="cmeng001.github.io/2022/07/17/theoretical_knowledge/concurrency_model/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="cmeng">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="c萌怪谈">
    </span>
      <header class="post-header">

        
          <h1 class="post-title" itemprop="name headline">
              
              <a href="/2022/07/17/theoretical_knowledge/concurrency_model/" class="post-title-link" itemprop="url">并发模型比较</a>
            
          </h1>
        

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              
                
              

              <time title="创建时间：2022-07-17 16:13:12" itemprop="dateCreated datePublished" datetime="2022-07-17T16:13:12+08:00">2022-07-17</time>
            </span>
          
            

            
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-08-03 22:23:06" itemprop="dateModified" datetime="2022-08-03T22:23:06+08:00">2022-08-03</time>
              </span>
            
          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/理论知识/" itemprop="url" rel="index"><span itemprop="name">理论知识</span></a></span>

                
                
                  ，
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/理论知识/并发相关/" itemprop="url" rel="index"><span itemprop="name">并发相关</span></a></span>

                
                
              
            </span>
          

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          
            <h2 id="一、进程、线程、协程"><a href="#一、进程、线程、协程" class="headerlink" title="一、进程、线程、协程"></a>一、进程、线程、协程</h2><h3 id="1-1、进程"><a href="#1-1、进程" class="headerlink" title="1.1、进程"></a>1.1、进程</h3><p><strong>进程：</strong> 是系统进行资源分配的一个独立单位，内核通过进程控制块（PCB，process control block）来感知进程。</p>
<blockquote>
<p>一个计算机系统进程包括（或者说“拥有”）下列资料：</p>
<blockquote>
<ul>
<li>那个程序的可执行机器代码的一个在存储器的映像。</li>
<li>分配到的存储器（通常是虚拟的一个存储器区域）。存储器的内容包括可执行代码、特定于进程的资料（输入、输出）、调用堆栈、堆栈（用于保存运行时运输中途产生的资料）。</li>
<li>分配给该进程的资源的操作系统描述符，诸如文件描述符（Unix术语）或文件句柄（Windows）、资料源和资料终端。</li>
<li>安全特性，诸如进程拥有者和进程的权限集（可以容许的操作）。</li>
<li>处理器状态（内文），诸如寄存器内容、物理存储器寻址等。当进程正在执行时，状态通常存储在寄存器，其他情况在存储器。</li>
</ul>
</blockquote>
</blockquote>
<h3 id="1-2、线程"><a href="#1-2、线程" class="headerlink" title="1.2、线程"></a>1.2、线程</h3><ol>
<li><p>是独立调度和分派的基本单位。内核通过<a href="https://en.wikipedia.org/wiki/Thread_control_block" target="_blank" rel="noopener">线程控制块（TCB，thread control block）</a>来感知线程。  </p>
</li>
<li><p>同一进程中的多条线程将共享该进程中的全部系统资源，如虚拟地址空间，文件描述符和信号处理等等。但同一进程中的多个线程有各自的调用栈（call stack），自己的寄存器环境（register context），自己的线程本地存储（thread-local storage）。</p>
</li>
</ol>
<h3 id="1-3、线程的实现和调度方式"><a href="#1-3、线程的实现和调度方式" class="headerlink" title="1.3、线程的实现和调度方式"></a>1.3、线程的实现和调度方式</h3><h4 id="1-3-1、线程的实现"><a href="#1-3-1、线程的实现" class="headerlink" title="1.3.1、线程的实现"></a>1.3.1、线程的实现</h4><ol>
<li><p><strong>内核支持线程（KST，Kernel Supported Threads）</strong></p>
<ul>
<li>内核级线程的 TCB 保存在内核空间，其创建、阻塞、撤销、切换等活动也都是在内核空间实现的。</li>
<li>内核线程的调度是由内核完成的，一般是抢占式调度。     </li>
</ul>
</li>
<li><p>用户级线程(UST, User Supported Threads)</p>
<ul>
<li>用户级线程则是内核无关的，用户级线程的实现在用户空间，内核感知不到用户线程的存在。</li>
<li>用户线程的调度算法可以是进程专用的，不会被内核调度，但同时，用户线程也无法利用多处理机的并行执行。调度也发生在用户态，一般是由线程库或编程语言运行时自行实现的。</li>
<li>一个拥有多个用户线程的进程，一旦有一个线程阻塞，该进程所有的线程都会被阻塞。</li>
<li>内核的切换需要转换到内核空间，而用户线程不需要，所以前者开销会更大。</li>
<li>用户线程需要内核的支持，一般是通过运行时系统或内核控制线程来连接一个内核线程，有 1:1、1:n、n:m 的不同实现。</li>
</ul>
</li>
</ol>
<h4 id="1-3-2、调度方式"><a href="#1-3-2、调度方式" class="headerlink" title="1.3.2、调度方式"></a>1.3.2、调度方式</h4><p>在分时操作系统中，处理机的调度一般基于时间片的轮转（RR, round robin)，多个就绪线程排成队列，轮流执行时间片。所以进程调度主要有抢占式调度和协作式调度两种：<strong>抢占式(Preemptive)</strong> 与 <strong>协作式(Cooperative)</strong>。</p>
<ol>
<li><p><strong>抢占式(Preemptive)</strong><br>抢占式调度往往在一些重要位置（Sleep Call，Timer Tick）放置了中断信号，通过这个信号通知操作系统调度器(Scheduler)进行进程切换。在抢占式模型中，正在运行的进程可能会被强行挂起，这是由于这些中断信号引发的。</p>
</li>
<li><p><strong>协作式(Cooperative)</strong>。<br>协作式调度也叫非抢占式调度，是指当前运行的进程通过自身代码逻辑出让CPU控制权。与抢占式调度的区别在于进程运行不会被中断信号打断，除非其主动出让控制权给其他进程。  </p>
</li>
<li><p>结构示意图<br><img src="/image/theoretical_knowledge/线程调度方式.png" alt="调度方式"></p>
</li>
</ol>
<h3 id="1-4、协程-Coroutines-Cooperative-User-Level-Threads"><a href="#1-4、协程-Coroutines-Cooperative-User-Level-Threads" class="headerlink" title="1.4、协程(Coroutines - Cooperative User-Level Threads)"></a>1.4、协程(Coroutines - Cooperative User-Level Threads)</h3><p><strong>协程：</strong> 又称微线程，纤程。英文名Coroutine。是应用程序通过线程库自行实现的 <strong>协作式调度</strong> 的运行在用户空间的用户线程，是编译器级别的。<strong>系统的并发是时间片的轮转</strong> ，单处理器交互执行不同的执行流，营造不同线程同时执行的感觉；而 <strong>协程的并发，是单线程内控制权的轮转</strong> 。相比抢占式调度，协程是主动让权，实现协作。</p>
<h2 id="二、并发模型"><a href="#二、并发模型" class="headerlink" title="二、并发模型"></a>二、并发模型</h2><h3 id="2-1、、模型：单进（线）程·循环处理请求"><a href="#2-1、、模型：单进（线）程·循环处理请求" class="headerlink" title="2.1、、模型：单进（线）程·循环处理请求"></a>2.1、、模型：单进（线）程·循环处理请求</h3><p>单进程和单线程其实没有区别，因为一个进程至少有一个线程。循环处理请求应该是最初级的做法。当大量请求进来时，单线程一个一个处理请求，请求很容易就积压起来，得不到响应。这是无并发的做法。</p>
<h3 id="2-2、模型：多进程（Multiprocessing）"><a href="#2-2、模型：多进程（Multiprocessing）" class="headerlink" title="2.2、模型：多进程（Multiprocessing）"></a>2.2、模型：多进程（Multiprocessing）</h3><p>主进程监听和管理连接，当有客户请求的时候，<strong>fork</strong> 一个子进程来处理连接，父进程继续等待其他客户的请求。</p>
<p><strong>优点</strong>：<strong>好处是隔离性</strong>，子进程万一 crash 并不会影响到父进程。<br><strong>缺点</strong>：<strong>缺点就是对系统的负担过重</strong>。  </p>
<p>典型的是 <strong>Apache Web Server</strong>，每个用户请求接入的时候都会创建一个进程，这样应用就可以同时支持多个用户。</p>
<p><img src="/image/theoretical_knowledge/Apache-Web-Server-Thread.jpeg" alt="Apache-Web-Server-Thread"></p>
<p>在图中M1、M2与M3都代表内存资源，在多进程中如果不同进程想共享内存中的数据必须通过 <strong>进程间通信</strong>的方式来实现。</p>
<h3 id="2-3、模型：多线程（Multithreaded）"><a href="#2-3、模型：多线程（Multithreaded）" class="headerlink" title="2.3、模型：多线程（Multithreaded）"></a>2.3、模型：多线程（Multithreaded）</h3><p>在操作系统的视角看，比如Linux中，在进程中创建线程是通过 <strong>clone()</strong> 系统调用来实现，这和创建子进程的区别不大。线程与进程的区别在于同一个进程内的线程共享着进程分配的资源，线程不被分配资源，只是操作系统调度执行任务的抽象的最小单元。</p>
<p>比如下图中，PID为10的进程P0通过clone()系统调用创建了3个线程，这些线程都可以访问进程分配的内存资源M0。<br><img src="/image/theoretical_knowledge/多线程模型.jpeg" alt="多线程模型"></p>
<h4 id="2-3-1、多线程：通信方式——共享内存通信-Shared-memory-communication"><a href="#2-3-1、多线程：通信方式——共享内存通信-Shared-memory-communication" class="headerlink" title="2.3.1、多线程：通信方式——共享内存通信(Shared memory communication)"></a>2.3.1、多线程：通信方式——共享内存通信(Shared memory communication)</h4><p><strong>共享内存通信(Shared memory communication)</strong> ：不同线程间可以访问同一内存地址空间，并可修改此地址空间的数据。</p>
<h5 id="同步-Synchronize-访问"><a href="#同步-Synchronize-访问" class="headerlink" title="同步(Synchronize)访问"></a>同步(Synchronize)访问</h5><p>因为线程间共享内存资源，所以在访问临界区域时会出现数据竞争。解决竞态条件的方式是对数据进行 <strong>同步(Synchronize)访问</strong> 。要实现同步访问常见的方式有：</p>
<pre><code>* **锁(Lock)** ：通过锁定临界区域来实现同步访问。
* **信号量(Semaphores)** ：可以通过信号量的增减控制对一个或多个线程对临界区域的访问。
* **同步屏障(Barriers)** ：通过设置屏障控制不同线程执行周期实现同步访问。  
</code></pre><p><strong>此模型的优点：</strong>  </p>
<ul>
<li>大多编程语言都支持此模型；</li>
<li>贴近硬件架构，使用得当性能很高；</li>
<li>是其他并发模型的基础；</li>
</ul>
<p><strong>此模型的缺点：</strong></p>
<ul>
<li>不支持分布式内存模型，只解决了进程内的并发同步；</li>
<li>不好调试与测试，想用好不容易；    </li>
</ul>
<h5 id="STM-Software-transactional-memory"><a href="#STM-Software-transactional-memory" class="headerlink" title="STM(Software transactional memory)"></a>STM(Software transactional memory)</h5><p>STM是用软件的方式去实现事务内存(Transactional memory)，而事务内存中的事务(Transactional)正是关系型数据库中的概念，一个事务必须满足ACID性质，在STM的事务中尽可能避免副作用，比如在事务中去修改原子变量这种操作，可能会导致事务回滚失败。</p>
<p><strong>此模型的优点：</strong></p>
<ul>
<li>相比锁模型更简单；</li>
<li>大部分情况下更高效；</li>
</ul>
<p><strong>此模型的缺点：</strong></p>
<ul>
<li>在事务内需要避免产生副作用；</li>
<li>不支持分布式内存模型，只解决了进程内的并发同步；</li>
</ul>
<h4 id="2-3-2、多线程：通信方式——消息传递通信-Message-passing-communication"><a href="#2-3-2、多线程：通信方式——消息传递通信-Message-passing-communication" class="headerlink" title="2.3.2、多线程：通信方式——消息传递通信(Message passing communication)"></a>2.3.2、多线程：通信方式——消息传递通信(Message passing communication)</h4><p><strong>消息传递通信(Message passing communication)</strong> ：不同线程间只能通过收发消息的形式去通信，数据只能被拥有它的线程修改。</p>
<h5 id="通信顺序进程-CSP-Communicating-sequential-processes"><a href="#通信顺序进程-CSP-Communicating-sequential-processes" class="headerlink" title="通信顺序进程(CSP(Communicating sequential processes))"></a>通信顺序进程(CSP(Communicating sequential processes))</h5><p><strong>CSP</strong>：是一种形式语言，用来描述基于消息传递通信的安全并发模型。各任务模块之间的通信是基于 <strong>通道(Channel)</strong> 来完成的。<strong>通道可以被不同的任务块共享</strong> 。通道两端任务块的通信可以是<strong>同步的，也可以是异步的</strong>。</p>
<p><strong>此模型的优点：</strong></p>
<ul>
<li>相比锁模型更简单；</li>
<li>很容易实现高并发；</li>
</ul>
<p><strong>此模型的缺点：</strong></p>
<ul>
<li>不支持分布式内存模型，只解决了进程内的并发同步；</li>
</ul>
<h5 id="Actor"><a href="#Actor" class="headerlink" title="Actor"></a>Actor</h5><p><strong>演员模型(Actor)</strong> 是一种类似面向对象编程思想的安全并发模型。Actor模型=数据+行为+消息。Actor模型内部的状态由自己的行为维护，外部线程不能直接调用对象的行为，必须通过消息才能激发行为，这样就保证Actor内部数据只有被自己修改。</p>
<p>相比CSP模型，Actor模型可以跨节点在 <strong>分布式集群中运行</strong>。实际上Actor模型的代表Erlang正是天然分布式容错的编程语言。</p>
<p>二者的区别：Actor之间直接通讯，而CSP是通过Channel通讯，在耦合度上两者是有区别的，后者更加松耦合。</p>
<p><strong>此模型的优点：</strong></p>
<ul>
<li>相比锁模型更简单；</li>
<li>很容易实现高并发；</li>
<li>支持分布式内存模型，能实现跨节点的并发同步；</li>
</ul>
<p><strong>此模型的缺点：</strong></p>
<ul>
<li>存在信箱满后消息丢失的问题;</li>
</ul>
<h3 id="2-4、事件驱动模型"><a href="#2-4、事件驱动模型" class="headerlink" title="2.4、事件驱动模型"></a>2.4、事件驱动模型</h3><p><strong>事件驱动编程</strong> 是一种编程范式，这里程序的执行流由外部事件来决定。它的特点是包含一个事件循环，当外部事件发生时使用回调机制来触发相应的处理。<br><strong>Event Loop with Multiplexing</strong>：此模型巧妙的利用了系统内核提供的I/O多路复用系统调用，将多个socket连接转换成一个事件队列(event queue)，只需要单个线程即可循环处理这个事件队列。当然这个线程是有可能被阻塞或长期占用的，针对这种类型的任务处理可以单独使用一个线程池去做，这样就不会阻塞Event Loop的线程了。</p>
<p><strong>此模型的优点：</strong></p>
<ul>
<li>单线程对系统资源的占用很小；</li>
<li>很容易实现高并发；</li>
</ul>
<p>此模型的缺点：</p>
<ul>
<li>不支持分布式内存模型，只解决了进程内的并发同步；</li>
</ul>
<h2 id="三、总结"><a href="#三、总结" class="headerlink" title="三、总结"></a>三、总结</h2><p>高并发的关键在于实现异步非阻塞，更加高效地利用 CPU，涉及的两大安全难题则是<strong>线程安全</strong>与<strong>内存安全</strong>。多线程可以达到非阻塞，但占用资源多，切换开销大。协程用栈的动态增长、用户态的调度来避免多线程的两个问题。事件驱动用单线程的方式，避免了占用太多系统资源，不需要关心线程安全，但无法利用多核。具体要采用哪种模型，还是要看需求。</p>
<h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><p><a href="https://gobomb.github.io/post/high-concurrency-model/" target="_blank" rel="noopener">https://gobomb.github.io/post/high-concurrency-model/</a><br><a href="https://www.bmpi.dev/dev/deep-in-program-language/how-to-implement-concurrency/concurrency-model/" target="_blank" rel="noopener">https://www.bmpi.dev/dev/deep-in-program-language/how-to-implement-concurrency/concurrency-model/</a>  </p>

          
        
      
    </div>

    
    
    
      <footer class="post-footer">
          <div class="post-eof"></div>
        
      </footer>
  </div>
  
  
  
  </article>

    
      

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="cmeng001.github.io/2021/08/01/医学信息/血分析(血常规)/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="cmeng">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="c萌怪谈">
    </span>
      <header class="post-header">

        
          <h1 class="post-title" itemprop="name headline">
              
              <a href="/2021/08/01/医学信息/血分析(血常规)/" class="post-title-link" itemprop="url">血常规/血分析</a>
            
          </h1>
        

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              
                
              

              <time title="创建时间：2021-08-01 23:13:12 / 修改时间：21:09:41" itemprop="dateCreated datePublished" datetime="2021-08-01T23:13:12+08:00">2021-08-01</time>
            </span>
          
            

            
          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/化验/" itemprop="url" rel="index"><span itemprop="name">化验</span></a></span>

                
                
              
            </span>
          

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          
            <h2 id="血常规相关指标解读"><a href="#血常规相关指标解读" class="headerlink" title="血常规相关指标解读"></a>血常规相关指标解读</h2><p>  按照每项指标进行解读，单纯的单项指标的意义，不具备临床参考意义。具体病因须整体分析。</p>
<h3 id="报告示例"><a href="#报告示例" class="headerlink" title="报告示例"></a>报告示例</h3><p><img src="/image/医学信息/血分析.jpg" alt="血分析"></p>
<h3 id="白细胞（WBC）"><a href="#白细胞（WBC）" class="headerlink" title="白细胞（WBC）"></a>白细胞（WBC）</h3><p>白细胞(white blood cell), 旧称白血球,是血液中一种重要的血细胞。白细胞与红血球，血小板并称三大血细胞。除白细胞外，人体血液中还含有红血球、血小板和血浆。</p>
<p>白细胞也通常被称为免疫细胞, 作为免疫系统的一部分帮助身体抵抗传染病以及外来的病原。正常情况下白细胞在健康成人体内为4×10^9到10×10^9/每升血液。</p>
<p>白细胞无色，呈球形，直径在7～20μm之间。白细胞有细胞核，能作变形运动。白细胞一般有活跃的移动能力，它们可以从血管内迁移到血管外，或从血管外组织迁移到血管内。因此, 除了在血液外，白细胞还存在于淋巴系统、脾以及身体的其它组织中。</p>
<p>由于白细胞的增生失去控制而引起的一种癌症称为“白血病”。</p>
<h4 id="白细胞意义"><a href="#白细胞意义" class="headerlink" title="白细胞意义"></a>白细胞意义</h4><h5 id="正常值范围"><a href="#正常值范围" class="headerlink" title="正常值范围"></a>正常值范围</h5><ul>
<li>成人：（4.0-10.0）×10^9个/L</li>
<li>新生儿：（15-20）×10^9个/L</li>
<li>6个月到2岁：（11-12）×10^9个/L</li>
<li>4到14岁：8×10^9个/L</li>
<li>儿童：（5.0-12.0）×10^9/L<h5 id="临床意义"><a href="#临床意义" class="headerlink" title="临床意义"></a>临床意义</h5>1.升高<br>白细胞计数升高并不完全是疾病的表现，因此有生理性和病理性升高之分。<br>各种细胞感染,炎症,严重烧伤.明显升高时应除外白血病.</li>
<li>降低：白细胞减少症,脾功能亢进,造血功能障碍,放射线,药物,化学毒素等引起骨髓抑制,疟疾,伤寒,病毒感染,副伤寒.</li>
</ul>

          
        
      
    </div>

    
    
    
      <footer class="post-footer">
          <div class="post-eof"></div>
        
      </footer>
  </div>
  
  
  
  </article>

    
      

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="cmeng001.github.io/2021/04/15/mysql/执行计划/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="cmeng">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="c萌怪谈">
    </span>
      <header class="post-header">

        
          <h1 class="post-title" itemprop="name headline">
              
              <a href="/2021/04/15/mysql/执行计划/" class="post-title-link" itemprop="url">未命名</a>
            
          </h1>
        

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              
                
              

              <time title="创建时间：2021-04-15 18:05:10" itemprop="dateCreated datePublished" datetime="2021-04-15T18:05:10+08:00">2021-04-15</time>
            </span>
          
            

            
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-06-09 17:17:01" itemprop="dateModified" datetime="2021-06-09T17:17:01+08:00">2021-06-09</time>
              </span>
            
          

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          
            
          
        
      
    </div>

    
    
    
      <footer class="post-footer">
          <div class="post-eof"></div>
        
      </footer>
  </div>
  
  
  
  </article>

    
      

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="cmeng001.github.io/2020/08/18/docker/mysql/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="cmeng">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="c萌怪谈">
    </span>
      <header class="post-header">

        
          <h1 class="post-title" itemprop="name headline">
              
              <a href="/2020/08/18/docker/mysql/" class="post-title-link" itemprop="url">Docker之MySQL安装</a>
            
          </h1>
        

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              
                
              

              <time title="创建时间：2020-08-18 16:13:12" itemprop="dateCreated datePublished" datetime="2020-08-18T16:13:12+08:00">2020-08-18</time>
            </span>
          
            

            
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-08-24 20:46:23" itemprop="dateModified" datetime="2022-08-24T20:46:23+08:00">2022-08-24</time>
              </span>
            
          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/docker/" itemprop="url" rel="index"><span itemprop="name">docker</span></a></span>

                
                
                  ，
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/docker/mysql/" itemprop="url" rel="index"><span itemprop="name">mysql</span></a></span>

                
                
              
            </span>
          

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          
            <h1 id="docker-安装-mysql"><a href="#docker-安装-mysql" class="headerlink" title="docker 安装 mysql"></a>docker 安装 mysql</h1><h2 id="一、下载镜像"><a href="#一、下载镜像" class="headerlink" title="一、下载镜像"></a>一、下载镜像</h2><p>以最新版为例：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker pull mysql</span><br></pre></td></tr></table></figure></p>
<p>下载后通过 <strong>docker images</strong> 查看：</p>
<blockquote>
<p>REPOSITORY              TAG       IMAGE ID       CREATED        SIZE<br>mysql                   latest    7b94cda7ffc7   2 weeks ago    446MB<br>redis                   latest    7614ae9453d1   8 months ago   113MB</p>
</blockquote>
<h2 id="二、启动mysql容器"><a href="#二、启动mysql容器" class="headerlink" title="二、启动mysql容器"></a>二、启动mysql容器</h2><h3 id="2-1、启动"><a href="#2-1、启动" class="headerlink" title="2.1、启动"></a>2.1、启动</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">docker run -d \</span><br><span class="line">--name mysql-2 \</span><br><span class="line">-p 9000:3306 \</span><br><span class="line">-e MYSQL_ROOT_PASSWORD=123456 \</span><br><span class="line">mysql:latest</span><br></pre></td></tr></table></figure>
<ul>
<li><strong>-d</strong>：后台运行</li>
<li><strong>—name</strong>：设置容器名称</li>
<li><strong>-p</strong>：将主机的9000端口绑定到容器的3306端口，<strong>-p格式：主机(宿主)端口:容器端口</strong></li>
<li><strong>-e</strong>：设置root用户密码</li>
<li><strong>mysql:latest</strong>：指定镜像和版本</li>
</ul>
<h3 id="2-2、数据用户密码加密机制"><a href="#2-2、数据用户密码加密机制" class="headerlink" title="2.2、数据用户密码加密机制"></a>2.2、数据用户密码加密机制</h3><p><strong>mysql8及以上</strong>，需要使用navicat链接的话需要修改用户密码的加密方式，该版本有修改：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ALTER USER &apos;root&apos;@&apos;%&apos; IDENTIFIED WITH mysql_native_password BY &apos;password&apos;;</span><br></pre></td></tr></table></figure></p>
<p>修改后可查看 mysql库下的user表：</p>
<blockquote>
<p>mysql&gt; select host,user,plugin from user;<br>+—————-+—————————+———————————-+<br>| host      | user             | plugin                |<br>+—————-+—————————+———————————-+<br>| %         | root             | mysql_native_password |<br>| localhost | mysql.infoschema | caching_sha2_password |<br>| localhost | mysql.session    | caching_sha2_password |<br>| localhost | mysql.sys        | caching_sha2_password |<br>+—————-+—————————+———————————-+<br>4 rows in set (0.01 sec)</p>
</blockquote>
<h2 id="三、文件挂载"><a href="#三、文件挂载" class="headerlink" title="三、文件挂载"></a>三、文件挂载</h2><p>以为启动容器，但文件及配置信息均在容器内部，为了防止数据丢失可将容器内文件挂在到宿主机上，命令如下：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 将容器中的 mysql 配置文件复制到宿主机中指定路径下，路径你可以根据需要，自行修改</span></span><br><span class="line">docker cp mysql:/etc/mysql/mysql.conf.d/mysqld.cnf /usr/<span class="built_in">local</span>/docker/mysql/config</span><br><span class="line"><span class="comment"># 将容器中的 mysql 存储目录复制到宿主机中</span></span><br><span class="line">docker cp mysql:/var/lib/mysql/ /usr/<span class="built_in">local</span>/docker/mysql/data</span><br></pre></td></tr></table></figure></p>
<p>总和挂在一起创建及启动容器的命令如下：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">docker run -d \</span><br><span class="line">--name mysql \</span><br><span class="line">-p 3306:3306 \</span><br><span class="line">-v /usr/<span class="built_in">local</span>/docker/mysql/config/mysqld.cnf:/etc/mysql/mysql.conf.d/mysqld.cnf \</span><br><span class="line">-v /usr/<span class="built_in">local</span>/docker/mysql/data/mysql:/var/lib/mysql \</span><br><span class="line">-e MYSQL_ROOT_PASSWORD=123456 \</span><br><span class="line">mysql:latest</span><br></pre></td></tr></table></figure></p>
<p>其余命令不变，多了两个 <strong>-v</strong> 参数用于文件挂载。<br>后续即可直接使用数据库。</p>
<h2 id="MySQL配置文件"><a href="#MySQL配置文件" class="headerlink" title="MySQL配置文件"></a>MySQL配置文件</h2><p>通过 <strong>mysql —help</strong> 可以获得以下描述：</p>
<blockquote>
<p>Default options are read from the following files in the given order:<br>/etc/my.cnf /etc/mysql/my.cnf /usr/etc/my.cnf ~/.my.cnf</p>
</blockquote>
<p><strong>/etc/my.cnf</strong> 文件结尾处：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">!includedir /etc/mysql/conf.d/</span><br><span class="line">!includedir /etc/mysql/mysql.conf.d/</span><br></pre></td></tr></table></figure></p>
<p>所以几处的配置文件按照顺序都会加载到mysql中，所以只需求一处即可，因此本文挂载文件为：<strong>/etc/mysql/mysql.conf.d/mysqld.cnf</strong></p>

          
        
      
    </div>

    
    
    
      <footer class="post-footer">
          <div class="post-eof"></div>
        
      </footer>
  </div>
  
  
  
  </article>

    
      

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="cmeng001.github.io/2020/08/18/docker/日常命令/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="cmeng">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="c萌怪谈">
    </span>
      <header class="post-header">

        
          <h1 class="post-title" itemprop="name headline">
              
              <a href="/2020/08/18/docker/日常命令/" class="post-title-link" itemprop="url">docker日常命令</a>
            
          </h1>
        

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              
                
              

              <time title="创建时间：2020-08-18 16:13:12" itemprop="dateCreated datePublished" datetime="2020-08-18T16:13:12+08:00">2020-08-18</time>
            </span>
          
            

            
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-08-30 16:21:57" itemprop="dateModified" datetime="2022-08-30T16:21:57+08:00">2022-08-30</time>
              </span>
            
          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/Docker/" itemprop="url" rel="index"><span itemprop="name">Docker</span></a></span>

                
                
              
            </span>
          

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          
            <h3 id="容器挂载文件相关"><a href="#容器挂载文件相关" class="headerlink" title="容器挂载文件相关"></a>容器挂载文件相关</h3><ol>
<li>查看容器挂的文件信息：<ul>
<li>命令：docker inspect containerID | grep Source -A 1</li>
<li>结果：<blockquote>
<p>“Source”: “/Users/workerspace/mysql/mysql2/mysql”,<br>“Destination”: “/var/lib/mysql”,</p>
<p>“Source”: “/host_mnt/Users/workerspace/mysql/mysql2/mysqld.cnf”,<br>“Destination”: “/etc/mysql/mysql.conf.d/mysqld.cnf”,</p>
</blockquote>
</li>
</ul>
</li>
</ol>

          
        
      
    </div>

    
    
    
      <footer class="post-footer">
          <div class="post-eof"></div>
        
      </footer>
  </div>
  
  
  
  </article>

    
      

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="cmeng001.github.io/2020/08/18/mysql/master-slave-sync/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="cmeng">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="c萌怪谈">
    </span>
      <header class="post-header">

        
          <h1 class="post-title" itemprop="name headline">
              
              <a href="/2020/08/18/mysql/master-slave-sync/" class="post-title-link" itemprop="url">MySQL主从、主主、主备模式</a>
            
          </h1>
        

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              
                
              

              <time title="创建时间：2020-08-18 16:13:12" itemprop="dateCreated datePublished" datetime="2020-08-18T16:13:12+08:00">2020-08-18</time>
            </span>
          
            

            
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-09-07 09:47:30" itemprop="dateModified" datetime="2022-09-07T09:47:30+08:00">2022-09-07</time>
              </span>
            
          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/MySQL/" itemprop="url" rel="index"><span itemprop="name">MySQL</span></a></span>

                
                
                  ，
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/MySQL/同步/" itemprop="url" rel="index"><span itemprop="name">同步</span></a></span>

                
                
              
            </span>
          

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          
            <h2 id="一、主从、主主、主备模式介绍"><a href="#一、主从、主主、主备模式介绍" class="headerlink" title="一、主从、主主、主备模式介绍"></a>一、主从、主主、主备模式介绍</h2><p><img src="/image/mysql/MySQL主主、主从、主备、单点模型.png" alt="主从、主主、主备模式">  </p>
<p>主从、主主、主备的基层逻辑都是数据的同步，而主从则将相关的数据同步机制全涉及，所以数据同步逻辑以解析主从逻辑为主。</p>
<p><strong>mysql主从配置分为三种模式，分别是：</strong></p>
<ul>
<li>异步复制（Asynchronous replication）：即使用二进制日志文件进行异步操作。master在执行完事后会直接给返回客户端，不考虑从库同步是否完成，从库的同步操做是通过异步线程读取二进制日志文件完成的。</li>
<li>全同步复制（Fully synchronous replication）：指当主库执行完一个事务，所有的从库都执行了该事务才返回给客户端。因为需要等待所有从库执行完该事务才能返回，所以全同步复制的性能必然会收到严重的影响。</li>
<li>半同步复制（Semisynchronous replication）：介于异步复制和全同步复制之间，主库在执行完客户端提交的事务后不是立刻返回给客户端，而是等待至少一个从库接收到并写到relay log中才返回给客户端。相对于异步复制，半同步复制提高了数据的安全性，同时它也造成了一定程度的延迟，这个延迟最少是一个TCP/IP往返的时间。所以，半同步复制最好在低延时的网络中使用。</li>
</ul>
<h2 id="二、主从同步——异步复制（Asynchronous-replication）"><a href="#二、主从同步——异步复制（Asynchronous-replication）" class="headerlink" title="二、主从同步——异步复制（Asynchronous replication）"></a>二、主从同步——异步复制（Asynchronous replication）</h2><h3 id="2-1、异步复制——原理"><a href="#2-1、异步复制——原理" class="headerlink" title="2.1、异步复制——原理"></a>2.1、异步复制——原理</h3><h4 id="2-1-1、复制线程"><a href="#2-1-1、复制线程" class="headerlink" title="2.1.1、复制线程"></a>2.1.1、复制线程</h4><p>MySQL 复制功能使用三个主线程实现，一个在源服务器上，两个在副本上：</p>
<ul>
<li><p><strong>二进制日志转储线程（Binary log dump thread）</strong>：当副本连接时，源创建一个线程以将二进制日志内容发送到副本。该线程可以在 <strong>SHOW PROCESSLIST</strong> 源上的输出中标识为该Binlog Dump线程。<br>二进制日志转储线程获取源二进制日志上的锁，以读取要发送到副本的每个事件。一旦事件被读取，锁就会被释放，甚至在事件被发送到副本之前。<br>具备多个从库的主库会为每个链接到主库的从库创建一个Binary log dump thread。</p>
</li>
<li><p><strong>复制 I/O 线程（Replication I/O thread）</strong>：当 <strong>START SLAVE</strong> 在副本服务器上发出语句时，副本会创建一个 I/O 线程，该线程连接到源并要求它发送记录在其二进制日志中的更新。<br>复制 I/O 线程读取源 Binlog Dump线程发送的更新（参见上一项）并将它们复制到组成 <strong>副本中继日志的本地文件中</strong>。<br>该线程的状态：可以通过<strong>SHOW SLAVE STATUS</strong>语句查询 <strong>Slave_IO_running</strong>字段的状态值。</p>
</li>
<li><p><strong>复制 SQL 线程（Replication SQL thread）</strong>。  副本创建一个 SQL 线程来读取由复制 I/O 线程写入的中继日志并执行其中包含的事务。</p>
</li>
</ul>
<h4 id="2-1-2、主从复制流程图"><a href="#2-1-2、主从复制流程图" class="headerlink" title="2.1.2、主从复制流程图"></a>2.1.2、主从复制流程图</h4><p><img src="/image/mysql/主从同步流程图.jpeg" alt="主从复制流程图"> </p>
<h3 id="2-2、异步复制——配置"><a href="#2-2、异步复制——配置" class="headerlink" title="2.2、异步复制——配置"></a>2.2、异步复制——配置</h3><h4 id="2-2-1、编码值设置"><a href="#2-2-1、编码值设置" class="headerlink" title="2.2.1、编码值设置"></a>2.2.1、编码值设置</h4><p>主从同步或多数据源同步时，一定要保证多个数据的编码值一致，否则在同步阶段会出现乱码，甚至无法解析的情况。编码设置如下：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># mysqld.cnf</span></span><br><span class="line"></span><br><span class="line">[client]</span><br><span class="line"><span class="comment"># 客户端设置</span></span><br><span class="line">default_character_set=utf8mb4</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">[mysqld]</span><br><span class="line"><span class="comment"># 服务端设置</span></span><br><span class="line">default-storage-engine=INNODB</span><br><span class="line">character-set-server=utf8mb4</span><br><span class="line">collation-server=utf8mb4_general_ci</span><br></pre></td></tr></table></figure></p>
<p>主从库均需要设置编码。</p>
<h4 id="2-2-2、主库配置"><a href="#2-2-2、主库配置" class="headerlink" title="2.2.2、主库配置"></a>2.2.2、主库配置</h4><p><strong>主库设置分为：server-id设置、二进制日志设置、同步用户设置等三部。</strong></p>
<h5 id="1-服务ID"><a href="#1-服务ID" class="headerlink" title="1. 服务ID"></a>1. 服务ID</h5><p>要将源配置为使用基于二进制日志文件位置的复制，必须确保启用二进制日志记录，并建立唯一的服务ID。并且必须是介于 1 和 (2 32 )-1 之间的正整数。<br>使用默认服务器 ID 为 0，且拒绝来自副本的任何连接，所以必须保证服务ID各个数据库服务不重复且大于0。配置如下：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 服务唯一ID</span></span><br><span class="line">server-id=9000</span><br></pre></td></tr></table></figure></p>
<h5 id="2-二进制日志（binlog）"><a href="#2-二进制日志（binlog）" class="headerlink" title="2. 二进制日志（binlog）"></a>2. 二进制日志（binlog）</h5><h6 id="日志格式"><a href="#日志格式" class="headerlink" title="日志格式"></a><strong>日志格式</strong></h6><p><strong>binlog日志</strong>：数据库每提交一次事务，都会把数据变更，记录到一个二进制文件中，这个二进制文件就叫binlog。需注意：只有写操作才会记录至binlog，只读操作是不会的（如select、show语句）。<br><strong>binlog的3种格式：</strong><br><strong>1. statement格式：</strong> <strong>MySQL</strong> 中的复制功能最初是基于 <strong>SQL</strong> 语句从源到副本的传播，即记录的是实际执行的sql语句。这称为 <strong>基于语句的日志记录</strong>。</p>
<ul>
<li>优点：<ul>
<li>成熟的技术</li>
<li>写入日志文件的数据更少。当更新或删除影响许多行时，这会导致 日志文件所需的存储空间大大减少。</li>
<li>日志文件包含进行任何更改的所有语句，因此它们可用于审计数据库。</li>
</ul>
</li>
<li>缺点：<ul>
<li>对 SBR 不安全的语句。</li>
<li><strong>INSERT … SELECT</strong> 与基于行的复制相比，它需要更多的行级锁。</li>
<li><strong>UPDATE</strong> 需要表扫描的语句（因为 WHERE子句中没有使用索引）必须锁定比基于行的复制更多的行。</li>
<li>For InnoDB： INSERT使用 AUTO_INCREMENT阻塞其他非冲突语句的INSERT 语句。</li>
<li>对于复杂的语句，在更新或插入行之前，必须在副本上评估和执行该语句。使用基于行的复制，副本只需要修改受影响的行，而不是执行完整的语句。</li>
<li>如果对副本的评估存在错误，尤其是在执行复杂语句时，基于语句的复制可能会随着时间的推移慢慢增加受影响行的误差幅度。</li>
<li>存储函数以与 NOW()调用语句相同的值执行。但是，存储过程并非如此。</li>
<li>确定性可加载函数必须应用于副本。</li>
<li>表定义在源和副本上必须（几乎）相同。</li>
</ul>
</li>
</ul>
<p><strong>2. row格式：</strong> binlog记录的是变化前后的数据（涉及所有列），例如update table_a set col1=value1, col2=value2 … where col1=condition1 and col2=condition2 …，这称为 <strong>基于行的日志记录</strong>。</p>
<ul>
<li>优点：<ul>
<li>所有更改都可以复制。这是最安全的复制形式。</li>
<li>INSERT对于任何、UPDATE或 DELETE语句，副本上需要的行锁更少。</li>
<li>对于以下类型的语句，源上需要更少的行锁，从而实现更高的并发性：<ul>
<li>INSERT … SELECT</li>
<li>INSERT与声明 AUTO_INCREMENT</li>
<li>UPDATE或 带有不使用键或不更改大多数检查行的子句的 DELETE语句 。WHERE</li>
</ul>
</li>
</ul>
</li>
<li>缺点：<ul>
<li><strong>RBR</strong> 可以生成更多必须记录的数据。</li>
<li>生成大  <strong>BLOB</strong> 值的确定性可加载函数使用基于行的复制进行复制比使用基于语句的复制花费更长的间。这是因为 BLOB记录的是列值，而不是生成数据的语句。</li>
<li>无法在副本上看到从源接收并执行了哪些语句。</li>
<li>对于使用存储引擎的表，与将它们作为语句应用时相比，将它们作为基于行的事件应用到二进制日志时，语句<strong>MyISAM</strong>的副本需要更强的锁定。INSERT这意味着MyISAM在使用基于行的复制时不支持对表进行并发插入。</li>
</ul>
</li>
</ul>
<p><strong>3. mixed格式</strong>：默认选择statement格式，只在需要时改用row格式。这称为 <strong>混合日志记录</strong>。</p>
<p><strong>为获取前后变化的数据，建议使用 <font color="red">基于行的日志记录</font>，具体配置信息如下：</strong><br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">[mysqld]</span><br><span class="line"><span class="comment"># 配置bin-log信息</span></span><br><span class="line"><span class="comment"># 日志文件名</span></span><br><span class="line"><span class="built_in">log</span>-bin=master-bin</span><br><span class="line">log_bin_index = master-bin.index</span><br><span class="line"><span class="comment"># 日志格式</span></span><br><span class="line">binlog_format=row</span><br><span class="line"><span class="comment"># 日志保存天数</span></span><br><span class="line">expire-logs-days=7</span><br><span class="line"></span><br><span class="line"><span class="comment"># 从 mysql 8.0.x 引进的，单位：秒</span></span><br><span class="line"><span class="comment"># binlog_expire_logs_seconds=2592000</span></span><br></pre></td></tr></table></figure></p>
<h6 id="同步过滤"><a href="#同步过滤" class="headerlink" title="同步过滤"></a><strong>同步过滤</strong></h6><p>基于业务情况，我们的数据库中并不是所有的库都需要进行复制同步。所以在开启同步前需要指定哪些库是需要进行同步操作的，即同步过滤。同步过滤有两种方式可以设置，分别是直接指定过滤库以及通过指定库记录二进制日志的方式，两种方式情况如下：</p>
<ul>
<li>指定复制库方式<ul>
<li>同步：<strong>replicate-do-db=db_name</strong></li>
<li>不同步：<strong>replicate-ignore-db=db_name</strong></li>
</ul>
</li>
<li>记录二进制方式：<ul>
<li>加入记录即同步：<strong>binlog-do-db=db_name</strong></li>
<li>不加入记录即不同步：<strong>binlog-ignore-db=db_name</strong></li>
</ul>
</li>
</ul>
<p><strong>两种方式区别：</strong></p>
<ul>
<li>相同点：都可以达到过滤的目的；可每个库需单独配置，可配置多个</li>
<li>不同点：针对日志的解析和复制有细微区别，详细可查看 <a href="https://dev.mysql.com/doc/refman/5.7/en/replication-options-binary-log.html#replication-optvars-binlog" target="_blank" rel="noopener">二进制日志记录选项和变量</a></li>
</ul>
<p>配置示例：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">[mysqld]</span><br><span class="line"><span class="comment"># 需要同步的数据库</span></span><br><span class="line">binlog-do-db=test_sync</span><br><span class="line"><span class="comment"># 不需要同步的库</span></span><br><span class="line">binlog-ignore-db=mysql</span><br><span class="line">binlog-ignore-db=sys</span><br><span class="line">binlog-ignore-db=information_schema</span><br><span class="line">binlog-ignore-db=performance_schema</span><br></pre></td></tr></table></figure></p>
<h5 id="3-为复制创建用户"><a href="#3-为复制创建用户" class="headerlink" title="3. 为复制创建用户"></a>3. 为复制创建用户</h5><p>每个从库都需要用于读取master库日志的账户信息，前提是它已被授予 <strong>REPLICATION SLAVE</strong> 特权。虽然可以直接使用root用户，但还是建议单独创建一个独立用户用于从库同步，因为 <strong>复制用户名和密码以纯文本形式存储在复制元数据存储库（slave的mysql.slave_master_info表）中</strong>。<br>创建用户示例：如果只是为了同步数据，该账户只需要 <strong>REPLICATION SLAVE</strong> 权限即可<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">USER</span> <span class="string">'slave_read'</span>@<span class="string">'%'</span> <span class="keyword">IDENTIFIED</span> <span class="keyword">BY</span> <span class="string">'password'</span>;</span><br><span class="line"><span class="keyword">GRANT</span> <span class="keyword">REPLICATION</span> <span class="keyword">SLAVE</span> <span class="keyword">ON</span> *.* <span class="keyword">TO</span> <span class="string">'slave_read'</span>@<span class="string">'%'</span>;</span><br></pre></td></tr></table></figure></p>
<h4 id="2-2-3、从库及同步机制配置"><a href="#2-2-3、从库及同步机制配置" class="headerlink" title="2.2.3、从库及同步机制配置"></a>2.2.3、从库及同步机制配置</h4><p>主库设置好之后，进入从库配置及主从同步机制配置</p>
<h5 id="1-设置从库配置"><a href="#1-设置从库配置" class="headerlink" title="1. 设置从库配置"></a>1. 设置从库配置</h5><ul>
<li>编码设置</li>
<li>服务ID：设置服务ID，原因同主库。</li>
<li>日志：副本不需要启用二进制日志记录以进行复制。但是，副本上的二进制日志记录意味着副本的二进制日志可用于数据备份和崩溃恢复。启用了二进制日志记录的副本也可以用作更复杂的复制拓扑的一部分。</li>
<li>配置如下：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 客户端设置编码字符集为UTF8mb4</span></span><br><span class="line">[client]</span><br><span class="line">default_character_set=utf8mb4</span><br><span class="line"></span><br><span class="line">[mysqld]</span><br><span class="line"><span class="comment"># 服务端设置编码</span></span><br><span class="line">default-storage-engine=INNODB</span><br><span class="line">character-set-server=utf8mb4</span><br><span class="line">collation-server=utf8mb4_general_ci</span><br><span class="line"></span><br><span class="line"><span class="comment"># 服务唯一ID</span></span><br><span class="line">server-id=9001</span><br><span class="line"></span><br><span class="line"><span class="comment"># 配置bin-log信息</span></span><br><span class="line"><span class="comment"># 日志文件名</span></span><br><span class="line"><span class="built_in">log</span>-bin=slave-bin</span><br><span class="line">log_bin_index=slave-bin.index</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h5 id="2-从库设置主库链接信息"><a href="#2-从库设置主库链接信息" class="headerlink" title="2. 从库设置主库链接信息"></a>2. 从库设置主库链接信息</h5><p>要将从库设置为与主库通信，则要进行必要的连接信息配置，主要分为三个模块：</p>
<ul>
<li>主库ip，port等信息</li>
<li>主库用户同步的账户信息</li>
<li>二进制相关信息。</li>
</ul>
<p>主库ip、port和账户信息在上面已经获取或配置好，下面获取主库的二进制日志相关的信息，获取脚本如下：<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SHOW</span> <span class="keyword">MASTER</span> <span class="keyword">STATUS</span>;</span><br></pre></td></tr></table></figure></p>
<p><strong>查询结果如下：</strong>   </p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:left">File</th>
<th style="text-align:left">Position</th>
<th style="text-align:left">Binlog_Do_DB</th>
<th style="text-align:left">Binlog_Ignore_DB</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">master-bin.000001</td>
<td style="text-align:left">86</td>
<td style="text-align:left">cm_sync</td>
<td style="text-align:left">mysql,sys,information_schema,performance_schema</td>
</tr>
</tbody>
</table>
</div>
<ul>
<li>File：显示日志文件的名称，表格中二进制日志文件是mysql-bin.000001</li>
<li>Position：显示文件中的位置。表格中位置是位置是 86</li>
<li>Binlog_Do_DB：启用二进制日志的库</li>
<li>Binlog_Ignore_DB：未启用二进制日志的库</li>
</ul>
<p><strong>File和Position</strong> 稍后在设置副本时需要它们。它们表示副本应该开始处理来自源的新更新的复制坐标。</p>
<p>通过 <strong>CHANGE MASTER TO</strong> （更多信息请查看官方文档：<a href="https://dev.mysql.com/doc/refman/5.7/en/change-master-to.html" target="_blank" rel="noopener">CHANGE MASTER TO 语句</a>）语句进行设置，登录MySQL数据，执行以下Sql：<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; CHANGE MASTER TO MASTER_HOST = '172.17.0.2',</span><br><span class="line">    MASTER_USER = 'slave_read',</span><br><span class="line">    MASTER_PASSWORD = '123456',</span><br><span class="line">    MASTER_PORT = 3306,</span><br><span class="line">    MASTER_LOG_FILE = 'master-bin.000001',</span><br><span class="line">    MASTER_LOG_POS = 86;</span><br></pre></td></tr></table></figure></p>
<p><strong>此处只使用几个常用参数：</strong></p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:left">参数</th>
<th style="text-align:left">含义</th>
<th style="text-align:left">最大长度</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">MASTER_HOST</td>
<td style="text-align:left">主库IP</td>
<td style="text-align:left">60</td>
</tr>
<tr>
<td style="text-align:left">MASTER_USER</td>
<td style="text-align:left">用于连接主库的用户</td>
<td style="text-align:left">96</td>
</tr>
<tr>
<td style="text-align:left">MASTER_PASSWORD</td>
<td style="text-align:left">用于连接主库的密码</td>
<td style="text-align:left">32</td>
</tr>
<tr>
<td style="text-align:left">MASTER_PORT</td>
<td style="text-align:left">主库端口</td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:left">MASTER_LOG_FILE</td>
<td style="text-align:left">日志文件名称</td>
<td style="text-align:left">511</td>
</tr>
<tr>
<td style="text-align:left">MASTER_LOG_POS</td>
<td style="text-align:left">日志文件中的位置</td>
<td style="text-align:left"></td>
</tr>
</tbody>
</table>
</div>
<blockquote>
<p>注：如果使用docker部署mysql，则ip为容器的ip，端口为容器内部mysql端口。MASTER_LOG_POS参数一定要与主库查询出来的结果一致，否则无法同步。</p>
</blockquote>
<h5 id="3-新的主库和从库配置"><a href="#3-新的主库和从库配置" class="headerlink" title="3. 新的主库和从库配置"></a>3. 新的主库和从库配置</h5><p>无历史数据，全新的主库和从库，上面两步配置完毕后，直接启动复制线程：<br><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; START SLAVE;</span><br></pre></td></tr></table></figure></p>
<p>执行此过程后，从库将连接到主库并复制自拍摄快照以来在主库上发生的任何更新。</p>
<h5 id="4-使用现有数据设置复制"><a href="#4-使用现有数据设置复制" class="headerlink" title="4. 使用现有数据设置复制"></a>4. 使用现有数据设置复制</h5><p>针对已有数据的主库，主从启动之前需要先将主库数据通过快照方式导入从库，以便数据同步。<br>步骤如下：</p>
<ul>
<li>1、先锁定主库，以防止数据新增遗漏<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; FLUSH TABLES WITH READ LOCK;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<blockquote>
<p>1、此过程使用FLUSH TABLES WITH READ LOCK, 阻止 表COMMIT的操作 InnoDB。<br>2、 FLUSH TABLES语句的客户端保持运行，以便读取锁保持有效。如果退出客户端，锁就会被释放。</p>
</blockquote>
<ul>
<li><p>2、创建数据快照</p>
<ul>
<li><p>使用 <strong><a href="https://dev.mysql.com/doc/refman/5.7/en/mysqldump.html" target="_blank" rel="noopener">mysqldump</a></strong> 创建数据快照：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysqldump <span class="comment">--all-databases --master-data &gt; dbdump.db</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>使用原始数据文件创建数据快照</p>
</li>
</ul>
</li>
<li><p>3、重新启动源服务器。</p>
</li>
<li>4、在从库导入快照数据</li>
<li>5、启动复制线程</li>
<li>6、解锁<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; UNLOCK TABLES;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h5 id="5-将新的从库添加到复制拓扑"><a href="#5-将新的从库添加到复制拓扑" class="headerlink" title="5. 将新的从库添加到复制拓扑"></a>5. 将新的从库添加到复制拓扑</h5><p>可以在不停止源服务器的情况下将另一个副本添加到现有复制配置。方式为通过复制现有副本的数据目录来设置新副本，并为新副本提供不同的 <strong>服务器 ID（由用户指定）</strong>和 <strong>服务器 UUID（在启动时生成）</strong>。</p>
<ul>
<li><p>1、停止现有副本并记录副本状态信息，特别是源的二进制日志文件和中继日志文件位置。</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; STOP SLAVE;</span><br><span class="line">mysql&gt; SHOW SLAVE STATUS</span><br></pre></td></tr></table></figure>
</li>
<li><p>2、关闭现有副本</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$&gt; mysqladmin shutdown</span><br></pre></td></tr></table></figure>
</li>
<li><p>3、将现有副本的数据目录复制到新副本，包括日志文件和中继日志文件。可以通过使用tar或创建存档来执行此操作 ，或者使用cp或rsyncWinZip等工具执行直接复制 。</p>
<ul>
<li>在复制之前，请验证与现有副本相关的所有文件实际上都存储在数据目录中。例如，InnoDB 系统表空间、撤消表空间和重做日志可能存储在其他位置。</li>
<li>在复制期间，如果文件已用于复制元数据存储库，确保还将这些文件从现有副本复制到新副本。如果表已用于存储库，则表位于数据目录中。</li>
<li>复制后，从新副本上的数据目录副本中删除该 auto.cnf文件，以便新副本以不同的生成服务器 UUID 启动。服务器 UUID 必须是唯一的。</li>
</ul>
</li>
<li><p>4、复制完成后，重新启动现有副本。</p>
</li>
<li><p>5、在新副本上，编辑配置并为新副本提供唯一的服务器 ID（使用 server_id系统变量），源或任何现有副本均未使用该 ID。</p>
</li>
<li><p>6、启动新的副本服务器，指定 —skip-slave-start选项以便复制尚未开始。使用性能模式复制表或问题SHOW SLAVE STATUS来确认新副本与现有副本相比具有正确的设置。还要显示服务器 ID 和服务器 UUID，并验证这些对于新副本是否正确且唯一。</p>
</li>
<li>7、通过发出一条 <strong>START SLAVE</strong> 语句来启动复制线程。</li>
</ul>
<h4 id="2-2-4、从库状态查询"><a href="#2-2-4、从库状态查询" class="headerlink" title="2.2.4、从库状态查询"></a>2.2.4、从库状态查询</h4><p>异步复制线程开启后，查看从库的相关状态：<br><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; SHOW SLAVE STATUS</span><br></pre></td></tr></table></figure></p>
<p><strong>结果中关键字段是：</strong></p>
<ul>
<li>Slave_IO_State：副本的当前状态。</li>
<li>Slave_IO_Running: 读取源二进制日志的I/O线程是否正在运行。执行完 <strong>START SLAVE</strong> 后为 <strong>Yes</strong>。</li>
<li>Slave_SQL_Running：用于执行中继日志中事件的SQL线程是否正在运行。与 I/O 线程一样，执行完 <strong>START SLAVE</strong> 后为 <strong>Yes</strong>。</li>
<li>Last_IO_Error, Last_SQL_Error: I/O 和 SQL 线程在处理中继日志时注册的最后一个错误。理想情况下，这些应该是空白的，表示没有错误。</li>
<li>Seconds_Behind_Master：复制 SQL 线程在处理源的二进制日志之后的秒数。较大的数字（或增加的数字）可能表明副本无法及时处理来自源的事件。</li>
</ul>
<p>在主库上进行状态查询的语句有：</p>
<ul>
<li><strong>SHOW PROCESSLIST</strong>：用于检查正在运行的进程列表。</li>
<li><strong>SHOW SLAVE HOSTS</strong>：显示有关副本的基本信息。</li>
</ul>
<h4 id="2-2-5、配置汇总"><a href="#2-2-5、配置汇总" class="headerlink" title="2.2.5、配置汇总"></a>2.2.5、配置汇总</h4><p><strong>主库配置</strong><br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># mysqld.cnf</span></span><br><span class="line">[client]</span><br><span class="line"><span class="comment"># 客户端设置编码字符集为UTF8mb4</span></span><br><span class="line">default_character_set=utf8mb4</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">[mysqld]</span><br><span class="line"><span class="comment"># 服务端设置编码</span></span><br><span class="line">default-storage-engine=INNODB</span><br><span class="line">character-set-server=utf8mb4</span><br><span class="line">collation-server=utf8mb4_general_ci</span><br><span class="line"></span><br><span class="line"><span class="comment"># 服务唯一ID</span></span><br><span class="line">server-id=9000</span><br><span class="line"></span><br><span class="line"><span class="comment"># 配置bin-log信息</span></span><br><span class="line"><span class="comment"># 日志文件名</span></span><br><span class="line"><span class="built_in">log</span>-bin=master-bin</span><br><span class="line">log_bin_index = master-bin.index</span><br><span class="line"><span class="comment"># 日志格式</span></span><br><span class="line">binlog_format=row</span><br><span class="line"><span class="comment"># 日志保存天数</span></span><br><span class="line">expire-logs-days=7</span><br><span class="line"><span class="comment"># 需要同步的数据库</span></span><br><span class="line"><span class="comment">#binlog-do-db=cm_sync</span></span><br><span class="line"><span class="comment"># 不需要同步的库</span></span><br><span class="line">binlog-ignore-db=mysql</span><br><span class="line">binlog-ignore-db=sys</span><br><span class="line">binlog-ignore-db=information_schema</span><br><span class="line">binlog-ignore-db=performance_schema</span><br></pre></td></tr></table></figure></p>
<p><strong>从库配置</strong><br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># mysqld.cnf</span></span><br><span class="line"><span class="comment"># 客户端设置编码字符集为UTF8mb4</span></span><br><span class="line">[client]</span><br><span class="line">default_character_set=utf8mb4</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">[mysqld]</span><br><span class="line"><span class="comment"># 服务端设置编码</span></span><br><span class="line">default-storage-engine=INNODB</span><br><span class="line">character-set-server=utf8mb4</span><br><span class="line">collation-server=utf8mb4_general_ci</span><br><span class="line"></span><br><span class="line"><span class="comment"># 服务唯一ID</span></span><br><span class="line">server-id=9001</span><br><span class="line"></span><br><span class="line"><span class="comment"># 配置bin-log信息</span></span><br><span class="line"><span class="comment"># 日志文件名</span></span><br><span class="line"><span class="built_in">log</span>-bin=slave-bin</span><br><span class="line">log_bin_index=slave-bin.index</span><br><span class="line"></span><br><span class="line">relay_log=slave-relay-bin</span><br><span class="line">read_only=1</span><br></pre></td></tr></table></figure></p>
<h3 id="2-3、强一致性——GTID"><a href="#2-3、强一致性——GTID" class="headerlink" title="2.3、强一致性——GTID"></a>2.3、强一致性——GTID</h3><h4 id="2-3-1、GTID"><a href="#2-3-1、GTID" class="headerlink" title="2.3.1、GTID"></a>2.3.1、GTID</h4><p>GTID：<strong>全局事务标识符</strong> 是在源服务器（master）上创建并与提交的每个事务相关联的唯一标识符。这个标识符不仅对于它起源的服务器是唯一的，而且在给定的复制拓扑中的所有服务器中都是唯一的。<br>针对GTID相关操作可以分为两部分：</p>
<ul>
<li>客户端事务在master上提交：提交时它会被分配一个新的 GTID，前提是该事务已写入二进制日志。保证客户端事务具有单调递增的 GTID，生成的数字之间没有间隙。如果客户端事务没有写入二进制日志（例如，因为事务被过滤掉，或者事务是只读的），则不会在源服务器上为其分配 GTID。</li>
<li>同步复制事务：从库会根据主库日志中各个GTID对应的事务操作进行数据同步操作，且在主库上提交的事务只能在副本上应用一次，这有助于保证一致性。</li>
</ul>
<h5 id="GTID组成"><a href="#GTID组成" class="headerlink" title="GTID组成"></a>GTID组成</h5><p>GTID 表示为一对坐标，由冒号字符 ( : ) 分隔，如下所示：</p>
<blockquote>
<p>GTID = source_id:transaction_id</p>
</blockquote>
<p><strong>source_id</strong>：标识始发服务器 。通常，源 server_uuid用于此目的。<br><strong>transaction_id</strong>：是一个序列号，由在源上提交事务的顺序确定。其实就是一个自增序列，从1递增。</p>
<p>MySQL 系统表 <strong>mysql.gtid_executed</strong> 用于保存在 MySQL 服务器上应用的所有事务的分配 GTID，但存储在当前活动的二进制日志文件中的事务除外。</p>
<h4 id="2-3-2、使用-GTID-设置复制"><a href="#2-3-2、使用-GTID-设置复制" class="headerlink" title="2.3.2、使用 GTID 设置复制"></a>2.3.2、使用 GTID 设置复制</h4><p><strong>GTID</strong> 模式是基于开启二进制服务的基础上进行的，下面操作步骤均已 <strong>开启二进制日志为前提</strong>。</p>
<h5 id="1、同步服务器"><a href="#1、同步服务器" class="headerlink" title="1、同步服务器"></a>1、同步服务器</h5><p>将mysql服务设置为只读，保证操作期间无数据丢失。<br><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; SET @@GLOBAL.read_only = ON;</span><br></pre></td></tr></table></figure></p>
<p>等待所有正在进行的事务提交或回滚。然后，让副本赶上源。在继续之前确保副本已处理所有更新非常重要。</p>
<p>如果是新服务则直接从第三步开始</p>
<h5 id="2、停止所有服务器"><a href="#2、停止所有服务器" class="headerlink" title="2、停止所有服务器"></a>2、停止所有服务器</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$&gt;  mysqladmin -uusername -p shutdown</span><br></pre></td></tr></table></figure>
<h5 id="3、开启主库和从库的GTID设置"><a href="#3、开启主库和从库的GTID设置" class="headerlink" title="3、开启主库和从库的GTID设置"></a>3、开启主库和从库的GTID设置</h5><p>开启方式增加配置文件：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[mysqld]</span><br><span class="line">gtid_mode=ON</span><br><span class="line">enforce-gtid-consistency=ON</span><br></pre></td></tr></table></figure></p>
<p>主库和从库均需设置，设置后重启mysql服务。</p>
<h5 id="4、将副本配置为使用基于-GTID-的自动定位"><a href="#4、将副本配置为使用基于-GTID-的自动定位" class="headerlink" title="4、将副本配置为使用基于 GTID 的自动定位"></a>4、将副本配置为使用基于 GTID 的自动定位</h5><p>在副本上发出一条 <strong>CHANGE MASTER TO</strong> 语句，包括 <strong>MASTER_AUTO_POSITION</strong> 在语句中告诉副本源的事务由 GTID 标识的选项。如果除 <strong>MASTER_AUTO_POSITION</strong> 参数外其它参数均已设置，则可以不进行重复设置。</p>
<blockquote>
<font color="red">MASTER_LOG_FILE选项和 选项 都MASTER_LOG_POS不能与 MASTER_AUTO_POSITION=1 一起使用。尝试这样做会导致CHANGE MASTER TO语句失败并出现错误。</font>

</blockquote>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; CHANGE MASTER TO</span><br><span class="line">     &gt;     MASTER_HOST = host,</span><br><span class="line">     &gt;     MASTER_PORT = port,</span><br><span class="line">     &gt;     MASTER_USER = user,</span><br><span class="line">     &gt;     MASTER_PASSWORD = password,</span><br><span class="line">     &gt;     MASTER_AUTO_POSITION = 1;</span><br></pre></td></tr></table></figure>
<h5 id="5、启动复制线程并禁用只读模式"><a href="#5、启动复制线程并禁用只读模式" class="headerlink" title="5、启动复制线程并禁用只读模式"></a>5、启动复制线程并禁用只读模式</h5><p>启动复制线程：<br><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; START SLAVE;</span><br></pre></td></tr></table></figure></p>
<p>仅当在 <strong>步骤 1</strong> 中将服务器配置为只读时，才需要执行以下步骤。要允许服务器再次开始接受更新，请发出以下语句：<br><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; SET @@GLOBAL.read_only = OFF;</span><br></pre></td></tr></table></figure></p>
<h4 id="2-3-3、使用-GTID-复制的限制"><a href="#2-3-3、使用-GTID-复制的限制" class="headerlink" title="2.3.3、使用 GTID 复制的限制"></a>2.3.3、使用 GTID 复制的限制</h4><p>因为基于 GTID 的复制依赖于事务，所以在使用 MySQL 时不支持一些原本在 MySQL 中可用的特性。相关限制如下：</p>
<ul>
<li>涉及非事务性存储引擎的更新。 </li>
<li>CREATE TABLE … SELECT 语句。基于 GTID 的复制时不允许使用语句。</li>
<li>临时表。  使用 GTID 时（即当 系统变量设置为时），事务、过程、函数和触发器中不支持CREATE TEMPORARY TABLE和 语句。</li>
<li>防止执行不受支持的语句。  为了防止执行会导致基于 GTID 的复制失败的语句，所有服务器都必须 —enforce-gtid-consistency在启用 GTID 时使用该选项启动。</li>
<li>跳过交易。  sql_slave_skip_counter使用 GTID 时不支持。</li>
<li>忽略服务器。  使用 GTID 时不推荐使用该语句的 IGNORE_SERVER_IDS 选项CHANGE MASTER TO，因为已应用的事务将被自动忽略。</li>
</ul>
<h2 id="三、主从同步——半同步复制（Semisynchronous-replication）"><a href="#三、主从同步——半同步复制（Semisynchronous-replication）" class="headerlink" title="三、主从同步——半同步复制（Semisynchronous replication）"></a>三、主从同步——半同步复制（Semisynchronous replication）</h2><p>主从同步的三种机制分别是异步、半同步、全同步，异步逻辑已经分析完了，下面看下半同步和全同步。先了解下全同步。</p>
<p><strong>全同步（完全同步复制）</strong>：当源提交事务时，所有副本也必须在源返回到执行事务的会话之前提交事务。即master每次提交都要等所有副本接收并记录了事件，所有副本都通知master记录成功，master才能提交本次事务。</p>
<ul>
<li>优点：完全同步复制意味着可以随时从源故障转移到任何副本。</li>
<li>缺点完全同步复制的缺点是完成事务可能会有很多延迟。</li>
</ul>
<p><strong>半同步复制（Semisynchronous Replication）</strong>：介于异步复制和完全同步复制之间。源等待直到至少一个副本接收并记录了事件（所需的副本数量是可配置的），然后提交事务。源不等待所有副本确认接收，它只需要来自副本的确认，而不是事件已在副本端完全执行并提交。因此，半同步复制保证如果源崩溃，它已提交的所有事务都已传输到至少一个副本。</p>
<ul>
<li>与完全同步复制相比，半同步复制更快，因为它可以配置为平衡您对数据完整性的要求（确认收到事务的副本数）和提交速度，提交速度由于需要等待而较慢复制品。</li>
<li>与异步复制相比，半同步复制的性能影响是提高数据完整性的权衡。</li>
</ul>
<p><strong>源与其副本之间的半同步复制操作如下：</strong></p>
<ul>
<li>副本在连接到源时指示它是否具有半同步能力。</li>
<li>如果在源端启用了半同步复制并且至少有一个半同步副本，则在源上执行事务提交的线程会阻塞并等待，直到至少一个半同步副本确认它已收到事务的所有事件，或者直到发生超时。</li>
<li>只有在将事件写入其中继日志并刷新到磁盘后，副本才会确认收到事务的事件。</li>
<li>如果在没有任何副本确认事务的情况下发生超时，则源将恢复为异步复制。当至少一个半同步副本赶上时，源返回到半同步复制。</li>
<li>必须在源端和副本端都启用半同步复制。如果在源上禁用半同步复制，或者在源上启用但没有副本，则源使用异步复制。</li>
</ul>
<h3 id="3-1、半同步实现"><a href="#3-1、半同步实现" class="headerlink" title="3.1、半同步实现"></a>3.1、半同步实现</h3><p>半同步复制是使用插件实现的，因此必须将插件安装到服务器中以使其可用。安装插件后，可以通过与其关联的系统变量来控制它。</p>
<h4 id="3-1-1、插件安装"><a href="#3-1-1、插件安装" class="headerlink" title="3.1.1、插件安装"></a>3.1.1、插件安装</h4><h5 id="1、介绍"><a href="#1、介绍" class="headerlink" title="1、介绍"></a>1、介绍</h5><p>服务器插件必须先加载到服务器中才能使用。MySQL 支持在服务器启动和运行时加载插件。还可以在启动时控制已加载插件的激活状态，并在运行时卸载它们。</p>
<p><strong>INSTALL PLUGIN</strong> 语句安装的插件：</p>
<ul>
<li>位于插件库文件中的插件可以在运行时使用该 <strong>INSTALL PLUGIN</strong> 语句加载。</li>
<li>该语句还在 mysql.plugin表中注册插件，以使服务器在后续重新启动时加载它。</li>
<li>插件库文件的基本名称取决于您的平台。常见的后缀 <strong>.so</strong> 适用于 Unix 和类 Unix 系统，<strong>.dll</strong> 适用于 Windows。</li>
</ul>
<h5 id="2、安装"><a href="#2、安装" class="headerlink" title="2、安装"></a>2、安装</h5><p><strong>安装语句：</strong><br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 基于mac环境</span></span><br><span class="line"><span class="comment">-- 主库</span></span><br><span class="line"><span class="keyword">INSTALL</span> <span class="keyword">PLUGIN</span> rpl_semi_sync_master <span class="keyword">SONAME</span> <span class="string">'semisync_master.so'</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 从库</span></span><br><span class="line"><span class="keyword">INSTALL</span> <span class="keyword">PLUGIN</span> rpl_semi_sync_slave <span class="keyword">SONAME</span> <span class="string">'semisync_slave.so'</span>;</span><br></pre></td></tr></table></figure></p>
<p><strong>安装查看</strong></p>
<ul>
<li>可以查看 <strong>INFORMATION_SCHEMA.PLUGINS</strong> 表</li>
<li>使用 <strong>SHOW PLUGINS</strong> 语句</li>
</ul>
<p>此处查看PLUGINS表信息<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span></span><br><span class="line">	PLUGIN_NAME,</span><br><span class="line">	PLUGIN_STATUS </span><br><span class="line"><span class="keyword">FROM</span></span><br><span class="line">	INFORMATION_SCHEMA.PLUGINS </span><br><span class="line"><span class="keyword">WHERE</span></span><br><span class="line">	PLUGIN_NAME <span class="keyword">LIKE</span> <span class="string">'%semi%'</span>;</span><br></pre></td></tr></table></figure></p>
<p><strong>结果：</strong><br><img src="/image/mysql/查看插件信息.png" alt="安装的插件信息"></p>
<h5 id="3、配置"><a href="#3、配置" class="headerlink" title="3、配置"></a>3、配置</h5><p>半同步相关的配置项主要使用以下几项：</p>
<ul>
<li><strong>rpl_semi_sync_master_enabled：</strong> 控制是否在源上启用半同步复制。要启用或禁用插件，请将此变量分别设置为 1 或 0。默认值为 0（关闭）。</li>
<li><strong>rpl_semi_sync_master_timeout：</strong> 一个以毫秒为单位的值，用于控制源在超时和恢复到异步复制之前等待来自副本的确认提交的时间。默认值为 10000（10 秒）。</li>
<li><strong>rpl_semi_sync_slave_enabled：</strong> 类似于 rpl_semi_sync_master_enabled，但控制副本插件。</li>
</ul>
<p>mysql实例运行时：<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 主库</span></span><br><span class="line"><span class="keyword">SET</span> <span class="keyword">GLOBAL</span> rpl_semi_sync_master_enabled = &#123;<span class="number">0</span>|<span class="number">1</span>&#125;;</span><br><span class="line"><span class="keyword">SET</span> <span class="keyword">GLOBAL</span> rpl_semi_sync_master_timeout = N;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 从库</span></span><br><span class="line"><span class="keyword">SET</span> <span class="keyword">GLOBAL</span> rpl_semi_sync_slave_enabled = &#123;<span class="number">0</span>|<span class="number">1</span>&#125;;</span><br></pre></td></tr></table></figure></p>
<p>如果在运行时在副本上启用半同步复制，则还必须启动复制 I/O 线程（如果它已经在运行，则首先停止它）以使副本连接到源并注册为半同步副本：<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">STOP</span> <span class="keyword">SLAVE</span> IO_THREAD;</span><br><span class="line"><span class="keyword">START</span> <span class="keyword">SLAVE</span> IO_THREAD;</span><br></pre></td></tr></table></figure></p>
<p>实例启动时配置文件配置：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 主库</span></span><br><span class="line">[mysqld]</span><br><span class="line">rpl_semi_sync_master_enabled=1</span><br><span class="line">rpl_semi_sync_master_timeout=1000 <span class="comment"># 1 second</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 从库</span></span><br><span class="line">[mysqld]</span><br><span class="line">rpl_semi_sync_slave_enabled=1</span><br></pre></td></tr></table></figure></p>
<p>自此半同步配置即完成</p>
<h2 id="四、延迟复制"><a href="#四、延迟复制" class="headerlink" title="四、延迟复制"></a>四、延迟复制</h2><p>MySQL 5.7 支持延迟复制，这样副本服务器故意滞后源至少指定的时间量。默认延迟为 0 秒。设置：<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- N 为延迟秒数</span></span><br><span class="line"><span class="keyword">CHANGE</span> <span class="keyword">MASTER</span> <span class="keyword">TO</span> MASTER_DELAY = N;</span><br></pre></td></tr></table></figure></p>
<p>从源接收到的事件直到在源上执行至少 N几秒钟后才会执行。例外情况是格式描述事件或日志文件轮换事件没有延迟，它们只影响 SQL 线程的内部状态。</p>
<p>作用：</p>
<ul>
<li>防止用户在源上出错。DBA 可以将延迟的副本回滚到灾难发生前的时间。</li>
<li>测试存在滞后时系统的行为。</li>
<li>检查数据库很久以前的样子，而无需重新加载备份。</li>
</ul>

          
        
      
    </div>

    
    
    
      <footer class="post-footer">
          <div class="post-eof"></div>
        
      </footer>
  </div>
  
  
  
  </article>

    
      

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="cmeng001.github.io/2020/08/18/java/JVM/JVM调优/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="cmeng">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="c萌怪谈">
    </span>
      <header class="post-header">

        
          <h1 class="post-title" itemprop="name headline">
              
              <a href="/2020/08/18/java/JVM/JVM调优/" class="post-title-link" itemprop="url">JVM调优之jps jinfo jstat jmap jhat</a>
            
          </h1>
        

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              
                
              

              <time title="创建时间：2020-08-18 16:13:12" itemprop="dateCreated datePublished" datetime="2020-08-18T16:13:12+08:00">2020-08-18</time>
            </span>
          
            

            
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-08-08 22:19:41" itemprop="dateModified" datetime="2022-08-08T22:19:41+08:00">2022-08-08</time>
              </span>
            
          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/java/" itemprop="url" rel="index"><span itemprop="name">java</span></a></span>

                
                
                  ，
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/java/JVM/" itemprop="url" rel="index"><span itemprop="name">JVM</span></a></span>

                
                
              
            </span>
          

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          
            <h2 id="JVM调优"><a href="#JVM调优" class="headerlink" title="JVM调优"></a>JVM调优</h2><h4 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h4><p>虽然jvm调优成熟的工具已经有很多：jconsole、大名鼎鼎的VisualVM，IBM的Memory Analyzer等等。但生产环境出现问题时，一是受环境所限，二是所有工具几乎都是依赖JDK的接口和底层连接命令，所以研究JDK的这些命令有助我们进一步了解JDK的构成和特性。</p>
<h4 id="调优原则"><a href="#调优原则" class="headerlink" title="调优原则"></a>调优原则</h4><p>多数应用在服务器不需要怎么进行GC优化，多数导致GC问题的应用，主要问题并不在于GC的参数上，而更多的在代码上面。如：全局变量对象创建过多等。GC是最后不得已下的手段而已。所以通过GC情况分析并优化代码比GC调优要更多。</p>
<p>本文基于JDK8，相关监控和处理故障的命令有：jps、jinfo、jstat、jmap、jhat。</p>
<h2 id="jps"><a href="#jps" class="headerlink" title="jps"></a>jps</h2><p>jps（JVM Process Status Tool）：显示指定系统内所有Hotspot虚拟机进程</p>
<p>命令格式：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jps [options] [hostid]</span><br></pre></td></tr></table></figure></p>
<p>options参数：  </p>
<ul>
<li>-l：输入主类的全名或路径  </li>
<li>-q：输出LVMID  </li>
<li>-m：输出JVM启动时传递给main()的参数  </li>
<li>-v：输出JVM启动时显示指定的参数    </li>
</ul>
<p>示例：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">λ jps -l</span><br><span class="line">39392 org.jetbrains.jps.cmdline.Launcher</span><br><span class="line">77060 sun.tools.jps.Jps</span><br><span class="line">115404 org.jetbrains.idea.maven.server.RemoteMavenServer</span><br></pre></td></tr></table></figure></p>
<h2 id="jinfo"><a href="#jinfo" class="headerlink" title="jinfo"></a>jinfo</h2><p>jinfo(JVM Configuration info)：生成指定进程的JVM配置信息。</p>
<p>命令格式：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jinfo -&lt;options&gt; vmid</span><br></pre></td></tr></table></figure></p>
<h3 id="options参数"><a href="#options参数" class="headerlink" title="options参数"></a>options参数</h3><ul>
<li>-flag <name>：打印指定参数的名称和值。</name></li>
<li>-flag [+|-]name：启用或禁用指定的布尔命令标志。</li>
<li>-flag <name>=<value>：设定指定参数的值。</value></name></li>
<li>-flags：输出所有JVM参数。</li>
<li>-sysprops：以key-value形式，输出Java系统属性。</li>
</ul>
<p>示例：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">λ jinfo -flag MaxNewSize 75052</span><br><span class="line">  -XX:MaxNewSize=1418723328</span><br></pre></td></tr></table></figure></p>
<h2 id="jstat"><a href="#jstat" class="headerlink" title="jstat"></a>jstat</h2><p>jstat（JVM Statistics Monitoring）：监视虚拟机运行时状态信息的命令，它可显示JVM的类加载、内存、垃圾收集、JIT编译等运行数据等。</p>
<p>命令格式：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jstat -&lt;option&gt; [-t] [-h&lt;lines&gt;] &lt;vmid&gt; [&lt;interval&gt; [&lt;count&gt;]]</span><br></pre></td></tr></table></figure></p>
<ul>
<li>option：操作参数</li>
<li>-t ：将时间戳列显示为输出的第一列。时间戳是自目标JVM启动时间以来的时间。</li>
<li>-h<lines>：即-h跟数字，代表隔几行显示标题，默认为0</lines></li>
<li>vmid ：代表vm进程id</li>
<li>interval：代表监控间隔时间段，默认毫秒做单位</li>
<li>count：代表取数次数</li>
</ul>
<h3 id="options参数-1"><a href="#options参数-1" class="headerlink" title="options参数"></a>options参数</h3><h4 id="总览"><a href="#总览" class="headerlink" title="总览"></a>总览</h4><div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:left">参数</th>
<th style="text-align:left">描述</th>
<th style="text-align:left">备注</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">class</td>
<td style="text-align:left">class loader的行为统计<br>Statistics about the behavior of the class loader.</td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:left">compiler</td>
<td style="text-align:left">HotSpt JIT编译器行为统计。<br>Statistics about the behavior of the Java HotSpot VM Just-in-Time compiler.</td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:left">gc</td>
<td style="text-align:left">垃圾收集堆行为统计.<br>Statistics about the behavior of the garbage collected heap.</td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:left">gccapacity</td>
<td style="text-align:left">代的容量及其相应空间的统计信息。<br>Statistics about the capacities of the generations and their corresponding spaces.</td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:left">gccause</td>
<td style="text-align:left">垃圾收集器统计概述(同gcutil)，及最近两次垃圾回收原因。<br>A summary about garbage collection statistics (same as -gcutil), with the cause of the last and current (when applicable) garbage collection events.</td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:left">gcnew</td>
<td style="text-align:left">新生代代行为统计<br>Statistics about the behavior of the new generation.</td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:left">gcnewcapacity</td>
<td style="text-align:left">新生代与其相应的内存空间统计。<br>Statistics about the sizes of the new generations and their corresponding spaces.</td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:left">gcold</td>
<td style="text-align:left">老年代和元空间的行为统计。<br>Statistics about the behavior of the old generation and metaspace statistics.</td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:left">gcoldcapacity</td>
<td style="text-align:left">老年代大小统计。<br>Statistics about the sizes of the old generation.</td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:left">gcmetacapacity</td>
<td style="text-align:left">元空间大小统计。<br>Statistics about the sizes of the metaspace.</td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:left">gcutil</td>
<td style="text-align:left">垃圾收集器统计概述。<br>A summary about garbage collection statistics.</td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:left">printcompilation</td>
<td style="text-align:left">HotSpot编译方法统计。<br>Java HotSpot VM compilation method statistics.</td>
<td style="text-align:left"></td>
</tr>
</tbody>
</table>
</div>
<h4 id="options参数详解"><a href="#options参数详解" class="headerlink" title="options参数详解"></a>options参数详解</h4><h5 id="class"><a href="#class" class="headerlink" title="-class"></a>-class</h5><p>Class loader statistics.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">λ jstat -class 62044</span><br><span class="line">  Loaded  Bytes    Unloaded  Bytes     Time</span><br><span class="line">  6152    12149.8     0       0.0       8.72</span><br></pre></td></tr></table></figure></p>
<ul>
<li>Loaded：加载class数量。  </li>
<li>Bytes：加载的class字节大小（KB）。</li>
<li>Unloaded：未加载的class数量。</li>
<li>Bytes：未加载calss字节大小（KB）。</li>
<li>Time：执行类加载和卸载的总时间。</li>
</ul>
<h5 id="compiler"><a href="#compiler" class="headerlink" title="-compiler"></a>-compiler</h5><p>Java HotSpot VM Just-in-Time compiler statistics.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">λ jstat -compiler 62044</span><br><span class="line">  Compiled Failed Invalid   Time   FailedType FailedMethod</span><br><span class="line">      8306      2       0    34.24          1 com/alibaba/druid/pool/DruidDataSource shrink</span><br></pre></td></tr></table></figure></p>
<ul>
<li>Compilerd：编译数量</li>
<li>Failed：编译失败的数量</li>
<li>Invalid：无效的数量</li>
<li>Time：执行编译时长</li>
<li>FailedType : 失败类型</li>
<li>FailedMethod : 失败方法的全限定名</li>
</ul>
<h5 id="gc"><a href="#gc" class="headerlink" title="-gc"></a>-gc</h5><p>Garbage collected heap statistics.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">λ jstat -gc 62044</span><br><span class="line"> S0C    S1C    S0U    S1U      EC       EU        OC         OU       MC     MU    CCSC   CCSU   YGC     YGCT    FGC    FGCT     GCT</span><br><span class="line">512.0  512.0   0.0    96.0  27648.0   6616.5   67584.0    55474.4   42112.0 41055.1 4736.0 4522.8  50299   94.002  12      0.677   94.679</span><br></pre></td></tr></table></figure></p>
<p>C：Capacity，即总容量，容量单位为KB；U：Used，即已使用容量。  </p>
<ul>
<li>S0C：survivor0总容量  </li>
<li>S1C：survivor1总容量  </li>
<li>S0U：survivor0已使用容量</li>
<li>S1U：survivor1已使用容量</li>
<li>EC：Eden区总容量</li>
<li>EU：Eden区已使用容量</li>
<li>OC：老年代总容量</li>
<li>OU：老年代已使用容量</li>
<li>MC：元空间承诺大小</li>
<li>MU：元空间已使用容量</li>
<li>CCSC：压缩类容量大小</li>
<li>CCSU：压缩类已使用容量</li>
<li>YGC：新生代垃圾回收次数</li>
<li>YGCT：新生代垃圾回收时间</li>
<li>FGC：老年代垃圾回收次数</li>
<li>FGCT：老年代垃圾回收时间</li>
<li>GCT：垃圾回收总耗时</li>
</ul>
<h5 id="gccapacity"><a href="#gccapacity" class="headerlink" title="-gccapacity"></a>-gccapacity</h5><p>Memory pool generation and space capacities.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">jstat -gccapacity 62044</span><br><span class="line"> NGCMN    NGCMX     NGC     S0C   S1C       EC      OGCMN      OGCMX       OGC         OC       MCMN     MCMX      MC     CCSMN    CCSMX     CCSC    YGC    FGC</span><br><span class="line"> 86528.0 1385472.0  32256.0  512.0  512.0  30720.0   173568.0  2771968.0    83968.0    83968.0      0.0 1085440.0  39936.0      0.0 1048576.0   4608.0   1306     2</span><br></pre></td></tr></table></figure></p>
<ul>
<li>NGCMN：新生代最小容量</li>
<li>NGCMX：新生代最大容量</li>
<li>NGC：当前新生代容量</li>
<li>S0C：survivor0总容量  </li>
<li>S1C：survivor1总容量  </li>
<li>EC：Eden区总容量  </li>
<li>OGCMN：老年代最小容量</li>
<li>OGCMX：老年代最大容量</li>
<li>OGC：当前老年代容量</li>
<li>OC：老年代总容量</li>
<li>MCMN：元空间最小容量</li>
<li>MCMX：元空间最大容量</li>
<li>MC：元空间当前容量</li>
<li>CCSMN：压缩类空间最小容量</li>
<li>CCSMX：压缩类空间最大容量</li>
<li>CCSC：当前压缩类空间容量</li>
<li>YGC：年轻的GC次数</li>
<li>FGC：老年代GC次数</li>
</ul>
<h5 id="gccause"><a href="#gccause" class="headerlink" title="-gccause"></a>-gccause</h5><p>垃圾收集器统计概述(同gcutil)，及最近两次垃圾回收原因。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">λ jstat -gccause 62044</span><br><span class="line">  S0     S1     E      O      M     CCS    YGC     YGCT    FGC    FGCT     GCT    LGCC                 GCC</span><br><span class="line"> 25.00   0.00  49.19  37.97  97.21  96.06   2360    4.765     2    0.099    4.865 Allocation Failure   No GC</span><br></pre></td></tr></table></figure></p>
<ul>
<li>LGCC：上次垃圾回收原因</li>
<li>GCC：当前垃圾回收原因</li>
</ul>
<h5 id="gcnew"><a href="#gcnew" class="headerlink" title="-gcnew"></a>-gcnew</h5><p>新生代代行为统计<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">λ jstat -gcnew 62044</span><br><span class="line"> S0C    S1C    S0U    S1U   TT MTT  DSS      EC       EU     YGC     YGCT</span><br><span class="line"> 512.0  512.0    0.0   96.0 15  15  512.0  30720.0   6082.8   2557    5.169</span><br></pre></td></tr></table></figure></p>
<ul>
<li>S0C：survivor0总容量  </li>
<li>S1C：survivor1总容量  </li>
<li>S0U：survivor0已使用容量</li>
<li>S1U：survivor1已使用容量</li>
<li>TT：Tenuring threshold.(任期阈值)</li>
<li>DTT： Maximum tenuring threshold.</li>
<li>DSS：DSS: Desired survivor size (KB).survivor的容量</li>
<li>EC：Eden区总容量</li>
<li>EU：Eden区已使用容量</li>
<li>YGC：新生代垃圾回收次数</li>
<li>YGCT：新生代垃圾回收时间</li>
</ul>
<h4 id="gcnewcapacity"><a href="#gcnewcapacity" class="headerlink" title="-gcnewcapacity"></a>-gcnewcapacity</h4><p>新生代与其相应的内存空间统计。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">λ jstat -gcnewcapacity 105308</span><br><span class="line">  NGCMN      NGCMX       NGC      S0CMX     S0C     S1CMX     S1C       ECMX        EC      YGC   FGC</span><br><span class="line">   86528.0  1385472.0    64512.0 461824.0   9728.0 461824.0    512.0  1384448.0    45056.0    25     2</span><br></pre></td></tr></table></figure></p>
<ul>
<li>NGCMN：新生代最小容量</li>
<li>NGCMX：新生代最大容量</li>
<li>NGC：当前新生代容量</li>
<li>S0CMX：survivor0最大容量</li>
<li>S0C：当前survivor0容量</li>
<li>ECMX：Eden最大容量</li>
<li>EC：当前Eden容量</li>
<li>YGC：新生代垃圾回收次数</li>
<li>FGC：老年代GC次数</li>
</ul>
<h5 id="gcold"><a href="#gcold" class="headerlink" title="-gcold"></a>-gcold</h5><p>老年代和元空间的行为统计。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">λ jstat -gcold 105308</span><br><span class="line">   MC       MU      CCSC     CCSU       OC          OU       YGC    FGC    FGCT     GCT</span><br><span class="line"> 39680.0  38773.6   4608.0   4422.3     80896.0     22094.7    313     2    0.098    0.805</span><br></pre></td></tr></table></figure></p>
<ul>
<li>MC：元空间承诺大小</li>
<li>MU：元空间已使用容量</li>
<li>CCSC：压缩类容量大小</li>
<li>CCSU：压缩类已使用容量</li>
<li>OC：老年代总容量</li>
<li>OU：老年代已使用容量</li>
<li>YGC：新生代垃圾回收次数</li>
<li>FGC：老年代垃圾回收次数</li>
<li>FGCT：老年代垃圾回收时间</li>
<li>GCT：垃圾回收总耗时</li>
</ul>
<h5 id="gcoldcapacity"><a href="#gcoldcapacity" class="headerlink" title="-gcoldcapacity"></a>-gcoldcapacity</h5><p>老年代大小统计。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">λ jstat -gcoldcapacity 105308</span><br><span class="line">   OGCMN       OGCMX        OGC         OC       YGC   FGC    FGCT     GCT</span><br><span class="line">   173568.0   2771968.0     80896.0     80896.0   740     2    0.098    1.668</span><br></pre></td></tr></table></figure></p>
<ul>
<li>OGCMN：老年代最小容量</li>
<li>OGCMX：老年代最大容量</li>
<li>OGC：当前老年代容量</li>
<li>OC：老年代总容量</li>
<li>YGC：年轻的GC次数</li>
<li>FGC：老年代GC次数</li>
<li>FGCT：老年代垃圾回收时间</li>
<li>GCT：垃圾回收总耗时</li>
</ul>
<h5 id="gcmetacapacity"><a href="#gcmetacapacity" class="headerlink" title="-gcmetacapacity"></a>-gcmetacapacity</h5><p>元空间大小统计。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">λ jstat -gcmetacapacity 105308</span><br><span class="line">   MCMN       MCMX        MC       CCSMN      CCSMX       CCSC     YGC   FGC    FGCT     GCT</span><br><span class="line">       0.0  1085440.0    40448.0        0.0  1048576.0     4608.0   848     2    0.098    1.885</span><br></pre></td></tr></table></figure></p>
<ul>
<li>MCMN：元空间最小容量</li>
<li>MCMX：元空间最大容量</li>
<li>MC：元空间当前容量</li>
<li>CCSMN：压缩类空间最小容量</li>
<li>CCSMX：压缩类空间最大容量</li>
<li>CCSC：当前压缩类空间容量</li>
<li>YGC：年轻的GC次数</li>
<li>FGC：老年代GC次数</li>
<li>FGCT：老年代垃圾回收时间</li>
<li>GCT：垃圾回收总耗时</li>
</ul>
<h5 id="gcutil"><a href="#gcutil" class="headerlink" title="-gcutil"></a>-gcutil</h5><p>垃圾收集器统计概述。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">λ jstat -gcutil 105308</span><br><span class="line">  S0     S1     E      O      M     CCS    YGC     YGCT    FGC    FGCT     GCT</span><br><span class="line">  0.00  31.25  57.06  30.97  97.41  96.00    959    2.047     2    0.098    2.145</span><br></pre></td></tr></table></figure></p>
<ul>
<li>S0、S1、E、O、M、CCS分别为对应内存空间已使用容量占总容量的百分比。</li>
</ul>
<h4 id="printcompilation"><a href="#printcompilation" class="headerlink" title="-printcompilation"></a>-printcompilation</h4><p>HotSpot编译方法统计。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">λ jstat -printcompilation 105308</span><br><span class="line">Compiled  Size  Type Method</span><br><span class="line">    7351     30    1 org/apache/http/message/TokenParser isWhitespace</span><br></pre></td></tr></table></figure></p>
<ul>
<li>Compiled：被执行的编译任务的数量</li>
<li>Size：方法字节码的字节数</li>
<li>Type：编译类型</li>
<li>Method：编译方法的类名和方法名。类名使用”/“ 代替 “.” 作为空间分隔符. 方法名是给出类的方法名. 格式是一致于HotSpot - XX:+PrintComplation 选项</li>
</ul>
<h3 id="示例分析"><a href="#示例分析" class="headerlink" title="示例分析"></a>示例分析</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">λ jstat -gcutil 105308 200 10</span><br><span class="line">  S0     S1     E      O      M     CCS    YGC     YGCT    FGC    FGCT     GCT</span><br><span class="line"> 31.25   0.00  69.70  41.31  97.43  96.12   3050    6.466     2    0.098    6.564</span><br><span class="line">  0.00  25.00  25.65  41.31  97.43  96.12   3051    6.468     2    0.098    6.566</span><br><span class="line">  0.00  25.00  38.43  41.31  97.43  96.12   3051    6.468     2    0.098    6.566</span><br><span class="line">  0.00  25.00  50.31  41.31  97.43  96.12   3051    6.468     2    0.098    6.566</span><br><span class="line">  0.00  25.00  63.75  41.31  97.43  96.12   3051    6.468     2    0.098    6.566</span><br><span class="line">  0.00  25.00  73.27  41.31  97.43  96.12   3051    6.468     2    0.098    6.566</span><br><span class="line">  0.00  25.00  84.72  41.31  97.43  96.12   3051    6.468     2    0.098    6.566</span><br><span class="line">  0.00  25.00  99.04  41.31  97.43  96.12   3051    6.468     2    0.098    6.566</span><br><span class="line"> 31.25   0.00  11.40  41.31  97.43  96.12   3052    6.469     2    0.098    6.567</span><br><span class="line"> 31.25   0.00  20.88  41.31  97.43  96.12   3052    6.469     2    0.098    6.567</span><br></pre></td></tr></table></figure>
<p>示例中vmid为105308，指令含义为输出垃圾收集统计概述，输出策略为每200毫秒一次共输出10次<br>根据结果可得出以下结果：</p>
<ol>
<li>10次内进行两次新生代GC</li>
<li>第一次新生代GC耗时0.002秒，第二次耗时0.001秒。</li>
<li>没有进行老年代收集，老年代没有空间上的变化，说明Eden区没有对象年龄晋升到老年代</li>
<li>第一次YGC将S0内对象提升到S1，S1部分对象提升到Eden区</li>
<li>元空间没有变化，但元空间使用程度已经极高，到了96.12%，这个时候就可以考虑下元空间调优的问题了。</li>
</ol>
<h2 id="jmap-print-details-of-a-specified-process"><a href="#jmap-print-details-of-a-specified-process" class="headerlink" title="jmap - print details of a specified process"></a>jmap - print details of a specified process</h2><p>jmap(JVM Memory Map)：用于生成heap dump文件，还可以查询finalize执行队列、Java堆和永久代的详细信息，如当前使用率、当前使用的是哪种收集器等。<br>可以使用XX:+HeapDumpOnOutOfMemoryError参数来让虚拟机出现OOM的时候·自动生成dump文件。</p>
<p>命令格式：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jmap -&lt;options&gt; &lt;vmid&gt;</span><br></pre></td></tr></table></figure></p>
<h3 id="options参数-2"><a href="#options参数-2" class="headerlink" title="options参数"></a>options参数</h3><h4 id="总览-1"><a href="#总览-1" class="headerlink" title="总览"></a>总览</h4><div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:left">参数</th>
<th style="text-align:left">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">-clstats</td>
<td style="text-align:left">打印java堆类加载统计信息<br>Prints class loader wise statistics of Java heap.</td>
</tr>
<tr>
<td style="text-align:left">-finalizerinfo</td>
<td style="text-align:left">打印等待结束的对象信息<br>Prints information about objects that are awaiting finalization.</td>
</tr>
<tr>
<td style="text-align:left">-histo[:live]</td>
<td style="text-align:left">打印堆的对象统计，包括对象数量，大小等。也可以单独指定子项：live，只打印存活对象。<br>Prints a histogram of the heap. For each Java class, the number of objects, memory size in bytes, and the fully qualified class names are printed. The JVM internal class names are printed with an asterisk (*) prefix. If the live suboption is specified, then only active objects are counted.</td>
</tr>
<tr>
<td style="text-align:left">-dump:[live,] format=b, file=filename</td>
<td style="text-align:left">将Java堆以hprof二进制格式转储为文件名filename。live子选项选定时，只转储存活对象。<br>Dumps the Java heap in hprof binary format to filename. The live suboption is optional, but when specified, only the active objects in the heap are dumped. To browse the heap dump, you can use the jhat(1) command to read the generated file.</td>
</tr>
<tr>
<td style="text-align:left">-heap</td>
<td style="text-align:left">输出java堆概览.<br>Prints a heap summary of the garbage collection used, the head configuration, and generation-wise heap usage. In addition, the number and size of interned Strings are printed.</td>
</tr>
</tbody>
</table>
</div>
<h4 id="详解"><a href="#详解" class="headerlink" title="详解"></a>详解</h4><h5 id="clstats"><a href="#clstats" class="headerlink" title="-clstats"></a>-clstats</h5><p>连接正在运行的进程，打印类加载器的统计信息<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line">λ jmap -clstats 75052</span><br><span class="line">Attaching to process ID 75052, please wait...</span><br><span class="line">Debugger attached successfully.</span><br><span class="line">Server compiler detected.</span><br><span class="line">JVM version is 25.131-b11</span><br><span class="line">finding class loader instances ..done.</span><br><span class="line">computing per loader stat ..done.</span><br><span class="line">please wait.. computing liveness.liveness analysis may be inaccurate ...</span><br><span class="line">class_loader    classes bytes   parent_loader   alive?  type</span><br><span class="line"></span><br><span class="line">&lt;bootstrap&gt;     3735    6715263   null          live    &lt;internal&gt;</span><br><span class="line">0x00000006c24851c8      1       889     0x00000006c24853f0      dead    sun/reflect/DelegatingClassLoader@0x00000007c0009df8</span><br><span class="line">0x00000006c3220ba0      1       1471    0x00000006c2418f08      dead    sun/reflect/DelegatingClassLoader@0x00000007c0009df8</span><br><span class="line">0x00000006c3820380      1       1471    0x00000006c2418f08      dead    sun/reflect/DelegatingClassLoader@0x00000007c0009df8</span><br><span class="line">0x00000006c383c380      1       1471    0x00000006c2418f08      dead    sun/reflect/DelegatingClassLoader@0x00000007c0009df8</span><br><span class="line">0x00000006c2cea748      1       878       null          dead    sun/reflect/DelegatingClassLoader@0x00000007c0009df8</span><br><span class="line">0x00000006c2bf8178      1       1472      null          dead    sun/reflect/DelegatingClassLoader@0x00000007c0009df8</span><br><span class="line">0x00000006c337c6f0      1       1483    0x00000006c2418f08      dead    sun/reflect/DelegatingClassLoader@0x00000007c0009df8</span><br><span class="line">0x00000006c2485100      1       878       null          dead    sun/reflect/DelegatingClassLoader@0x00000007c0009df8</span><br><span class="line">0x00000006c2418f08      2749    5382011 0x00000006c2418f68      dead    sun/misc/Launcher$AppClassLoader@0x00000007c000f6a0</span><br><span class="line">0x00000006c3220c68      1       1471    0x00000006c2418f08      dead    sun/reflect/DelegatingClassLoader@0x00000007c0009df8</span><br><span class="line">0x00000006c2cea680      1       880       null          dead    sun/reflect/DelegatingClassLoader@0x00000007c0009df8</span><br><span class="line">0x00000006c337c838      1       1473    0x00000006c2418f08      dead    sun/reflect/DelegatingClassLoader@0x00000007c0009df8</span><br><span class="line">0x00000006c3908b40      1       1471      null          dead    sun/reflect/DelegatingClassLoader@0x00000007c0009df8</span><br><span class="line">0x00000006c2ceab58      1       880       null          dead    sun/reflect/DelegatingClassLoader@0x00000007c0009df8</span><br><span class="line">0x00000006c3908c08      1       1471      null          dead    sun/reflect/DelegatingClassLoader@0x00000007c0009df8</span><br><span class="line">0x00000006c28bafd0      0       0       0x00000006c2418f08      dead    java/util/ResourceBundle$RBClassLoader@0x00000007c0089950</span><br><span class="line">0x00000006c2ceaa90      1       1472    0x00000006c2418f08      dead    sun/reflect/DelegatingClassLoader@0x00000007c0009df8</span><br><span class="line">0x00000006c2bf87a0      1       1473      null          dead    sun/reflect/DelegatingClassLoader@0x00000007c0009df8</span><br><span class="line">0x00000006c2bf89a0      1       1471      null          dead    sun/reflect/DelegatingClassLoader@0x00000007c0009df8</span><br><span class="line">0x00000006c2485328      1       1471      null          dead    sun/reflect/DelegatingClassLoader@0x00000007c0009df8</span><br><span class="line">0x00000006c39089b0      1       1471      null          dead    sun/reflect/DelegatingClassLoader@0x00000007c0009df8</span><br><span class="line">0x00000006c3222ec0      1       880     0x00000006c2418f08      dead    sun/reflect/DelegatingClassLoader@0x00000007c0009df8</span><br><span class="line">0x00000006c37cced8      1       1471      null          dead    sun/reflect/DelegatingClassLoader@0x00000007c0009df8</span><br><span class="line">0x00000006c2bd2298      40      93710   0x00000006c2418f08      dead    com/alibaba/fastjson/util/ASMClassLoader@0x00000007c02af098</span><br><span class="line">0x00000006c2cea428      1       1474      null          dead    sun/reflect/DelegatingClassLoader@0x00000007c0009df8</span><br><span class="line">0x00000006c2bf86d8      1       1473      null          dead    sun/reflect/DelegatingClassLoader@0x00000007c0009df8</span><br><span class="line">0x00000006c337d290      1       1485    0x00000006c2418f08      dead    sun/reflect/DelegatingClassLoader@0x00000007c0009df8</span><br><span class="line">0x00000006c3908a78      1       1471      null          dead    sun/reflect/DelegatingClassLoader@0x00000007c0009df8</span><br><span class="line">0x00000006c2418f68      124     266033    null          dead    sun/misc/Launcher$ExtClassLoader@0x00000007c000fa48</span><br><span class="line">0x00000006c3222f88      1       1471    0x00000006c2418f08      dead    sun/reflect/DelegatingClassLoader@0x00000007c0009df8</span><br><span class="line">0x00000006c37cce10      1       1471    0x00000006c2418f08      dead    sun/reflect/DelegatingClassLoader@0x00000007c0009df8</span><br><span class="line">0x00000006c2cea360      1       1485      null          dead    sun/reflect/DelegatingClassLoader@0x00000007c0009df8</span><br><span class="line">0x00000006c2bf8610      1       1471      null          dead    sun/reflect/DelegatingClassLoader@0x00000007c0009df8</span><br><span class="line">0x00000006c2485038      1       1471      null          dead    sun/reflect/DelegatingClassLoader@0x00000007c0009df8</span><br><span class="line">0x00000006c2cea5b8      1       880       null          dead    sun/reflect/DelegatingClassLoader@0x00000007c0009df8</span><br><span class="line">0x00000006c2bf8308      1       1471    0x00000006c2418f68      dead    sun/reflect/DelegatingClassLoader@0x00000007c0009df8</span><br><span class="line">0x00000006c2bf8548      1       1473      null          dead    sun/reflect/DelegatingClassLoader@0x00000007c0009df8</span><br><span class="line">0x00000006c337cf80      1       878       null          dead    sun/reflect/DelegatingClassLoader@0x00000007c0009df8</span><br><span class="line">0x00000006c2484ef0      1       880       null          dead    sun/reflect/DelegatingClassLoader@0x00000007c0009df8</span><br><span class="line">0x00000006c24853f0      12      37276   0x00000006c2418f08      dead    sun/reflect/misc/MethodUtil@0x00000007c0116af8</span><br><span class="line">0x00000006c2cea4f0      1       880       null          dead    sun/reflect/DelegatingClassLoader@0x00000007c0009df8</span><br><span class="line">0x00000006c2bf8240      1       1473      null          dead    sun/reflect/DelegatingClassLoader@0x00000007c0009df8</span><br><span class="line">0x00000006c337d048      1       878       null          dead    sun/reflect/DelegatingClassLoader@0x00000007c0009df8</span><br><span class="line">0x00000006c37fe380      1       1471      null          dead    sun/reflect/DelegatingClassLoader@0x00000007c0009df8</span><br><span class="line"></span><br><span class="line">total = 45      6699    12545217            N/A         alive=1, dead=44            N/A</span><br></pre></td></tr></table></figure></p>
<ul>
<li>class_loader：类加载器</li>
<li>classes：加载的class数</li>
<li>bytes：加载字节码大小</li>
<li>parent_loader：父类加载器</li>
<li>live：存活状态</li>
<li>type：加载器类型</li>
</ul>
<h5 id="finalizerinfo"><a href="#finalizerinfo" class="headerlink" title="-finalizerinfo"></a>-finalizerinfo</h5><p>打印等待结束的对象信息<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">λ jmap -finalizerinfo 75052</span><br><span class="line">  Attaching to process ID 75052, please wait...</span><br><span class="line">  Debugger attached successfully.</span><br><span class="line">  Server compiler detected.</span><br><span class="line">  JVM version is 25.131-b11</span><br><span class="line">  Number of objects pending for finalization: 0</span><br></pre></td></tr></table></figure></p>
<p>可以看出来，目前没有等待结束的对象</p>
<h5 id="histo"><a href="#histo" class="headerlink" title="-histo"></a>-histo</h5><p>打印堆的对象统计，包括对象数量，大小等。也可以单独指定子项：live，只打印存活对象。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">λ jmap -histo:live 75052|more</span><br><span class="line"></span><br><span class="line"> num     #instances         #bytes  class name</span><br><span class="line">----------------------------------------------</span><br><span class="line">   1:          4071        5668128  [I</span><br><span class="line">   2:         52491        4982384  [C</span><br><span class="line">   3:          3629        1511648  [B</span><br><span class="line">   4:         51380        1233120  java.lang.String</span><br><span class="line">   5:          6620         751480  java.lang.Class</span><br><span class="line">   6:         16354         523328  java.util.concurrent.ConcurrentHashMap$Node</span><br><span class="line">   7:         15464         494848  java.util.HashMap$Node</span><br><span class="line">   8:          6599         409624  [Ljava.lang.Object;</span><br><span class="line">   9:          2787         245256  java.lang.reflect.Method</span><br><span class="line">  10:          1363         200728  [Ljava.util.HashMap$Node;</span><br><span class="line">  11:          8237         197688  sun.font.TrueTypeFont$DirectoryEntry</span><br><span class="line">  12:          6121         195872  java.util.Hashtable$Entry</span><br><span class="line">  13:           209         143976  [J</span><br><span class="line">-- More  --</span><br></pre></td></tr></table></figure></p>
<p>因histo统计对象的类型很多，带上more后，可根据命令窗口大小进行部分展示，可回车后继续展示。<br>其中class name为对象类型的，部分为简写，含义如下：</p>
<ul>
<li>B  byte</li>
<li>C  char</li>
<li>D  double</li>
<li>F  float</li>
<li>I  int</li>
<li>J  long</li>
<li>Z  boolean</li>
<li>[  数组，如[I表示int[]</li>
<li>[L+类名 其他对象</li>
</ul>
<h5 id="dump"><a href="#dump" class="headerlink" title="-dump"></a>-dump</h5><p>转储java堆信息，包含子项如下：</p>
<ul>
<li>live：当指定后，只转储存活对象</li>
<li>format=b：转储格式，以hprof二进制格式转储Java堆</li>
<li>file=filename：转储文件名  </li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">λ jmap -dump:live,format=b,file=heap 75052</span><br><span class="line">  Dumping heap to C:\Users\Y\heap1 ...</span><br><span class="line">  Heap dump file created</span><br></pre></td></tr></table></figure>
<p>示例中转储文件会生成在C:\Users\Y\目录下，后续dump文件分析可以根据文件大小进行选择。<br>分析工具：</p>
<ul>
<li>JDK自带程序jvisiualvm.exe</li>
<li>jhat命令</li>
<li>Eclipse Memory Analyzer(MAT)</li>
</ul>
<h5 id="heap"><a href="#heap" class="headerlink" title="-heap"></a>-heap</h5><p>输出java堆概览<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">λ jmap -heap 75052</span><br><span class="line">Attaching to process ID 75052, please wait...</span><br><span class="line">Debugger attached successfully.</span><br><span class="line">Server compiler detected.</span><br><span class="line">JVM version is 25.131-b11</span><br><span class="line"></span><br><span class="line">using thread-local object allocation.</span><br><span class="line">Parallel GC with 4 thread(s)  //GC方式，并行</span><br><span class="line"></span><br><span class="line">Heap Configuration:			//堆初始配置，可以通过 -XX:*(eg:NewSize) 进行对应参数设置</span><br><span class="line">   MinHeapFreeRatio         = 0		//最小空闲比率</span><br><span class="line">   MaxHeapFreeRatio         = 100		//最大空闲比率</span><br><span class="line">   MaxHeapSize              = 4257218560 (4060.0MB)		//最大堆内存</span><br><span class="line">   NewSize                  = 88604672 (84.5MB)		//新生代内存容量</span><br><span class="line">   MaxNewSize               = 1418723328 (1353.0MB)		//最大新生代内存容量</span><br><span class="line">   OldSize                  = 177733632 (169.5MB)		//老年代内存容量</span><br><span class="line">   NewRatio                 = 2		//新生代和老年代大小比例</span><br><span class="line">   SurvivorRatio            = 8		//Eden区与Survivor区的大小比值</span><br><span class="line">   MetaspaceSize            = 21807104 (20.796875MB)		//元空内存容量</span><br><span class="line">   CompressedClassSpaceSize = 1073741824 (1024.0MB)		//压缩类空间内存容量</span><br><span class="line">   MaxMetaspaceSize         = 17592186044415 MB		//最大元空间内存</span><br><span class="line">   G1HeapRegionSize         = 0 (0.0MB)		//G1垃圾回收器中指定分区大小(1MB~32MB，且必须是2的幂)，默认将整堆划分为2048个分区</span><br><span class="line"></span><br><span class="line">Heap Usage:</span><br><span class="line">PS Young Generation</span><br><span class="line">Eden Space:		//Eden区使用情况：总容量、已使用、空闲、使用比例</span><br><span class="line">   capacity = 31981568 (30.5MB)</span><br><span class="line">   used     = 5003392 (4.7716064453125MB)</span><br><span class="line">   free     = 26978176 (25.7283935546875MB)</span><br><span class="line">   15.644611296106557% used</span><br><span class="line">From Space:		//survivor0使用情况</span><br><span class="line">   capacity = 524288 (0.5MB)</span><br><span class="line">   used     = 131072 (0.125MB)</span><br><span class="line">   free     = 393216 (0.375MB)</span><br><span class="line">   25.0% used</span><br><span class="line">To Space:		//survivor1使用情况</span><br><span class="line">   capacity = 524288 (0.5MB)</span><br><span class="line">   used     = 0 (0.0MB)</span><br><span class="line">   free     = 524288 (0.5MB)</span><br><span class="line">   0.0% used</span><br><span class="line">PS Old Generation		//老年代使用情况</span><br><span class="line">   capacity = 88604672 (84.5MB)</span><br><span class="line">   used     = 22120552 (21.095802307128906MB)</span><br><span class="line">   free     = 66484120 (63.404197692871094MB)</span><br><span class="line">   24.965446517312316% used</span><br><span class="line"></span><br><span class="line">21409 interned Strings occupying 2142768 bytes.</span><br></pre></td></tr></table></figure></p>
<h2 id="jhat"><a href="#jhat" class="headerlink" title="jhat"></a>jhat</h2><p>jhat(JVM Heap Analysis Tool)与jmap结合使用，用来分析dump文件。jhat内置了一个微型的HTTP/HTML服务器，生成dump的分析结果后，可以在浏览器中查看.<br>本文基于JDK8来分析使用相关命令，所以依旧存在jhat命令。从JDK9的时候已经删除了（JEP 241: Remove the jhat Tool）。现在Oracle官方推荐的分析工具是Eclipse Memory Analyzer Tool (MAT) 和 VisualVM(jvisualvm.exe)。</p>
<p>相关操作参数,有兴趣的可以深入了解一下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">Usage:  jhat [-stack &lt;bool&gt;] [-refs &lt;bool&gt;] [-port &lt;port&gt;] [-baseline &lt;file&gt;] [-debug &lt;int&gt;] [-version] [-h|-help] &lt;file&gt;</span><br><span class="line"></span><br><span class="line">        -J&lt;flag&gt;          Pass &lt;flag&gt; directly to the runtime system. For</span><br><span class="line">                          example, -J-mx512m to use a maximum heap size of 512MB</span><br><span class="line">        -stack false:     Turn off tracking object allocation call stack.</span><br><span class="line">        -refs false:      Turn off tracking of references to objects</span><br><span class="line">        -port &lt;port&gt;:     Set the port for the HTTP server.  Defaults to 7000</span><br><span class="line">        -exclude &lt;file&gt;:  Specify a file that lists data members that should</span><br><span class="line">                          be excluded from the reachableFrom query.</span><br><span class="line">        -baseline &lt;file&gt;: Specify a baseline object dump.  Objects in</span><br><span class="line">                          both heap dumps with the same ID and same class will</span><br><span class="line">                          be marked as not being &quot;new&quot;.</span><br><span class="line">        -debug &lt;int&gt;:     Set debug level.</span><br><span class="line">                            0:  No debug output</span><br><span class="line">                            1:  Debug hprof file parsing</span><br><span class="line">                            2:  Debug hprof file parsing, no server</span><br><span class="line">        -version          Report version number</span><br><span class="line">        -h|-help          Print this help and exit</span><br><span class="line">        &lt;file&gt;            The file to read</span><br></pre></td></tr></table></figure></p>

          
        
      
    </div>

    
    
    
      <footer class="post-footer">
          <div class="post-eof"></div>
        
      </footer>
  </div>
  
  
  
  </article>

    
      

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="cmeng001.github.io/2020/08/18/java/多线程/future/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="cmeng">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="c萌怪谈">
    </span>
      <header class="post-header">

        
          <h1 class="post-title" itemprop="name headline">
              
              <a href="/2020/08/18/java/多线程/future/" class="post-title-link" itemprop="url">java的future体系</a>
            
          </h1>
        

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              
                
              

              <time title="创建时间：2020-08-18 16:13:12" itemprop="dateCreated datePublished" datetime="2020-08-18T16:13:12+08:00">2020-08-18</time>
            </span>
          
            

            
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-08-15 08:57:12" itemprop="dateModified" datetime="2022-08-15T08:57:12+08:00">2022-08-15</time>
              </span>
            
          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/java/" itemprop="url" rel="index"><span itemprop="name">java</span></a></span>

                
                
                  ，
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/java/多线程/" itemprop="url" rel="index"><span itemprop="name">多线程</span></a></span>

                
                
              
            </span>
          

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          
            <h2 id="一、Future概念"><a href="#一、Future概念" class="headerlink" title="一、Future概念"></a>一、Future概念</h2><h3 id="1-1、概念"><a href="#1-1、概念" class="headerlink" title="1.1、概念"></a>1.1、概念</h3><p><font color="blue"> <strong><a href="https://docs.oracle.com/en/java/javase/18/docs/api/java.base/java/util/concurrent/Future.html" target="_blank" rel="noopener">Oracle官方文档</a></strong> </font> 针对Future接口解释如下：未来表示异步计算的结果。提供了检查计算是否完成，等待计算完成以及检索计算结果的方法。只有在计算完成时，才能使用方法 <strong>get()</strong> 检索结果，如有必要，在计算准备就绪之前将其阻止。取消由取消方法执行。</p>
<p>举个例子：发快递时的快递单号，整个快递过程中单号就是唯一的重要标识与凭证。<strong>Future</strong> 就类似于这个单号，在异步操作中，可以根据 <strong>Future</strong> 去提取相关的操作结果。所以<strong>Future</strong> 表示的是异步任务还没完成提前给出的未来结果。</p>
<h3 id="1-2、Future"><a href="#1-2、Future" class="headerlink" title="1.2、Future"></a>1.2、Future</h3><p>java中 Future 就是对于具体的 <strong>Runnable</strong> 或者 <strong>Callable</strong>（下面会详细介绍） 任务的执行结果进行取消、查询是否完成、获取结果。必要时可以通过get方法获取执行结果，该方法会阻塞直到任务返回结果。</p>
<p><strong>代码定义</strong>：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Future</span>&lt;<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">cancel</span><span class="params">(<span class="keyword">boolean</span> mayInterruptIfRunning)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">isCancelled</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">isDone</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function">V <span class="title">get</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException, ExecutionException</span>;</span><br><span class="line">    <span class="function">V <span class="title">get</span><span class="params">(<span class="keyword">long</span> timeout, TimeUnit unit)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> InterruptedException, ExecutionException, TimeoutException</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><strong>提供功能点：</strong></p>
<ul>
<li>cancel：用来取消任务，成功：true，失败：false。如果任务【已完成】或【未执行】或【被取消过】则返回false。<ul>
<li>参数 <strong>mayInterruptIfRunning</strong> 表示是否允许取消正在执行却没有执行完毕的任务。</li>
</ul>
</li>
<li>isCancelled：方法表示任务是否被取消成功，如果在任务正常完成前被取消成功，则返回 true。</li>
<li>isDone方法表示任务是否已经完成，若任务完成，则返回true；</li>
<li>get()方法用来获取执行结果，这个方法会产生阻塞，会一直等到任务执行完毕才返回；</li>
<li>get(long timeout, TimeUnit unit)用来获取执行结果，如果在指定时间内，还没获取到结果，就直接返回null。</li>
</ul>
<p><strong>也就是说Future提供了三种功能：</strong></p>
<ul>
<li>判断任务是否完成；</li>
<li>能够中断任务；</li>
<li>能够获取任务执行结果。<br>因为Future只是一个接口，所以是无法直接用来创建对象使用的，因此就有了下面的FutureTask。</li>
</ul>
<h3 id="1-2、与Thread区别"><a href="#1-2、与Thread区别" class="headerlink" title="1.2、与Thread区别"></a>1.2、与Thread区别</h3><p>常见的两种创建线程的方式。一种是直接继承Thread，另外一种就是实现Runnable接口。Future与这二者的唯一区别就是：<strong>Thread是没有返回结果的，而Future模式是有返回结果的。</strong></p>
<h2 id="二、Future使用"><a href="#二、Future使用" class="headerlink" title="二、Future使用"></a>二、Future使用</h2><p>先假设个场景，我们要做烧仙草奶茶。那么就需要分别把烧仙草和奶茶做好，然后再做出烧仙草奶茶，前面的烧仙草的制作和奶茶的制作都耗时不短，而且二者完全独立，所以可以有二者同时进行即有两个线程分别去制作。等均完成后进行最后的制作。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    ExecutorService executorService = Executors.newCachedThreadPool();</span><br><span class="line"></span><br><span class="line">    FutureTask&lt;String&gt; makeGrassJelly = <span class="keyword">new</span> FutureTask&lt;&gt;(<span class="keyword">new</span> Callable&lt;String&gt;() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> String <span class="title">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">":"</span> + <span class="string">"开始制作烧仙草。。。。。"</span>);</span><br><span class="line">            <span class="comment">// 模拟制作耗时耗时</span></span><br><span class="line">            Thread.sleep(<span class="number">3000</span>);</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">":"</span>  + <span class="string">"烧仙草已经做好了..."</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="string">"烧仙草"</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    executorService.submit(makeGrassJelly);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//也可使用如下方式，两种方式的效果一样，只不过一个使用的是ExecutorService，一个使用的是Thread</span></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    Thread thread = new Thread(makeGrassJelly);</span></span><br><span class="line"><span class="comment">    thread.start();</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 在制作烧仙草的同时制作奶茶</span></span><br><span class="line">    System.out.println(Thread.currentThread().getName() + <span class="string">":"</span>  + <span class="string">" 烧仙草的线程已经开始，下面我们做奶茶..."</span>);</span><br><span class="line">    <span class="comment">// 模拟奶茶制作的耗时</span></span><br><span class="line">    Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">    System.out.println(Thread.currentThread().getName() + <span class="string">":"</span>  + <span class="string">"奶茶准备好了"</span>);</span><br><span class="line">    String milkTea = <span class="string">"奶茶"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 开水已经稍好，我们取得烧好的开水</span></span><br><span class="line">    String grassJelly = makeGrassJelly.get();</span><br><span class="line"></span><br><span class="line">    System.out.println(Thread.currentThread().getName() + <span class="string">":"</span>  + grassJelly  + milkTea + <span class="string">"：制作完成了，可以开吃了"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>执行结果：</p>
<blockquote>
<p>main: 烧仙草的线程已经开始，下面我们做奶茶…<br>pool-1-thread-1:开始制作烧仙草。。。。。<br>main:奶茶准备好了<br>pool-1-thread-1:烧仙草已经做好了…<br>main:烧仙草奶茶：制作完成了，可以开吃了</p>
</blockquote>
<p><strong>从demo可知，使用Future步骤如下：</strong></p>
<ul>
<li>新建一个Callable匿名函数实现类对象，我们的业务逻辑在Callable的call方法中实现，其中Callable的泛型是返回结果类型；</li>
<li>然后把Callable匿名函数对象作为FutureTask的构造参数传入，构建一个futureTask对象；</li>
<li>然后再把futureTask对象作为Thread构造参数传入并开启这个线程执行去执行业务逻辑；</li>
<li>最后我们调用futureTask对象的get方法得到业务逻辑执行结果。</li>
</ul>
<p>可以看到跟 Future 使用有关的JDK类主要有 <strong>FutureTask</strong> 和 <strong>Callable</strong> 两个，下面分别对对 <strong>Callable</strong> 和 <strong>FutureTask</strong> 进行源码分析。</p>
<h2 id="三、Callable"><a href="#三、Callable" class="headerlink" title="三、Callable"></a>三、Callable</h2><p>正式进入Future模式讲解前，先了解下预备知识之——Callable。</p>
<h3 id="3-1、Callable-介绍"><a href="#3-1、Callable-介绍" class="headerlink" title="3.1、Callable 介绍"></a>3.1、Callable 介绍</h3><p><strong>Callable：</strong> 代表一段可以调用并返回结果的代码；<strong>Future接口</strong> 表示异步任务，是还没有完成的任务给出的未来结果。所以说 <strong>Callable</strong> 用于产生结果，<strong>Future</strong> 用于获取结果。 </p>
<p><strong>代码声明</strong>：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Callable</span>&lt;<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 计算结果，如果计算失败则抛出异常</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> computed result</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> Exception if unable to compute a result</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function">V <span class="title">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>可以看到，这是一个泛型接口，call()函数返回的类型就是传递进来的V类型。<br>一般情况下是配合 ExecutorService 来使用的，在 ExecutorService 接口中声明了若干个submit方法的重载版本：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;T&gt; <span class="function">Future&lt;T&gt; <span class="title">submit</span><span class="params">(Callable&lt;T&gt; task)</span></span>;</span><br><span class="line">&lt;T&gt; <span class="function">Future&lt;T&gt; <span class="title">submit</span><span class="params">(Runnable task, T result)</span></span>;</span><br><span class="line">Future&lt;?&gt; submit(Runnable task);</span><br></pre></td></tr></table></figure></p>
<p>第一个 <strong>submit</strong> 方法里面的参数类型就是 <strong>Callable</strong>。返回的是 <strong>Future</strong> 类型对象。</p>
<h3 id="3-2、与Runnable"><a href="#3-2、与Runnable" class="headerlink" title="3.2、与Runnable"></a>3.2、与Runnable</h3><ol>
<li><p>相同点</p>
<ul>
<li>都可以开发多线程。</li>
<li>都可以使用ExecutorService来执行。   </li>
</ul>
</li>
<li><p>不同点</p>
<ul>
<li>Callable有返回值，可以向上抛异常。Runnable不行。</li>
<li>都使用 ExecutorService 来执行，Callable 的返回值有意义，Runnable 的返回值为空。</li>
</ul>
</li>
</ol>
<h3 id="3-3、Callable执行"><a href="#3-3、Callable执行" class="headerlink" title="3.3、Callable执行"></a>3.3、Callable执行</h3><p><strong>Callable</strong> 的使用方式有两种一种是结合 <strong>ExecutorService</strong> 提交使用，一种是构建 <strong>FutureTask</strong> 对象来使用。</p>
<p>就先聊聊 Callable 的使用方法之一是：ExecutorService 的 submit 方法，那么我们就看下具体的执行逻辑和涉及的相关类型。</p>
<p><strong>异步执行demo</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">executeTask</span><span class="params">()</span></span>&#123;</span><br><span class="line">    ExecutorService executorService = Executors.newCachedThreadPool();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//提交带有返回值的任务以供执行，并返回表示任务挂起结果的 Future</span></span><br><span class="line">    Future submit = executorService.submit(()-&gt;&#123;</span><br><span class="line">        <span class="comment">//业务逻辑执行</span></span><br><span class="line">        log.info(<span class="string">"in callable!!!!"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"callable"</span>;</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">//获取执行结果</span></span><br><span class="line">        submit.get();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        log.error(<span class="string">"==== Asynchronous execution exception"</span>);</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(e);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>执行逻辑：</strong><br><strong>1. 获取 ExecutorService 实例</strong>：<br>获取 <strong>ExecutorService</strong> 实例，用于任务提交操作。<strong>newCachedThreadPool()</strong> 将返回 <strong>ThreadPoolExecutor</strong> 类型对象实例。</p>
<p><strong>2. submit() 提交任务</strong></p>
<ul>
<li>执行对象类型<br><strong>Executors.newCachedThreadPool()</strong> 产生的对象实例类型为 <strong>ThreadPoolExecutor</strong>。其继承实现模型为：<br><img src="/image/java/多线程/ThreadPoolExecutor类结构模型.png" alt="ThreadPoolExecutor类结构模型">  </li>
<li>方法调用源码分析<br>提交任务的方法 <strong>submit</strong> 由 <strong>ExecutorService</strong> 接口定义，在 <strong>AbstractExecutorService</strong> 里面实现。<strong>ThreadPoolExecutor</strong> 类没有再次覆盖实现。因此最终调用的代码逻辑为 AbstractExecutorService 内的逻辑，其实现逻辑如下：    </li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// AbstractExecutorService.java</span></span><br><span class="line"><span class="keyword">public</span> &lt;T&gt; <span class="function">Future&lt;T&gt; <span class="title">submit</span><span class="params">(Callable&lt;T&gt; task)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (task == <span class="keyword">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">    RunnableFuture&lt;T&gt; ftask = newTaskFor(task);</span><br><span class="line">    execute(ftask);</span><br><span class="line">    <span class="keyword">return</span> ftask;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// newTaskFor实现</span></span><br><span class="line"><span class="keyword">protected</span> &lt;T&gt; <span class="function">RunnableFuture&lt;T&gt; <span class="title">newTaskFor</span><span class="params">(Callable&lt;T&gt; callable)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> FutureTask&lt;T&gt;(callable);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>由源码可知，submit执行时：</p>
<ol>
<li>先将Callable接口实现转化为 <strong>FutureTask</strong> 类型对象。</li>
<li>然后再通过 <strong>execute</strong> 执行。  </li>
</ol>
<p>具体执行逻辑下面聊到 <strong>FutureTask</strong> 会详细说明。此处已经说明了 <strong>Callable 最终一定通过与 Future 结合进行使用</strong>，达到异步执行任务且返回相关结果的功能。所以两种执行方式的底层实现实为一种：即结合 <strong>FutureTask</strong> 进行使用。</p>
<p>那么接下来就聊聊 <strong>FutureTask</strong> 。</p>
<h2 id="四、FutureTask"><a href="#四、FutureTask" class="headerlink" title="四、FutureTask"></a>四、FutureTask</h2><h3 id="4-1、FutureTask类结构分析"><a href="#4-1、FutureTask类结构分析" class="headerlink" title="4.1、FutureTask类结构分析"></a>4.1、FutureTask类结构分析</h3><p>FutureTask的类结构：<br><img src="/image/java/多线程/FutureTask类结构模型.png" alt="ThreadPoolExecutor类结构模型">  </p>
<p>通过类图我们不难看出,<strong>RunnableFuture</strong> 继承了 <strong>Runable</strong> 以及 <strong>Future</strong> 接口，所以它即可以被线程异步执行，也可作为Future得到callable的计算结果。</p>
<p>下面进入正题聊聊 <strong>FutureTask</strong>，它实现了<strong>RunnableFuture</strong> 接口，所以也是 <strong>Future</strong> 和<strong>Runnable</strong> 接口的具体实现类，即异步任务执行后我们能够获取到异步任务的执行结果。</p>
<p>下面就详详细的通过源码分析下 <strong>FutureTask</strong> 的执行逻辑。</p>
<h3 id="4-2、源码分析——属性"><a href="#4-2、源码分析——属性" class="headerlink" title="4.2、源码分析——属性"></a>4.2、源码分析——属性</h3><p>先看下具体属性，这个在整体运行逻辑中都是很重要的。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// FutureTask.java</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Possible state transitions:</span></span><br><span class="line"><span class="comment"> * NEW -&gt; COMPLETING -&gt; NORMAL</span></span><br><span class="line"><span class="comment"> * NEW -&gt; COMPLETING -&gt; EXCEPTIONAL</span></span><br><span class="line"><span class="comment"> * NEW -&gt; CANCELLED</span></span><br><span class="line"><span class="comment"> * NEW -&gt; INTERRUPTING -&gt; INTERRUPTED</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="comment">// 任务执行状态标识</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">int</span> state;</span><br><span class="line"></span><br><span class="line"><span class="comment">//定义运行状态码</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> NEW          = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> COMPLETING   = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> NORMAL       = <span class="number">2</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> EXCEPTIONAL  = <span class="number">3</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> CANCELLED    = <span class="number">4</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> INTERRUPTING = <span class="number">5</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> INTERRUPTED  = <span class="number">6</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/** Callable对象实现，用于异步执行 */</span></span><br><span class="line"><span class="keyword">private</span> Callable&lt;V&gt; callable;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** 从 get() 返回的结果或抛出的异常 */</span></span><br><span class="line"><span class="keyword">private</span> Object outcome; </span><br><span class="line"></span><br><span class="line"><span class="comment">/** 用来执行callable任务的线程 */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> Thread runner;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** 在 Treiber 中记录等待线程的简单链表节点 */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> WaitNode waiters;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// VarHandle mechanics</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> VarHandle STATE;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> VarHandle RUNNER;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> VarHandle WAITERS;</span><br></pre></td></tr></table></figure></p>
<p>根据Java并发工具类三板斧：</p>
<ul>
<li>状态</li>
<li>队列</li>
<li>CAS操作<br>从这个方面分别对不同的属性进行详细的解析。</li>
</ul>
<h4 id="4-2-1、属性——状态"><a href="#4-2-1、属性——状态" class="headerlink" title="4.2.1、属性——状态"></a>4.2.1、属性——状态</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// FutureTask.java</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> NEW          = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> COMPLETING   = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> NORMAL       = <span class="number">2</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> EXCEPTIONAL  = <span class="number">3</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> CANCELLED    = <span class="number">4</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> INTERRUPTING = <span class="number">5</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> INTERRUPTED  = <span class="number">6</span>;</span><br></pre></td></tr></table></figure>
<p><strong>FutureTask</strong> 中定义了七种状态，一种初始状态，四种终态，两种中间态，由 <strong>0-6</strong> 分别代表分别如下：</p>
<ol>
<li>初始状态：<ul>
<li>NEW：初始状态，这是由构造函数保证的。</li>
</ul>
</li>
<li>中间态：<strong>瞬间状态，而且此状态并不代表任务正执行，而是已经执行完成正（成功或失败异常）在设置返回结果</strong><ul>
<li>COMPLETING： 正在设置任务结果</li>
<li>INTERRUPTING： 正在中断运行任务的线程</li>
</ul>
</li>
<li>终态<ul>
<li>NORMAL：任务正常执行完毕</li>
<li>EXCEPTIONAL：任务执行过程中发生异常</li>
<li>CANCELLED：任务被取消</li>
<li>INTERRUPTED：任务被中断</li>
</ul>
</li>
</ol>
<p><strong>执行状态流转顺序如下</strong>：</p>
<ol>
<li><strong>NEW -&gt; COMPLETING -&gt; NORMAL</strong><ul>
<li>任务正常执行且完成设置返回结果。</li>
<li>状态由 <strong>set</strong> 方法设置。</li>
</ul>
</li>
<li><strong>NEW -&gt; COMPLETING -&gt; EXCEPTIONAL</strong><ul>
<li>任务执行异常。</li>
<li>状态由 <strong>setException</strong> 方法设置。</li>
</ul>
</li>
<li><strong>NEW -&gt; CANCELLED</strong><ul>
<li>任务取消，即调用了 <strong>cancel(false)</strong></li>
<li>状态由 <strong>cancel</strong> 方法设置。</li>
</ul>
</li>
<li><strong>NEW -&gt; INTERRUPTING -&gt; INTERRUPTED</strong><ul>
<li>任务取消，即调用了 <strong>cancel(true)</strong></li>
<li>状态由 <strong>cancel</strong> 方法设置。</li>
</ul>
</li>
</ol>
<p>因此涉及状态修改的只有 set、setException、cancel这三个方法，方法的具体逻辑后面再详细分析。</p>
<h4 id="4-2-2、属性——队列"><a href="#4-2-2、属性——队列" class="headerlink" title="4.2.2、属性——队列"></a>4.2.2、属性——队列</h4><p>聊队列时同时将其它相关操作的属性一块聊一聊，</p>
<ol>
<li><strong>处理逻辑（callable）</strong><br>包含具体的异步执行逻辑内容，整个生命周期从构造函数接收，到call()方法调用执行，到最后的移除销毁整个过程与线程的具体执行逻辑息息相关。后面聊到具体执行逻辑再分析。</li>
<li><strong>执行（runner）</strong><br>用来执行 callable 任务的线程，<strong>runner 属性是在运行时被初始化的。</strong> 简单点说，就是run方法被调用时赋值。</li>
<li><strong>结果（outcome）</strong><br>任务的执行结果，成功为 callable 内的返回结果，失败为异常对象。</li>
<li><strong>队列（waiters）</strong><br>所有等待任务执行完毕的线程的集合。</li>
</ol>
<p>在并发编程中使用队列通常是将 <strong>当前线程包装成某种类型的数据结构扔到等待队列中，</strong> 接下来看下waiters的结构定义：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">WaitNode</span> </span>&#123;</span><br><span class="line">    <span class="keyword">volatile</span> Thread thread;</span><br><span class="line">    <span class="keyword">volatile</span> WaitNode next;</span><br><span class="line">    WaitNode() &#123; thread = Thread.currentThread(); &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>简单的单项链表结构，仅有两个属性一个是当前线程 <strong>thread</strong>，一个是下一个队列节点对象 <strong>next</strong>。</p>
<ul>
<li><strong>thread</strong>：存放当前调用 <strong>FutureTask</strong> 内各相关方法的线程信息。</li>
<li><strong>next</strong>：指向下一个节点的next属性。</li>
</ul>
<p>根据 <strong>WaitNode</strong> 对象的数据结构和属性内容，可以很明显的知道它的作用，即：将当前线程信息存放至链表，按照 <strong>后进先出</strong> 的规则进行相关操作。</p>
<p>因为 <strong>Future</strong> 的 <strong>get()/get(timeout)</strong> 在 task 处于非完成状态时是需要 <strong>阻塞等待</strong> 的，如果多个线程进行 get 操作，显然需要一个链表/队列来维护这些等待线程，这就是waiters的意义所在。</p>
<p>简答模拟了一下五个线程同时调用 <strong>get()</strong> 方法，可看到当第5个线程进行时，<strong>队列（waiters）</strong> 已经有五个等待线程了：<br><img src="/image/java/多线程/Future-waiters模拟.png" alt="Future-waiters模拟"> </p>
<p>其中 <strong>runner</strong> , <strong>waiters</strong> 和 <strong>state</strong> 都是用 <strong>volatile</strong> 关键字修饰，说明这三个变量都是多线程共享的对象（成员变量），会被多线程操作，此时用volatile关键字修饰是为了一个线程操作volatile属性变量值后，能够及时对其他线程可见。当然仅仅如此依旧存在线程安全的问题，所以其相关操作使用的CAS机制来确保线程的安全性。下面就聊下CAS。</p>
<h4 id="4-2-3、属性——CAS"><a href="#4-2-3、属性——CAS" class="headerlink" title="4.2.3、属性——CAS"></a>4.2.3、属性——CAS</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// FutureTask.java</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> VarHandle STATE;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> VarHandle RUNNER;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> VarHandle WAITERS;</span><br><span class="line"><span class="keyword">static</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        MethodHandles.Lookup l = MethodHandles.lookup();</span><br><span class="line">        STATE = l.findVarHandle(FutureTask.class, <span class="string">"state"</span>, <span class="keyword">int</span>.class);</span><br><span class="line">        RUNNER = l.findVarHandle(FutureTask.class, <span class="string">"runner"</span>, Thread.class);</span><br><span class="line">        WAITERS = l.findVarHandle(FutureTask.class, <span class="string">"waiters"</span>, WaitNode.class);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (ReflectiveOperationException e) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> ExceptionInInitializerError(e);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>从这个静态代码块中我们也可以看出，CAS操作主要针对3个属性，包括 <strong>STATE</strong>、<strong>RUNNER</strong> 和  <strong>WAITERS</strong>，说明这3个属性基本是会被多个线程同时访问的。其中 <strong>STATE</strong>属性代表了任务的状态，<strong>WAITERS</strong> 属性代表了指向栈顶节点的指针。<strong>RUNNER</strong> 主要是为了 <strong>中断或者取消任务</strong> 做准备的，只有知道了执行任务的线程是谁，我们才能去中断它。</p>
<p>具体的操作也是使用了CAS方法即 <strong>compareAndSet</strong> 来完成的。</p>
<h3 id="4-3、源码分析——构造函数"><a href="#4-3、源码分析——构造函数" class="headerlink" title="4.3、源码分析——构造函数"></a>4.3、源码分析——构造函数</h3><p>FutureTask有两个构造函数，分别看下源码：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 构造函数1</span></span><br><span class="line"><span class="comment">// FutureTask.java</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">FutureTask</span><span class="params">(Callable&lt;V&gt; callable)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (callable == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">    <span class="keyword">this</span>.callable = callable;</span><br><span class="line">    <span class="keyword">this</span>.state = NEW;       <span class="comment">// ensure visibility of callable</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 构造函数2</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">FutureTask</span><span class="params">(Runnable runnable, V result)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.callable = Executors.callable(runnable, result);</span><br><span class="line">    <span class="keyword">this</span>.state = NEW;       <span class="comment">// ensure visibility of callable</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>构造函数1很好理解，传入 <strong>Callable</strong> 的实现类，将参数赋值属性 <strong>callable</strong>，同时将状态 <strong>state</strong> 置为初始状态 <strong>NEW</strong>，代表新建任务状态。</p>
<p>接着看构造函数2，很明显的区别在于入参变成了 <strong>Runnable</strong> 实现类，且增加了返回结果的泛型集。然后将二者通过 <strong>Executors.callable()</strong> 方法转变成了 <strong>callable</strong> 类型，那么就进入方法具体看下源码：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// FutureTask.java</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function">Callable&lt;T&gt; <span class="title">callable</span><span class="params">(Runnable task, T result)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (task == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> RunnableAdapter&lt;T&gt;(task, result);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">RunnableAdapter</span>&lt;<span class="title">T</span>&gt; <span class="keyword">implements</span> <span class="title">Callable</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Runnable task;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> T result;</span><br><span class="line"></span><br><span class="line">    RunnableAdapter(Runnable task, T result) &#123;</span><br><span class="line">        <span class="keyword">this</span>.task = task;</span><br><span class="line">        <span class="keyword">this</span>.result = result;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">call</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        task.run();</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">super</span>.toString() + <span class="string">"[Wrapped task = "</span> + task + <span class="string">"]"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>由源码可知，方法直接调用了 <strong>RunnableAdapter</strong> 的构造函数，这个方法采用了设计模式中的适配器模式，将一个Runnable类型对象适配成Callable类型。当然 <strong>result</strong> 参数的存在只是为了将一个Runnable 类型适配成 Callable 类型，确实没什么实际意义。   </p>
<h3 id="4-4、源码分析——执行-run方法"><a href="#4-4、源码分析——执行-run方法" class="headerlink" title="4.4、源码分析——执行(run方法)"></a>4.4、源码分析——执行(run方法)</h3><h4 id="4-4-1、执行-run方法-——执行逻辑"><a href="#4-4-1、执行-run方法-——执行逻辑" class="headerlink" title="4.4.1、执行(run方法)——执行逻辑"></a>4.4.1、执行(run方法)——执行逻辑</h4><p><strong>FutureTask</strong> 实现了 <strong>Runnable</strong>，覆写了 <strong>run</strong> 方法，即用于异步执行的线程逻辑。<strong>Callable</strong> 即是需要执行的业务逻辑，他是业务逻辑的基本表现形式，保存在类属性callable，在run函数里面，调用callalbe.call()来执行业务逻辑。下面从源码来了解具体的执行逻辑：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// FutureTask.java</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//1、判断是否满足执行条件，满足条件设置runner属性</span></span><br><span class="line">    <span class="keyword">if</span> (state != NEW ||</span><br><span class="line">        !RUNNER.compareAndSet(<span class="keyword">this</span>, <span class="keyword">null</span>, Thread.currentThread()))</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 2、具体执行业务逻辑，根据执行情况做不同处理</span></span><br><span class="line">        Callable&lt;V&gt; c = callable;</span><br><span class="line">        <span class="comment">// 执行前再次判断状态</span></span><br><span class="line">        <span class="keyword">if</span> (c != <span class="keyword">null</span> &amp;&amp; state == NEW) &#123;</span><br><span class="line">            V result;</span><br><span class="line">            <span class="comment">// 执行状态标识</span></span><br><span class="line">            <span class="keyword">boolean</span> ran;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">// 具体业务执行</span></span><br><span class="line">                result = c.call();</span><br><span class="line">                ran = <span class="keyword">true</span>;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">                result = <span class="keyword">null</span>;</span><br><span class="line">                ran = <span class="keyword">false</span>;</span><br><span class="line">                <span class="comment">// 失败结果集设置</span></span><br><span class="line">                setException(ex);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (ran)</span><br><span class="line">            <span class="comment">// 成功结果集设置</span></span><br><span class="line">                set(result);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="comment">//3、执行完的后处理逻辑</span></span><br><span class="line">        runner = <span class="keyword">null</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> s = state;</span><br><span class="line">        <span class="keyword">if</span> (s &gt;= INTERRUPTING)</span><br><span class="line">            handlePossibleCancellationInterrupt(s);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>从源码可知，具体执行共三步：</p>
<ol>
<li>判断是否满足执行条件，满足条件设置runner属性<ul>
<li>判断任务状态是否为 <strong>NEW</strong> 状态，如果不是，则可能执行完毕或已经被取消，所以直接返回。</li>
<li>如果任务为 <strong>NEW</strong> 状态，则通过 <strong>CAS操作</strong> 将 <strong>runner</strong> 置为当前正在执行异步任务的线程。此处有两种情况：<ul>
<li><strong>runner!=null</strong>：则说明任务依旧处于NEW状态，但已经有线程在执行该任务，所以无需再次执行，CAS操作失败，直接返回。</li>
<li><strong>runner==null</strong> ：说明还未有线程执行过异步任务，此时满足执行异步任务的条件，CAS操作成功，继续执行任务。</li>
</ul>
</li>
</ul>
</li>
<li>具体执行，并根据结果进行相关操作<ul>
<li><strong>if (c != null &amp;&amp; state == NEW)</strong>：再次判断任务状态，状态为NEW则继续执行。</li>
<li><strong>result = c.call();</strong>：调用call()方法执行具体的业务逻辑，根据结果进行操作。<ul>
<li>失败则进入异常操作设置结果集 <strong>setException(ex)</strong>；并设置失败标识 <strong>ran = false</strong>。</li>
<li>成功则设置成功标识 <strong>ran = true</strong> ，并进行成功后结果集的设置 <strong>set(result)</strong>；</li>
</ul>
</li>
</ul>
</li>
<li>后处理逻辑<br>不管异步任务执行成功还是失败，首先将当前执行任务线程 <strong>runner</strong> 置为空，若其他线程有调用 <strong>FutureTask.cancel(true)</strong>，此时需要调用<strong>handlePossibleCancellationInterrupt</strong> 方法处理中断。</li>
</ol>
<h4 id="4-4-2、执行-run方法-——Java线程的实现"><a href="#4-4-2、执行-run方法-——Java线程的实现" class="headerlink" title="4.4.2、执行(run方法)——Java线程的实现"></a>4.4.2、执行(run方法)——Java线程的实现</h4><p>Java线程的使用方式有很多，但最后都会归于 <strong>Thread.start()</strong>方法，无论是使用 Thread 直接调用 start()方法还是使用线程池进行多线程调用，最终都会归于此处。start()内容：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Thread.java</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (threadStatus != <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalThreadStateException();</span><br><span class="line">        group.add(<span class="keyword">this</span>);</span><br><span class="line">        <span class="keyword">boolean</span> started = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            start0();</span><br><span class="line">            started = <span class="keyword">true</span>;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (!started) &#123;</span><br><span class="line">                    group.threadStartFailed(<span class="keyword">this</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Throwable ignore) &#123;</span><br><span class="line">                <span class="comment">/* do nothing. If start0 threw a Throwable then</span></span><br><span class="line"><span class="comment">                  it will be passed up the call stack */</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 本地方法start</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title">start0</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 注册本地方法栈</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title">registerNatives</span><span class="params">()</span></span>;</span><br><span class="line"><span class="keyword">static</span> &#123;</span><br><span class="line">    registerNatives();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>可以看到，最终实现都是调用本地方法栈的 <strong>start0();</strong>。而这些native方法的注册是在Thread对象初始化的时候完成的，即上面的静态代码块内调用的 <strong>registerNatives();</strong> 。当该类被加载到 JVM 中的时候，它就会被调用，进而注册相应的本地方法。</p>
<p>而本地方法 <strong>registerNatives</strong> 是定义在 Thread.c 文件中的。Thread.c 是个很小的文件，它定义了各个操作系统平台都要用到的关于线程的公用数据和操作，如下：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// openJdk-10版本  THread.c</span></span><br><span class="line"><span class="keyword">static</span> JNINativeMethod methods[] = &#123;</span><br><span class="line">    &#123;<span class="string">"start0"</span>,           <span class="string">"()V"</span>,        (<span class="keyword">void</span> *)&amp;JVM_StartThread&#125;, <span class="comment">//java start0</span></span><br><span class="line">    &#123;<span class="string">"stop0"</span>,            <span class="string">"("</span> OBJ <span class="string">")V"</span>, (<span class="keyword">void</span> *)&amp;JVM_StopThread&#125;,</span><br><span class="line">    &#123;<span class="string">"isAlive"</span>,          <span class="string">"()Z"</span>,        (<span class="keyword">void</span> *)&amp;JVM_IsThreadAlive&#125;,</span><br><span class="line">    &#123;<span class="string">"suspend0"</span>,         <span class="string">"()V"</span>,        (<span class="keyword">void</span> *)&amp;JVM_SuspendThread&#125;,</span><br><span class="line">    &#123;<span class="string">"resume0"</span>,          <span class="string">"()V"</span>,        (<span class="keyword">void</span> *)&amp;JVM_ResumeThread&#125;,</span><br><span class="line">    &#123;<span class="string">"setPriority0"</span>,     <span class="string">"(I)V"</span>,       (<span class="keyword">void</span> *)&amp;JVM_SetThreadPriority&#125;,</span><br><span class="line">    &#123;<span class="string">"yield"</span>,            <span class="string">"()V"</span>,        (<span class="keyword">void</span> *)&amp;JVM_Yield&#125;,</span><br><span class="line">    &#123;<span class="string">"sleep"</span>,            <span class="string">"(J)V"</span>,       (<span class="keyword">void</span> *)&amp;JVM_Sleep&#125;,</span><br><span class="line">    &#123;<span class="string">"currentThread"</span>,    <span class="string">"()"</span> THD,     (<span class="keyword">void</span> *)&amp;JVM_CurrentThread&#125;,</span><br><span class="line">    &#123;<span class="string">"countStackFrames"</span>, <span class="string">"()I"</span>,        (<span class="keyword">void</span> *)&amp;JVM_CountStackFrames&#125;,</span><br><span class="line">    &#123;<span class="string">"interrupt0"</span>,       <span class="string">"()V"</span>,        (<span class="keyword">void</span> *)&amp;JVM_Interrupt&#125;,</span><br><span class="line">    &#123;<span class="string">"isInterrupted"</span>,    <span class="string">"(Z)Z"</span>,       (<span class="keyword">void</span> *)&amp;JVM_IsInterrupted&#125;,</span><br><span class="line">    &#123;<span class="string">"holdsLock"</span>,        <span class="string">"("</span> OBJ <span class="string">")Z"</span>, (<span class="keyword">void</span> *)&amp;JVM_HoldsLock&#125;,</span><br><span class="line">    &#123;<span class="string">"getThreads"</span>,        <span class="string">"()["</span> THD,   (<span class="keyword">void</span> *)&amp;JVM_GetAllThreads&#125;,</span><br><span class="line">    &#123;<span class="string">"dumpThreads"</span>,      <span class="string">"(["</span> THD <span class="string">")[["</span> STE, (<span class="keyword">void</span> *)&amp;JVM_DumpThreads&#125;,</span><br><span class="line">    &#123;<span class="string">"setNativeName"</span>,    <span class="string">"("</span> STR <span class="string">")V"</span>, (<span class="keyword">void</span> *)&amp;JVM_SetNativeThreadName&#125;,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">undef</span> THD</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">undef</span> OBJ</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">undef</span> STE</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">undef</span> STR</span></span><br><span class="line"></span><br><span class="line">JNIEXPORT <span class="keyword">void</span> JNICALL</span><br><span class="line">Java_java_lang_Thread_registerNatives(JNIEnv *env, jclass cls)</span><br><span class="line">&#123;</span><br><span class="line">    (*env)-&gt;RegisterNatives(env, cls, methods, ARRAY_LENGTH(methods));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>下面就要找具体是怎么调用的 <strong>Thread.run()</strong> 方法，在 jvm.cpp 中有如下代码：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// hotSpot-10版本  jvm.cpp</span></span><br><span class="line">JVM_ENTRY(<span class="keyword">void</span>, JVM_StartThread(JNIEnv* env, jobject jthread))</span><br><span class="line">  JVMWrapper(<span class="string">"JVM_StartThread"</span>);</span><br><span class="line">  JavaThread *native_thread = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">bool</span> throw_illegal_thread_state = <span class="literal">false</span>;</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="function">MutexLocker <span class="title">mu</span><span class="params">(Threads_lock)</span></span>;</span><br><span class="line">    <span class="keyword">if</span> (java_lang_Thread::thread(JNIHandles::resolve_non_null(jthread)) != <span class="literal">NULL</span>) &#123;</span><br><span class="line">      throw_illegal_thread_state = <span class="literal">true</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      jlong size =</span><br><span class="line">             java_lang_Thread::stackSize(JNIHandles::resolve_non_null(jthread));</span><br><span class="line">      </span><br><span class="line">      NOT_LP64(<span class="keyword">if</span> (size &gt; SIZE_MAX) size = SIZE_MAX;)</span><br><span class="line">      <span class="keyword">size_t</span> sz = size &gt; <span class="number">0</span> ? (<span class="keyword">size_t</span>) size : <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//主要看这里</span></span><br><span class="line">      native_thread = <span class="keyword">new</span> JavaThread(&amp;thread_entry, sz);</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (native_thread-&gt;osthread() != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        </span><br><span class="line">        native_thread-&gt;prepare(jthread);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></p>
<p>这里JVM_ENTRY是一个宏，用来定义JVM_StartThread 函数，可以看到函数内创建了真正的平台相关的本地线程，其线程函数是<strong>thread_entry</strong>，如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// hotSpot-10版本  jvm.cpp</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">thread_entry</span><span class="params">(JavaThread* thread, TRAPS)</span> </span>&#123;</span><br><span class="line">    <span class="function">HandleMark <span class="title">hm</span><span class="params">(THREAD)</span></span>;</span><br><span class="line">    <span class="function">Handle <span class="title">obj</span><span class="params">(THREAD, thread-&gt;threadObj()</span>)</span>;</span><br><span class="line">    <span class="function">JavaValue <span class="title">result</span><span class="params">(T_VOID)</span></span>;</span><br><span class="line">    JavaCalls::call_virtual(&amp;result,obj,</span><br><span class="line">    KlassHandle(THREAD,SystemDictionary::Thread_klass()),</span><br><span class="line">    vmSymbolHandles::run_method_name(),    <span class="comment">//看这里</span></span><br><span class="line">    vmSymbolHandles::void_method_signature(),THREAD);</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line">class vmSymbolHandles: AllStatic &#123;</span><br><span class="line">   ...</span><br><span class="line">    template(run_method_name,<span class="string">"run"</span>)  <span class="comment">//这里!!! 这里决定了调用的方法名称是 “run”!</span></span><br><span class="line">   ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>自此调用流程就清晰了：<br><img src="/image/java/多线程/Thread-JVM运行机制.png" alt="Thread-JVM运行机制.png"> </p>
<h4 id="4-4-3、执行-run方法-——成功结果set"><a href="#4-4-3、执行-run方法-——成功结果set" class="headerlink" title="4.4.3、执行(run方法)——成功结果set()"></a>4.4.3、执行(run方法)——成功结果set()</h4><p>老规矩，首先看源码：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// FutureTask.java</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(V v)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (STATE.compareAndSet(<span class="keyword">this</span>, NEW, COMPLETING)) &#123;</span><br><span class="line">        outcome = v;</span><br><span class="line">        STATE.setRelease(<span class="keyword">this</span>, NORMAL); <span class="comment">// final state</span></span><br><span class="line">        finishCompletion();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>该方法的调用只有通过 <strong>FutureTask.run()</strong> 方法才可以被调用，而 run 方法本身能执行到此处也是不会存在多线程的情况，因为能进行的前置要求存在 <strong>CAS操作修改状态</strong> 的步骤，由此分析其代码逻辑及含义：</p>
<ol>
<li>状态校验<br>其校验操作位<strong>CAS修改NEW状态为COMPLETING</strong>，所以只有状态为 <strong>NEW</strong> 的任务才可以进入其操作逻辑。这么做的意义在于执行<strong>run</strong> 方法逻辑时可能存在<strong>cancel</strong> 方法被调用，所以需要CAS操作来保证任务的状态为 NEW 才可以进入结果集设置的操作。</li>
<li>设置结果集<br>根据执行结果即 <strong>set的入参：V</strong> 设置返回结果集。</li>
<li>修改状态<br>将任务状态设置为 <strong>NORMAL</strong>，表示任务正常结束。此处对应的状态变化为：<strong>NEW -&gt; COMPLETING -&gt; NORMAL。</strong> </li>
<li>唤醒阻塞进程<br>调用任务执行完成方法，此时会唤醒阻塞的线程，调用done()方法和清空等待线程链表等。具体阻塞的进程的来源，上面聊队列的时候分析过具体的原因和情况。</li>
</ol>
<h4 id="4-4-4、执行-run方法-——异常结果setException"><a href="#4-4-4、执行-run方法-——异常结果setException" class="headerlink" title="4.4.4、执行(run方法)——异常结果setException()"></a>4.4.4、执行(run方法)——异常结果setException()</h4><p>先上源码：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// FutureTask.java</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">setException</span><span class="params">(Throwable t)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (STATE.compareAndSet(<span class="keyword">this</span>, NEW, COMPLETING)) &#123;</span><br><span class="line">        outcome = t;</span><br><span class="line">        STATE.setRelease(<span class="keyword">this</span>, EXCEPTIONAL); <span class="comment">// final state</span></span><br><span class="line">        finishCompletion();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>可以看到 <strong>setException</strong> 内的逻辑与 <strong>set</strong> 基本一致，区别在于返回结果此处是将异常设置进去，终态设置为 <strong>EXCEPTIONAL</strong> ，其它无区别。此处状态转换为： <strong>NEW -&gt; COMPLETING -&gt; EXCEPTIONAL。</strong></p>
<h4 id="4-4-5、执行-run方法-——finishCompletion"><a href="#4-4-5、执行-run方法-——finishCompletion" class="headerlink" title="4.4.5、执行(run方法)——finishCompletion()"></a>4.4.5、执行(run方法)——finishCompletion()</h4><p>先上源码：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// FutureTask.java</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">finishCompletion</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// assert state &gt; COMPLETING;</span></span><br><span class="line">    <span class="comment">// 根据 get 方法阻塞的队列，进行唤醒、移除等操作，若是get方法未被调用，则不进入循环</span></span><br><span class="line">    <span class="keyword">for</span> (WaitNode q; (q = waiters) != <span class="keyword">null</span>;) &#123;</span><br><span class="line">        <span class="keyword">if</span> (WAITERS.weakCompareAndSet(<span class="keyword">this</span>, q, <span class="keyword">null</span>)) &#123;</span><br><span class="line">            <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">                Thread t = q.thread;</span><br><span class="line">                <span class="keyword">if</span> (t != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    q.thread = <span class="keyword">null</span>;</span><br><span class="line">                    <span class="comment">// 唤醒线程</span></span><br><span class="line">                    LockSupport.unpark(t);</span><br><span class="line">                &#125;</span><br><span class="line">                WaitNode next = q.next;</span><br><span class="line">                <span class="keyword">if</span> (next == <span class="keyword">null</span>)</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                q.next = <span class="keyword">null</span>; <span class="comment">// unlink to help gc</span></span><br><span class="line">                q = next;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 无论有无阻塞队列，都调用done()，FutureTask内done()无任务实现内容。</span></span><br><span class="line">    done();</span><br><span class="line">    <span class="comment">// 任务已执行完毕，已将结果存储至outcome中，因此将callable属性置为空</span></span><br><span class="line">    callable = <span class="keyword">null</span>;        <span class="comment">// to reduce footprint</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>此处主要是针对 <strong>waiters</strong> 内被阻塞的线程队列，针对阻塞的线程进行唤醒、移除等操作。由于FutureTask中的队列本质上是一个Treiber栈，因此操作的顺序是 <strong>后进先出</strong> 即后面先来的线程先被先操作。  </p>
<h4 id="4-4-6、执行-run方法-——执行完成共有操作handlePossibleCancellationInterrupt"><a href="#4-4-6、执行-run方法-——执行完成共有操作handlePossibleCancellationInterrupt" class="headerlink" title="4.4.6、执行(run方法)——执行完成共有操作handlePossibleCancellationInterrupt()"></a>4.4.6、执行(run方法)——执行完成共有操作handlePossibleCancellationInterrupt()</h4><p>先上源码：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">handlePossibleCancellationInterrupt</span><span class="params">(<span class="keyword">int</span> s)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (s == INTERRUPTING)</span><br><span class="line">        <span class="keyword">while</span> (state == INTERRUPTING)</span><br><span class="line">            Thread.yield(); <span class="comment">// wait out pending interrupt</span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p>
<p>可见该方法是一个自旋操作，如果当前的state状态是 <strong>INTERRUPTING</strong>，我们在原地自旋，直到 <strong>state</strong> 状态转换成终止态。意义在于：检查是否有遗漏的中断，如果有，等待中断状态完成。具体 <strong>handlePossibleCancellationInterrupt</strong> 为什么在任务执行完毕后调用，等聊到 <strong>cancel()</strong> 方法再详细分析。</p>
<h3 id="4-5、源码分析——获取执行结果"><a href="#4-5、源码分析——获取执行结果" class="headerlink" title="4.5、源码分析——获取执行结果"></a>4.5、源码分析——获取执行结果</h3><h4 id="4-5-1、获取执行结果——get"><a href="#4-5-1、获取执行结果——get" class="headerlink" title="4.5.1、获取执行结果——get()"></a>4.5.1、获取执行结果——get()</h4><p>先上源码：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">get</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException, ExecutionException </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> s = state;</span><br><span class="line">        <span class="keyword">if</span> (s &lt;= COMPLETING)</span><br><span class="line">            s = awaitDone(<span class="keyword">false</span>, <span class="number">0L</span>);</span><br><span class="line">        <span class="keyword">return</span> report(s);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@throws</span> CancellationException &#123;<span class="doctag">@inheritDoc</span>&#125;</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">get</span><span class="params">(<span class="keyword">long</span> timeout, TimeUnit unit)</span></span></span><br><span class="line"><span class="function">    <span class="keyword">throws</span> InterruptedException, ExecutionException, TimeoutException </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (unit == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">    <span class="keyword">int</span> s = state;</span><br><span class="line">    <span class="keyword">if</span> (s &lt;= COMPLETING &amp;&amp;</span><br><span class="line">        (s = awaitDone(<span class="keyword">true</span>, unit.toNanos(timeout))) &lt;= COMPLETING)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> TimeoutException();</span><br><span class="line">    <span class="keyword">return</span> report(s);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>由源码可知，获取执行结果有两个方法：</p>
<ul>
<li><strong>get()</strong>：获取执行结果，如果未执行完毕，则阻塞等待。</li>
<li><strong>get(long timeout, TimeUnit unit)</strong>：获取执行结果，并设置超时时间，如果未超时则阻塞等待，如果已超时则 <strong>移除当前阻塞线程</strong> 并 <strong>直接返回当前执行状态</strong><br>除了后者存在超时时间设置外，其他执行逻辑并无区别，主要阻塞获取执行结果的方法都是 <strong>awaitDone</strong> 下面详细分析下此方法。</li>
</ul>
<h4 id="4-5-2、获取执行结果——awaitDone"><a href="#4-5-2、获取执行结果——awaitDone" class="headerlink" title="4.5.2、获取执行结果——awaitDone()"></a>4.5.2、获取执行结果——awaitDone()</h4><p>先上源码：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">awaitDone</span><span class="params">(<span class="keyword">boolean</span> timed, <span class="keyword">long</span> nanos)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//超时相关设置</span></span><br><span class="line">    <span class="keyword">long</span> startTime = <span class="number">0L</span>;</span><br><span class="line">    <span class="comment">// 线程链表头节点</span></span><br><span class="line">    WaitNode q = <span class="keyword">null</span>;</span><br><span class="line">    <span class="comment">//是否已入阻塞队列</span></span><br><span class="line">    <span class="keyword">boolean</span> queued = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="comment">// 【1-4】状态校验，如果已执行完毕，且当前队列节点不为空则将队列当前线程置为空后返回状态。如果当前队列节点为空则直接返回状态</span></span><br><span class="line">        <span class="keyword">int</span> s = state;</span><br><span class="line">        <span class="keyword">if</span> (s &gt; COMPLETING) &#123;</span><br><span class="line">            <span class="keyword">if</span> (q != <span class="keyword">null</span>)</span><br><span class="line">                q.thread = <span class="keyword">null</span>;</span><br><span class="line">            <span class="keyword">return</span> s;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 状态为COMPLETING则说明正在设置结果集，当前线程让出CPU时间片段，等待设置结果集完毕</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (s == COMPLETING)</span><br><span class="line">            Thread.yield();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 【3-1】当前执行线程被中断，则移除队列节点，抛出中断异常</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (Thread.interrupted()) &#123;</span><br><span class="line">            removeWaiter(q);</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> InterruptedException();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 【1-1】当前线程还未进入阻塞队列，则创建包含当前线程信息的队列节点。</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (q == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (timed &amp;&amp; nanos &lt;= <span class="number">0L</span>)</span><br><span class="line">                <span class="keyword">return</span> s;</span><br><span class="line">            q = <span class="keyword">new</span> WaitNode();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 【1-2】如果当前队列节点未入阻塞队列，则加入队列头部</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (!queued)</span><br><span class="line">            queued = WAITERS.weakCompareAndSet(<span class="keyword">this</span>, q.next = waiters, q);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 【2-1】若有超时设置，那么处理超时获取任务结果的逻辑</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (timed) &#123;</span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">long</span> parkNanos;</span><br><span class="line">            <span class="keyword">if</span> (startTime == <span class="number">0L</span>) &#123; <span class="comment">// first time</span></span><br><span class="line">                startTime = System.nanoTime();</span><br><span class="line">                <span class="keyword">if</span> (startTime == <span class="number">0L</span>)</span><br><span class="line">                    startTime = <span class="number">1L</span>;</span><br><span class="line">                parkNanos = nanos;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">long</span> elapsed = System.nanoTime() - startTime;</span><br><span class="line">                <span class="keyword">if</span> (elapsed &gt;= nanos) &#123;</span><br><span class="line">                    removeWaiter(q);</span><br><span class="line">                    <span class="keyword">return</span> state;</span><br><span class="line">                &#125;</span><br><span class="line">                parkNanos = nanos - elapsed;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// nanoTime may be slow; recheck before parking</span></span><br><span class="line">            <span class="keyword">if</span> (state &lt; COMPLETING)</span><br><span class="line">                LockSupport.parkNanos(<span class="keyword">this</span>, parkNanos);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 【1-3】阻塞当前线程</span></span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            LockSupport.park(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>获取结果集的自旋循环处理逻辑，存在多个分支处理，每个分支的校验条件和操作逻辑均已在注释中描述，那么下面就看下每次循环都会执行哪些分支，同时进一步了解为什么每个分支的逻辑如此设计。</p>
<p><strong>情况 1：1、任务状态为NEW；2、无超时时间设置时，3、不存在中断操做时。循环内的情况</strong>：</p>
<ol>
<li>第一次循环：<br>此时 <strong>q=null</strong>，进入队列节点创建操作，即：【1-1】，操作完此次循环结束。此时队列节点已创建，但尚未放入阻塞队列内。</li>
<li>第二次循环：<br>此时  <strong>queued=false</strong>，进入将当前节点放入阻塞队列操作，即【1-2】，操作完此次循环结束。</li>
<li>第三次循环<br>当前队列节点已创建且已放入阻塞队列，此时进入阻塞阶段，即【1-3】，操作完成循环结束。</li>
<li>第四次循环<br>此时任务已执行完毕，阻塞线程被激活，进入结果集获取操作，即【1-4】，<strong>awaitDone</strong> 方法执行完毕，返回异步任务结果集。</li>
</ol>
<p><strong>情况 2：1、任务状态为NEW；2、存在超时时间设置时，3、不存在中断操做时。循环内的情况</strong>：<br>则在【1-3】和【1-4】中间加入【2-1】超时判断操作。其它同 <strong>情况1</strong>。</p>
<p><strong>情况 3：1、任务状态为NEW；2、无超时时间设置时，3、存在中断操做时。循环内情况：</strong><br>直接进入中断操作，移除当前队列节点，抛出异常即【3-1】。任务执行和任务取消都调用 <strong>finishCompletion()</strong> 方法，那么此处调用的意义在哪？此处调用意义：执行 <strong>awaitDone</strong> 时存在一种情况，即刚进行队列节点创建但还未将队列节点放入阻塞队列即【第一次循环】时。此时进行任务中断则队列节点无法在 <strong>finishCompletion()</strong> 中移除，所以需要在此处进行置空操作，方便GC回收。</p>
<p><strong>情况 4：1、任务状态为不为NEW。循环内情况：</strong><br>直接返回当前任务状态，存在当前队列节点则移除当前队列节点即【1-4】。原因类似 <strong>情况2</strong>，只不过中断操作变为任务完成。</p>
<h4 id="4-5-3、获取执行结果——report"><a href="#4-5-3、获取执行结果——report" class="headerlink" title="4.5.3、获取执行结果——report()"></a>4.5.3、获取执行结果——report()</h4><p>先上源码：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> V <span class="title">report</span><span class="params">(<span class="keyword">int</span> s)</span> <span class="keyword">throws</span> ExecutionException </span>&#123;</span><br><span class="line">    Object x = outcome;</span><br><span class="line">    <span class="keyword">if</span> (s == NORMAL)</span><br><span class="line">        <span class="keyword">return</span> (V)x;</span><br><span class="line">    <span class="keyword">if</span> (s &gt;= CANCELLED)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> CancellationException();</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> ExecutionException((Throwable)x);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>根据状态获取结果集就很简单了，一共三个分支：</p>
<ol>
<li>状态为 <strong>NORMAL</strong>：即正常执行完成，返回 <strong>Callable.call()</strong> 方法执行结果即可。</li>
<li>状态 <strong>s &gt;= CANCELLED</strong>，说明存在取消情况，则抛出中断异常。</li>
<li>其它状态为执行过程存在异常，则将异常类返回即可。</li>
</ol>
<h3 id="4-6、源码分析——取消任务"><a href="#4-6、源码分析——取消任务" class="headerlink" title="4.6、源码分析——取消任务"></a>4.6、源码分析——取消任务</h3><p>线上源码：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">cancel</span><span class="params">(<span class="keyword">boolean</span> mayInterruptIfRunning)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 任务状态为NEW且根据mayInterruptIfRunning参数修改状态为INTERRUPTING或CANCELLED，二者任一</span></span><br><span class="line">    <span class="comment">// 失败或同时失败均返回 False</span></span><br><span class="line">    <span class="keyword">if</span> (!(state == NEW &amp;&amp; STATE.compareAndSet</span><br><span class="line">            (<span class="keyword">this</span>, NEW, mayInterruptIfRunning ? INTERRUPTING : CANCELLED)))</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;    </span><br><span class="line">        <span class="comment">// 如果mayInterruptIfRunning=true，则获取当前任务执行线程，进行中断操作</span></span><br><span class="line">        <span class="keyword">if</span> (mayInterruptIfRunning) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread t = runner;</span><br><span class="line">                <span class="keyword">if</span> (t != <span class="keyword">null</span>)</span><br><span class="line">                    t.interrupt();</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123; <span class="comment">// final state</span></span><br><span class="line">                <span class="comment">// 最后任务状态赋值为INTERRUPTED</span></span><br><span class="line">                STATE.setRelease(<span class="keyword">this</span>, INTERRUPTED);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="comment">// 针对阻塞进程进行唤醒、移除等操作</span></span><br><span class="line">        finishCompletion();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>由源码可知：</p>
<ol>
<li>状态校验：<ul>
<li>状态不为NEW，直接返回false</li>
<li>状态为NEW，根据参数 <strong>mayInterruptIfRunning</strong> 不同值，进行不同的状态修改，此处修改为CAS操作，修改失败则返回false。成功则继续执行取消操作。</li>
</ul>
</li>
<li><p>根据 mayInterruptIfRunning 不同值进行操作：</p>
<ul>
<li>为flase：跳过 <strong>try</strong> 代码块，直接执行 <strong>finally</strong> 操作。此时状态变化为：<strong>NEW -&gt; CANCELLED。</strong></li>
<li>为true：则 <strong>runner==null</strong>，因为可能存在此时任务已经执行完成，将 runner 置为空了。如果不为空，则发送线程中断信号，发送中中断信号并不代表一定会真正的中断线程。此时状态变化为：<strong>NEW -&gt; INTERRUPTING -&gt; INTERRUPTED</strong>。</li>
</ul>
</li>
<li><p>唤醒阻塞线程<br>无论 <strong>mayInterruptIfRunning</strong> 参数为何值，最终都会唤醒阻塞的线程，即调用 <strong>finishCompletion</strong> 方法，因为此时任务已经是终态了。 <strong>cancel()</strong> 方法返回true。<br>如果<strong>cancel()</strong> 返回true了，那么线程无论最终是否执行，<strong>get()</strong> 方法都会抛出<strong>CancellationException</strong>异常，因为 <strong>report(int s)</strong> 内会校验 <strong>s &gt;= CANCELLED</strong>，具体可看上一节的 <strong>report()</strong>源码。</p>
</li>
</ol>
<h3 id><a href="#" class="headerlink" title=" "></a> </h3><h3 id="4-7、源码分析——移除任务"><a href="#4-7、源码分析——移除任务" class="headerlink" title="4.7、源码分析——移除任务"></a>4.7、源码分析——移除任务</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">removeWaiter</span><span class="params">(WaitNode node)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (node != <span class="keyword">null</span>) &#123;</span><br><span class="line">        node.thread = <span class="keyword">null</span>;</span><br><span class="line">        retry:</span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;          <span class="comment">// restart on removeWaiter race</span></span><br><span class="line">            <span class="keyword">for</span> (WaitNode pred = <span class="keyword">null</span>, q = waiters, s; q != <span class="keyword">null</span>; q = s) &#123;</span><br><span class="line">                s = q.next;</span><br><span class="line">                <span class="keyword">if</span> (q.thread != <span class="keyword">null</span>)</span><br><span class="line">                    pred = q;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (pred != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    pred.next = s;</span><br><span class="line">                    <span class="keyword">if</span> (pred.thread == <span class="keyword">null</span>) <span class="comment">// check for race</span></span><br><span class="line">                        <span class="keyword">continue</span> retry;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (!WAITERS.compareAndSet(<span class="keyword">this</span>, q, s))</span><br><span class="line">                    <span class="keyword">continue</span> retry;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>移除指定节点，该方法仅在 <strong>awaitDone</strong> 方法内 <strong>等待执行结果超时</strong> 和 <strong>遇到线程中断</strong> 时调用。</p>
<h2 id="五、总结"><a href="#五、总结" class="headerlink" title="五、总结"></a>五、总结</h2><p>至此 <strong>FutureTask</strong> 体系相关的逻辑已经分析完毕。直接使用就只关心三块内容即可：</p>
<ol>
<li>Callable实现想要做的业务逻辑，</li>
<li>构建FutureTask类。</li>
<li>使用 Thread或ExecutorService来执行，并在执行后阻塞获取执行结果。</li>
</ol>
<p><strong>Callable</strong>也可直接执行，但只能通过 <strong>ExecutorService.submit</strong> 方法来执行，但内部实际上还是转换为FutureTask来执行，FutureTask则既可以 <strong>ExecutorService.submit</strong> 来执行，也可以直接使用 <strong>Thread</strong> 来直接执行，因为它既实现 <strong>Runnable</strong> 又实现了 <strong>Future</strong> 。</p>
<p><strong>FutureTask</strong> 内部则关系主要是 <strong>runner,waiters和state</strong> 这三个属性的定义概念和执行逻辑理清晰差不多也就把<strong>FutureTask</strong> 理解透彻了。</p>
<p>至此 <strong>future体系</strong> 算是分析完毕了。</p>
<p>参考：<br><a href="https://juejin.cn/post/6844903774985650183" target="_blank" rel="noopener">https://juejin.cn/post/6844903774985650183</a><br><a href="https://segmentfault.com/a/1190000015739343" target="_blank" rel="noopener">https://segmentfault.com/a/1190000015739343</a></p>

          
        
      
    </div>

    
    
    
      <footer class="post-footer">
          <div class="post-eof"></div>
        
      </footer>
  </div>
  
  
  
  </article>

    
      

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="cmeng001.github.io/2020/08/17/algorithm/back_tracking/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="cmeng">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="c萌怪谈">
    </span>
      <header class="post-header">

        
          <h1 class="post-title" itemprop="name headline">
              
              <a href="/2020/08/17/algorithm/back_tracking/" class="post-title-link" itemprop="url">回溯</a>
            
          </h1>
        

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              
                
              

              <time title="创建时间：2020-08-17 16:13:12" itemprop="dateCreated datePublished" datetime="2020-08-17T16:13:12+08:00">2020-08-17</time>
            </span>
          
            

            
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-04-18 09:21:09" itemprop="dateModified" datetime="2022-04-18T09:21:09+08:00">2022-04-18</time>
              </span>
            
          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/算法/" itemprop="url" rel="index"><span itemprop="name">算法</span></a></span>

                
                
              
            </span>
          

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          
            <h2 id="回溯"><a href="#回溯" class="headerlink" title="回溯"></a>回溯</h2><h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a><strong>概述</strong></h3><p><strong>回溯法</strong>（英语：backtracking）是暴力搜索法中的一种。<br>对于某些计算问题而言，回溯法是一种可以找出所有（或一部分）解的一般性算法，尤其适用于约束满足问题（在解决约束满足问题时，我们逐步构造更多的候选解，并且在确定某一部分候选解不可能补全成正确解之后放弃继续搜索这个部分候选解本身及其可以拓展出的子候选解，转而测试其他的部分候选解）。  </p>
<p>回溯算法又称 <font color="#0099ff">试探法</font>，采用试错的思想。在分步解决问题的过程中，当它通过尝试发现，现有的分步答案不能得到有效的正确的解答的时候，它将取消上一步甚至是上几步的计算，再通过其它的可能的分步解答再次尝试寻找问题的答案。回溯法通常用最简单的递归方法来实现，在反复重复上述的步骤后可能出现两种情况：</p>
<ul>
<li>找到一个可能存在的正确的答案</li>
<li>在尝试了所有可能的分步方法后宣告该问题没有答案  </li>
</ul>
<p>在最坏的情况下，回溯法会导致一次复杂度为指数时间的计算。</p>
<p><strong>例如:</strong><br>在统计1~N中整数的所有子集问题时，就可以使用 <font color="#0099ff">回溯法</font> 进行处理。从1开始每个数字都有两种可能，存在子集或不存在子集，每种可能都会有一种结果，那么问题的结果就是所有可能的子集的集合。</p>
<h3 id="实例"><a href="#实例" class="headerlink" title="实例"></a><strong>实例</strong></h3><p><strong>1. 实例1</strong><br><a href="https://leetcode-cn.com/problems/subsets/" target="_blank" rel="noopener"></a></p>

          
        
      
    </div>

    
    
    
      <footer class="post-footer">
          <div class="post-eof"></div>
        
      </footer>
  </div>
  
  
  
  </article>

    
      

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="cmeng001.github.io/2020/08/17/algorithm/时间复杂度/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="cmeng">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="c萌怪谈">
    </span>
      <header class="post-header">

        
          <h1 class="post-title" itemprop="name headline">
              
              <a href="/2020/08/17/algorithm/时间复杂度/" class="post-title-link" itemprop="url">算法-时间复杂度</a>
            
          </h1>
        

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              
                
              

              <time title="创建时间：2020-08-17 16:13:12" itemprop="dateCreated datePublished" datetime="2020-08-17T16:13:12+08:00">2020-08-17</time>
            </span>
          
            

            
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-08-18 17:00:25" itemprop="dateModified" datetime="2020-08-18T17:00:25+08:00">2020-08-18</time>
              </span>
            
          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/算法/" itemprop="url" rel="index"><span itemprop="name">算法</span></a></span>

                
                
              
            </span>
          

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          
            <h2 id="算法-时间复杂度"><a href="#算法-时间复杂度" class="headerlink" title="算法-时间复杂度"></a>算法-时间复杂度</h2><h3 id="1、数据结构-算法"><a href="#1、数据结构-算法" class="headerlink" title="1、数据结构-算法"></a>1、数据结构-算法</h3><p>数据结构和算法是相辅相成的，<strong>数据结构是为算法服务的，算法要作用在特定的数据结构之上</strong>。所以二者的学习不能互相孤立。</p>
<h3 id="2、算法复杂度分析"><a href="#2、算法复杂度分析" class="headerlink" title="2、算法复杂度分析"></a>2、算法复杂度分析</h3><ol>
<li>时间复杂度： 指算法需要消耗的时间资源。计算机算法是问题规模n 的函数f(n)，算法的时间复杂度也因此记做。<br>T(n)=Ο(f(n))</li>
<li>空间复杂度：算法需要消耗的空间资源。其计算和表示方法与时间复杂度类似，一般都用复杂度的渐近性来表示。同时间复杂度相比，空间复杂度的分析要简单得多。</li>
</ol>
<h4 id="2-1、事后统计法"><a href="#2-1、事后统计法" class="headerlink" title="2.1、事后统计法"></a>2.1、事后统计法</h4><p>事后统计法：通过统计、分析等，计算出算法的实际执行时间和实际内存占用，从而得到算法的时间复杂度。</p>
<ul>
<li>测试结果非常依赖测试环境。（服务器资源配置）</li>
<li>测试结果受限于数据规模</li>
</ul>
<h4 id="2-2、大O复杂度表示法"><a href="#2-2、大O复杂度表示法" class="headerlink" title="2.2、大O复杂度表示法"></a>2.2、大O复杂度表示法</h4><p>时间复杂度通俗来讲，就是代码运行的时间。大O表示法就是在不运算代码的情况下来分析一段代码的时间复杂度。<br>看下面的例子：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">calculate</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> (;i&lt;n;++i)&#123;</span><br><span class="line">    sum = sum + i;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>从CPU的角度来看，代码的每一行都执行着类似的操作：<strong>读操作-运算-写操作</strong>。这里我们假设每行代码的执行时间一样，为unit_time，那么2，3行执行了1个unit_time，3，4行n个unit_time，总的执行时间就是（2n+2）*unit_time。<br>按照这个思路再来看下面一段代码：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">cal</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">int</span> j = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> (;i&lt;n;i++)&#123;</span><br><span class="line">    j = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (;j&lt;=n;j++)&#123;</span><br><span class="line">      sum += sum + i * j;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>依旧假设单位时间为unit_time，2、3、4行执行时间分别为1unti_time，5、6加起来就是2n。7、8加起来就是2n²unit_time;总的时间就为(2n²+2n+3)unit_time.<br>这两段代码分析我们可得到一个重要的规律，那就是<strong>代码的执行时间T(n)和每段代码的执次数成正比</strong>，所以就得到了以下公式：</p>
<blockquote>
<font color="orange">T(n)=O(f(n))</font>

</blockquote>
<p>其中T(n)代表了代码的执行时间，n代表数据规模，f(n)代表每行代码执行的次数总和。因为是公式，所以用f(n)表达。公式中的O则表示代码执行时间T(n)和表达式f(n)成正比。   </p>
<p>两个例子中的T(n)=O(2n+2)和T(n)=O(2n²+2n+3)就是大O时间复杂度表示法，它并不代表具体的执行时间，而是代表<strong>代码的执行时间随着数据规模增加的变化趋势</strong>，所以也叫渐进时间复杂度（asymptotic time complexity），简称时间复杂度。  </p>
<p>当n很大时，表达式中的低阶、常量、系数等部分并不左右增长趋势，所以大O表示法可记为：T(n)=O(n)、T(n)=O(n²)。</p>
<h4 id="2-3-常见复杂度分析方法"><a href="#2-3-常见复杂度分析方法" class="headerlink" title="2.3 常见复杂度分析方法"></a>2.3 常见复杂度分析方法</h4><ol>
<li><p>单段代码看高频：如循环</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">calculate</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> (;i&lt;n;++i)&#123;</span><br><span class="line">    sum = sum + i;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>多段代码取最高：如一段代码中存在单重循环和多重循环，则取多重循环。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">cal</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> temp = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">int</span> a = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> (;a&lt;n;++a)&#123;</span><br><span class="line">    temp = temp + i;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">int</span> j = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> (;i&lt;n;i++)&#123;</span><br><span class="line">    j = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (;j&lt;=n;j++)&#123;</span><br><span class="line">      sum += sum + i * j;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>嵌套循环取乘积：比如多重循环，递归等。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">cal</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">int</span> j = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> (;i&lt;n;i++)&#123;</span><br><span class="line">    j = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (;j&lt;=n;j++)&#123;</span><br><span class="line">      sum += sum + i * j;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>多数据规模取和：O(n+m)。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">cal</span><span class="params">(<span class="keyword">int</span> n,<span class="keyword">int</span> m)</span></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> temp = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">int</span> a = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> (;a&lt;n;++a)&#123;</span><br><span class="line">    temp = temp + i;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (;i&lt;m;i++)&#123;</span><br><span class="line">    sum += sum + i * j;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h4 id="2-4-常见的时间复杂度"><a href="#2-4-常见的时间复杂度" class="headerlink" title="2.4 常见的时间复杂度"></a>2.4 常见的时间复杂度</h4><p><img src="/image/algorithm/常见时间复杂度.jpg" alt="常见时间复杂度"></p>
<ol>
<li>多项式阶，随着数据规模的增长，算法的执行时间和空间占用，按照多项式的比例增长。  </li>
</ol>
<ul>
<li>O(1)（常数阶）<br>常数阶的概念并不是只执行一行代码，一般情况下算法中不存在循环、递归等语句，即使有成千上万行代码，复杂度也是O(1)</li>
<li><p>O(logn)（对数阶）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> i =<span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span>(i&lt;n)&#123;</span><br><span class="line">  i = i * <span class="number">2</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当2^x&gt;=n时，循环结束，所以这段代码的执行次数就是x= $log_2n$;大O法记作：$O(log_2n)$。那么再看下面这段代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> i =<span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span>(i&lt;n)&#123;</span><br><span class="line">  i = i * <span class="number">3</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>按照上面的逻辑，这段的复杂度为$O(log_3n)$。二者之间是可以转换的$log_3n=log_32 * log_2n$；基于大O法的理论：在采用大O计数法时可以忽略系数等。则此类复杂度可统一记为O(logn)。   </p>
</li>
<li>O(n)（线性阶）</li>
<li>O(nlogn)（线性对数阶）<br>基于O(logn)，那么O(nlogn)就容易理解了，就相当于上面的嵌套取乘积规则一样，就是O(logn)执行的n遍。</li>
<li>O(n^2)（平方阶）、O(n^3)（立方阶）….、O(n^k)(K次方阶)</li>
</ul>
<ol>
<li>非多项式阶：随着数据规模的增长，算法的执行时间和空间占用暴增，这类算法性能极差。</li>
</ol>
<ul>
<li>O(2^n)（指数阶）</li>
<li>O(n!)（阶乘阶）</li>
</ul>
<h3 id="3-小结"><a href="#3-小结" class="headerlink" title="3 小结"></a>3 小结</h3><p>虽然上面说的事后统计法有一定的缺点，但时间复杂度的分析与其并不是对立冲突的。时间复杂度是一个理论上的模型，可以比较直观的给我们一个算法的效率上的感性认知，只能提供粗略的分析。它是与宿主平台无关的，并不是说O(n)的效率一定就优于O(n²)。针对不同的宿主平台环境，不同的数据集，不同的数据规模，在实际应用上性能可能会各有不同，所以实际应用中进行一定的性能基准测试是有必要的。<br>综上所述，时间复杂度分析和性能测试是相辅相成的。但一个低阶的时间复杂度确实有极大的可能优于高阶的时间复杂度，所以在编程中时刻关心复杂度的趋势走向是很有必要的，而且能很大幅度的提升输出质量。因此在编程中具有这种复杂度分析的思维还是十分有必要的。</p>

          
        
      
    </div>

    
    
    
      <footer class="post-footer">
          <div class="post-eof"></div>
        
      </footer>
  </div>
  
  
  
  </article>

    
  </section>

  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>


          </div>
          

        </div>
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      <div class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">

          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image"
      src="/images/avatar.jpg"
      alt="cmeng">
  <p class="site-author-name" itemprop="name">cmeng</p>
  <div class="site-description motion-element" itemprop="description"></div>
</div>
  <nav class="site-state motion-element">
      <div class="site-state-item site-state-posts">
        
          <a href="/archives/">
        
          <span class="site-state-item-count">20</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
    
      
      
      <div class="site-state-item site-state-categories">
        
          
            <a href="/categories/">
          
        
        
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
        <span class="site-state-item-count">18</span>
        <span class="site-state-item-name">分类</span>
        </a>
      </div>
    
      
      
      <div class="site-state-item site-state-tags">
        
          
            <a href="/tags/">
          
        
        
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
        <span class="site-state-item-count">15</span>
        <span class="site-state-item-name">标签</span>
        </a>
      </div>
    
  </nav>



        </div>
      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2022</span>
  <span class="with-love" id="animate">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">cmeng</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io" class="theme-link" rel="noopener" target="_blank">Hexo</a> 强力驱动 v3.9.0</div>
  <span class="post-meta-divider">|</span>
  <div class="theme-info">主题 – <a href="https://theme-next.org" class="theme-link" rel="noopener" target="_blank">NexT.Muse</a> v7.3.0</div>

        








        
      </div>
    </footer>
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
      </div>

    

  </div>

  
  <script src="/lib/jquery/index.js?v=3.4.1"></script>
  <script src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  <script src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>

<script src="/js/utils.js?v=7.3.0"></script>
  <script src="/js/motion.js?v=7.3.0"></script>


  <script src="/js/schemes/muse.js?v=7.3.0"></script>


<script src="/js/next-boot.js?v=7.3.0"></script>




  




























  

  
    
      
        
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
  
    
      <script type="text/x-mathjax-config">

  MathJax.Hub.Config({
    tex2jax: {
      inlineMath: [ ['$', '$'], ['\\(', '\\)'] ],
      processEscapes: true,
      skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
    },
    TeX: {
      equationNumbers: {
        autoNumber: 'AMS'
      }
    }
  });

  MathJax.Hub.Register.StartupHook('TeX Jax Ready', function() {
    MathJax.InputJax.TeX.prefilterHooks.Add(function(data) {
      if (data.display) {
        var next = data.script.nextSibling;
        while (next && next.nodeName.toLowerCase() === '#text') {
          next = next.nextSibling;
        }
        if (next && next.nodeName.toLowerCase() === 'br') {
          next.parentNode.removeChild(next);
        }
      }
    });
  });

  MathJax.Hub.Queue(function() {
    var all = MathJax.Hub.getAllJax(), i;
    for (i = 0; i < all.length; i += 1) {
      element = document.getElementById(all[i].inputID + '-Frame').parentNode;
      if (element.nodeName.toLowerCase() == 'li') {
        element = element.parentNode;
      }
      element.classList.add('has-jax');
    }
  });
</script>
<script>
  NexT.utils.getScript('//cdn.jsdelivr.net/npm/mathjax@2/MathJax.js?config=TeX-AMS-MML_HTMLorMML', function() {
    MathJax.Hub.Typeset();
  }, window.MathJax);
</script>

    
  

  

  


  
</body>
</html>
