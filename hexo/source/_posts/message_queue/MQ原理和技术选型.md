---
title: MQ原理和技术选型
date: 2022-11-13 16:13:12
tags: MQ
categories: [MQ]
top: true
---

# MQ原理及选型

## 一、消息队列概念
**消息队列（英语：Message queue，简称：MQ）**：是一种进程间通信或同一进程的不同线程间的通信方式。
* 消息（Message）：是指在应用之间传送的数据，消息可以非常简单，比如只包含文本字符串，也可以更复杂，可能包含嵌入对象。
* 队列（Queue）：保持消息的容器，本质上为队列。

**基本模型**
![MQ基本模型][MQ_basic_model]

消息队列的本质很好理解，本质都是：**<font color='red'>一发、一存、一消</font>**，所有复杂模型和中间件实现都是基于这个最初原理和模型来实现的。

---

## 二、消息队列优、缺
消息队列使用三个经典的场景：异步、解耦、削峰。无论因为什么都是这三点的延伸。下面就这三个模块展开细说。

### 2.1、优-异步
消息队列的主要特点就是异步执行，以异步的方式执行非核心业务逻辑来降低 **RT（Response Time）**，提高用户体验和流畅性。

比如某个充值场景，最初可能就是个简单的充值，充值支付成功就OK。但随着迭代和推广，出现了充值返利、积分、充值赠券、充值后短信通知等等功能。这个时候同步操作就很影响响应时间了。

此时就需要考虑异步操作，将非必要的放在MQ异步完成，压缩响应时间。

![异步模型][MQ_Async_model]


### 2.2、优-解耦
还是上面充值的场景，假如不用MQ，我直接使用异步线程或者分布式情况下调用其它服务接口不一样实现异步的操作么。

其实是可以的，但弊端就是后续再有相关的流程加入到充值操作里面，就需要改代码、加调用。流程越多改的次数越多。

所以MQ的另一个特性就体现出来了：**解耦**。如果使用MQ充值成功后发布个充值成功到队列，谁需要谁就去消费，这样充值就直负责充值，其它的就不用管了。各自系统负责自己的任务就可以了。

所以MQ可实现模块、服务、接口等不同粒度上实现解耦。


### 2.3、优-削峰
削峰就比较好理解了，比如系统推广或秒杀的时候，突然**QPS**（QPS：Queries Per Second：每秒查询率）极速上涨。这个时候就得考虑服务是否能承载这么大的访问，如果超出系统负责可能直接就是崩掉了。

这个时候就可以把请求先放到MQ中，至于每秒消费多少就根据数据库、中间件以及服务本身的实际情况来判断并消费对应的消息就可以了。虽然响应慢一些，但不至于直接把服务干蹦掉。

![削峰模型][MQ_weaken_peak_model]


### 2.4、使用MQ的缺点
以上均为系统加入MQ的优点，那么有没有缺点呢？当然有了，所有东西都要辩证的来得看
* 系统复杂性：原本系统的基础上增加中间件，就要考虑其使用、维护、问题定位等问题。再加上MQ机制本身也要考虑：重复消费、消息丢失、消息的顺序消费等等问题。系统复杂性的增加不言而喻了。

* 数据一致性：比如刚刚的充值，充值操作是完成了，那返利是否完成？优惠券是否发放？短信是否已通知到位？

* 可用性：原本只需要考虑系统的健壮性就可以，现在增加了中间件MQ，那MQ挂了怎么处理？系统是否就直接宕掉了？

当然这些都是可以处理，只不过增加相应的开发、维护成本。最终是否使用MQ还是需要根据实际的系统和业务需求来考虑其使用情况

---


## 三、消息队列协议

### 3.1、
JMS：**Java 消息服务API** 是一种消息传递标准，它允许基于 Java 平台企业版 (Java EE) 的应用程序组件创建、发送、接收和读取消息。它支持松耦合、可靠和异步的分布式通信。






















[MQ_basic_model]: https://raw.githubusercontent.com/cmeng-CM/image-hosting/master/img/MQ/MQ_basic_model.jpg

[MQ_Async_model]: https://raw.githubusercontent.com/cmeng-CM/image-hosting/master/img/MQ/MQ_Async_model.jpeg

[MQ_weaken_peak_model]: https://raw.githubusercontent.com/cmeng-CM/image-hosting/master/img/MQ/MQ_weaken_peak_model.jpg





















