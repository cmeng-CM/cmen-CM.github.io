<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>IO模型</title>
      <link href="/2023/02/17/theoretical-knowledge/io-model/"/>
      <url>/2023/02/17/theoretical-knowledge/io-model/</url>
      
        <content type="html"><![CDATA[<h2 id="I-O"><a href="#I-O" class="headerlink" title="I/O"></a>I/O</h2><p><a href="https://zh.wikipedia.org/zh-cn/I/O">I/O（英语：Input/Output）</a>，即输入／输出，通常指数据在存储器（内部和外部）或其他周边设备之间的输入和输出。IO有 <strong>内存IO、网络IO和磁盘IO</strong> 三种，通常我们说的IO指的是后两者。</p>]]></content>
      
      
      <categories>
          
          <category> 理论知识 </category>
          
          <category> IO </category>
          
      </categories>
      
      
        <tags>
            
            <tag> IO,IO模型 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>用户态、内核态</title>
      <link href="/2023/02/17/theoretical-knowledge/virtual-memory/"/>
      <url>/2023/02/17/theoretical-knowledge/virtual-memory/</url>
      
        <content type="html"><![CDATA[<h2 id="一、虚拟内存定义"><a href="#一、虚拟内存定义" class="headerlink" title="一、虚拟内存定义"></a>一、虚拟内存定义</h2><p><strong>虚拟内存</strong>：在多任务系统系统中，多任务并行，大大提升了 <strong>CPU</strong> 利用率，但却引出了多个进程对内存操作冲突的问题，<strong>虚拟内存</strong> 概念的提出就是为了解决这个问题，每个进程都运行在属于自己的 <strong>虚拟内存</strong> 中。</p><p><img src="https://raw.githubusercontent.com/cmeng-CM/image-hosting/master/img/theoretical_knowledge/虚拟内存页表映射物理内存.jpg" alt="虚拟内存页表映射物理内存"></p><p>如上图，虚拟内存通过 <strong>MMU</strong> 将自己映射到物理内存上，使程序认为它拥有连续的可用的内存（一个连续完整的地址空间），而实际上，它通常是被分隔成多个 <strong>物理内存碎片</strong> 。至于具体使用的 <strong>物理内存</strong> 是哪块他们不需知道。所以保证了进程之间不会互相影响。</p><blockquote><p><a href="https://zh.wikipedia.org/wiki/%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98">维基百科定义</a></p></blockquote><hr class="dotted"><h2 id="二、虚拟内存构成"><a href="#二、虚拟内存构成" class="headerlink" title="二、虚拟内存构成"></a>二、虚拟内存构成</h2><p><strong>虚拟内存</strong> 通常会被分成 <strong>用户空间（User Space）</strong>，与 <strong>核心空间/内核空间（Kernel Space）</strong> 这两个区段。对于 32 位的操作系统，在 Linux 的虚拟地址空间中，用户空间和内核空间的大小比例为 3:1，而在 window 中则为 2:2。</p><p><img src="https://raw.githubusercontent.com/cmeng-CM/image-hosting/master/img/theoretical_knowledge/虚拟内存结构.jpg" alt="虚拟内存结构"></p><h3 id="2-1-用户空间"><a href="#2-1-用户空间" class="headerlink" title="2.1. 用户空间"></a>2.1. 用户空间</h3><p>进程能实际操作百分百权限的空间</p><ol><li>用户空间是在虚拟内存上连续的，物理内存上 <strong>不连续的，碎片状</strong>。</li><li>通过 <strong>MMU</strong> 来映射。</li></ol><h3 id="2-2、内核空间"><a href="#2-2、内核空间" class="headerlink" title="2.2、内核空间"></a>2.2、内核空间</h3><p>针对一些特权指令并不允许进程直接调用，必须由系统内核调用。因系统内核也在内存中，同时防止用户进程干扰，操作系统为内核单独划分了一块内存区域，这块区域就是内核空间。</p><ol><li><p>内核空间是在虚拟内存和物料内存上都是 <strong>连续的</strong>。</p><ul><li><strong>系统内核</strong> 在系统启动时就需要加载到 <strong>物理内存的内核空间上运行</strong>，又要保证在虚拟内存内存在内核空间，所以进程的 <strong>虚拟地址空间中的内核空间</strong> 映射到 <strong>物理内存中的内核空间</strong>上。</li><li>物理内存的内核空间唯一，所以所有进程的 <strong>虚拟内存中内核空间</strong> 都映射到了 <strong>同一块物理内存区域</strong>。</li></ul></li><li><p>通过 <strong>MMU</strong> 来映射。</p></li><li><p>分级保护域<br><img src="https://raw.githubusercontent.com/cmeng-CM/image-hosting/master/img/theoretical_knowledge/priv_rings.jpg" alt="分级保护域"></p></li></ol><p>比如 Intel 的 CPU 将特权等级分为 4 个级别：Ring0~Ring3。其实 Linux 系统只使用了 Ring0 和 Ring3 两个运行级别(Windows 系统也是一样的)。当进程运行在 Ring3 级别时被称为运行在用户态，而运行在 Ring0 级别时被称为运行在内核态。</p><blockquote><p>详见：<a href="https://zh.wikipedia.org/wiki/%E5%88%86%E7%BA%A7%E4%BF%9D%E6%8A%A4%E5%9F%9F">分级保护域</a></p></blockquote><hr class="dotted"><h2 id="三、虚拟内存存在的意义"><a href="#三、虚拟内存存在的意义" class="headerlink" title="三、虚拟内存存在的意义"></a>三、虚拟内存存在的意义</h2><ul><li>虚拟内存可以利用内存起到缓存的作用，提高进程访问磁盘的速度；</li><li>虚拟内存可以为进程提供独立的内存空间，简化程序的链接、加载过程并通过动态库 共享内存；</li><li>虚拟内存可以控制进程对物理内存的访问，隔离不同进程的访问权限，提高系统的安全性；</li></ul><hr class="dotted"><h2 id="四、用户态、内核态"><a href="#四、用户态、内核态" class="headerlink" title="四、用户态、内核态"></a>四、用户态、内核态</h2><p>通俗点讲，<strong>用户态</strong> 就是程序在用户空间运行的状态，<strong>内核态</strong> 就是系统内核在内核空间运行的状态。</p><p>其实所有涉及系统资源管理的操作都是在 <strong>内核空间</strong> 内完成的，比如读写磁盘文件，分配回收内存，从网络接口读写数据等等。程序是无法直接访问的，这就涉及到了 <strong>用户态</strong> 和 <strong>内核态</strong> 的通讯机制。通常我们在调用系统提供的接口操作系统资源时都属于这种通讯机制。</p><p>从用户空间和内核空间及通讯角度来看：</p><p><img src="https://raw.githubusercontent.com/cmeng-CM/image-hosting/master/img/theoretical_knowledge/虚拟内存结构2.png" alt="虚拟内存结构（ps：图片来源于网络）"></p><p><br><font size="5">用户态主动切换至内核态</font><br>粗略根据代码流程看下用户切换到内核态的流水，<strong>用户态 &lt;—&gt; 内核态</strong> 状态切换流程（大致示意）：<br></p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token comment">//读取文件</span><span class="token class-name">File</span> file <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">File</span><span class="token punctuation">(</span><span class="token string">"/demo.txt"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">long</span> length <span class="token operator">=</span> file<span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><br><img src="https://raw.githubusercontent.com/cmeng-CM/image-hosting/master/img/theoretical_knowledge/file_read.jpg" alt="用户态主动切换到内核态"><p></p><p>上图为文件读取过程程序的用户态和内核态之前的切换，可以看到程序无法直接访问系统资源，如果涉及系统资源的访问都需要通过 <strong>内核空间</strong> ，切换为 <strong>内核态</strong> 才可以。</p><p><br><font size="5"> 用户态切换到内核态的 3 种方式</font>：</p><ul><li>系统调用：用户态主动切换为内核的方式，如上述示例。</li><li>异常：当 CPU 在用户态执行时，发生不可预知异常，则会切换到内核处理异常的机制中，比如缺页异常。</li><li>外围设备的中断。</li></ul><style>.dotted {    border-top: 2px dotted #eed5d2;}</style>]]></content>
      
      
      <categories>
          
          <category> 理论知识 </category>
          
          <category> 内存 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 虚拟空间,用户态,内核态 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JVM启动参数</title>
      <link href="/2023/01/18/java/jvm/jvm-params/"/>
      <url>/2023/01/18/java/jvm/jvm-params/</url>
      
        <content type="html"><![CDATA[<p><a href="https://docs.oracle.com/javase/8/docs/technotes/tools/unix/java.html">​JAVA8虚拟机参数官方文档​</a></p><h3 id="一、-X：显示所有可用-X选项的帮助。"><a href="#一、-X：显示所有可用-X选项的帮助。" class="headerlink" title="一、-X：显示所有可用-X选项的帮助。"></a>一、-X：显示所有可用-X选项的帮助。</h3><div class="table-container"><table><thead><tr><th style="text-align:center">参数名称</th><th style="text-align:center">含义</th><th style="text-align:center">默认值</th><th style="text-align:center">描述/示例</th></tr></thead><tbody><tr><td style="text-align:center">-Xms</td><td style="text-align:center">堆的最小和初始大小（以字节为单位），可以使用 -Xmn 选项或 -XX:NewSize 选项设置年轻代堆的初始大小。</td><td style="text-align:center">初始大小将被设置为分配给老年代和年轻代的大小之和</td><td style="text-align:center">示例：大小设置为 <strong>6MB</strong> 的方式有以下三种： <strong>-Xms6291456</strong>；<strong>-Xms6144k</strong>；<strong>-Xms6m</strong></td></tr><tr><td style="text-align:center">-Xmx</td><td style="text-align:center">堆的最大值</td><td style="text-align:center">默认值是在运行时根据系统配置选择的。</td><td style="text-align:center">-Xms 通常与 -Xmx 设置为相同的值，该 -Xmx 选项相当于 -XX:MaxHeapSize.</td></tr><tr><td style="text-align:center">-Xmn</td><td style="text-align:center">新生代（nursery）设置堆的初始大小和最大大小（以字节为单位）</td><td style="text-align:center"></td><td style="text-align:center">Oracle 建议将新生代的大小保持在整个堆大小的一半到四分之一之间。相当于 -XX:NewSize、-XX:MaxNewSize</td></tr><tr><td style="text-align:center">-XX:MetaspaceSize</td><td style="text-align:center">设置分配的类元数据空间的大小</td><td style="text-align:center"></td><td style="text-align:center">该空间将在第一次超出时触发垃圾回收。垃圾回收的阈值根据使用的元数据量增加或减少。默认大小取决于平台。</td></tr><tr><td style="text-align:center">-XX:MaxMetaspaceSize</td><td style="text-align:center">设置可以分配给类元数据的最大本机内存量。</td><td style="text-align:center">设置为 256 MB：-XX:MaxMetaspaceSize=256m</td><td style="text-align:center">默认情况下，大小不受限制。应用程序的元数据量取决于应用程序本身、其他正在运行的应用程序以及系统上可用的内存量。</td></tr><tr><td style="text-align:center">-XX:+UseConcMarkSweepGC</td><td style="text-align:center">为老年代启用 CMS 垃圾收集器。</td><td style="text-align:center"></td><td style="text-align:center">默认情况下，这个选项是禁用的，收集器是根据机器的配置和 JVM 的类型自动选择的。启用此选项后，该-XX:+UseParNewGC选项会自动设置，以下选项组合已在 JDK 8 中弃用：-XX:+UseConcMarkSweepGC -XX:-UseParNewGC。</td></tr><tr><td style="text-align:center">-XX:CMSInitiatingOccupancyFraction</td><td style="text-align:center">设置开始 CMS 收集周期的老年代占用百分比（0 到 100）。</td><td style="text-align:center">默认值设置为 -1。任何负值（包括默认值）都意味着-XX:CMSTriggerRatio用于定义初始占用率的值。</td><td style="text-align:center">以下示例显示如何将占用率设置为 20%：-XX:CMSInitiatingOccupancyFraction=20</td></tr><tr><td style="text-align:center">-XX:SoftRefLRUPolicyMSPerMB</td><td style="text-align:center">设置软可达对象在上次被引用后在堆上保持活动状态的时间量（以毫秒为单位）。</td><td style="text-align:center">默认值是堆中每兆字节的生命周期一秒。</td><td style="text-align:center">以下示例显示如何将值设置为 2.5 秒：-XX:SoftRefLRUPolicyMSPerMB=2500</td></tr><tr><td style="text-align:center">-XX:+CMSClassUnloadingEnabled</td><td style="text-align:center">使用并发标记清除 (CMS) 垃圾收集器时启用类卸载。</td><td style="text-align:center"></td><td style="text-align:center">默认情况下启用此选项。要禁用 CMS 垃圾收集器的类卸载，请指定-XX:-CMSClassUnloadingEnabled.</td></tr><tr><td style="text-align:center">-XX:SurvivorRatio</td><td style="text-align:center">设置伊甸园空间大小和幸存者空间大小之间的比率。</td><td style="text-align:center">默认情况下，此选项设置为 8。</td><td style="text-align:center">示例显示如何将 eden/survivor 空间比率设置为 4：-XX:SurvivorRatio=4</td></tr><tr><td style="text-align:center">-verbose:gc</td><td style="text-align:center">显示有关每个垃圾回收 (GC) 事件的信息。</td><td style="text-align:center"></td><td style="text-align:center"></td></tr><tr><td style="text-align:center">-Xloggc</td><td style="text-align:center">设置详细 GC 事件信息应重定向到的文件以进行日志记录。</td><td style="text-align:center"></td><td style="text-align:center">写入此文件的信息类似于-verbose:gc自每个记录事件之前的第一个 GC 事件以来经过的时间的输出。如果两者都使用相同的命令，则该-Xloggc选项会覆盖。-verbose:gcjava 例子：-Xloggc:garbage-collection.log</td></tr><tr><td style="text-align:center">-XX:+PrintGCDetails</td><td style="text-align:center">允许在每次 GC 时打印详细消息。默认情况下，此选项被禁用。</td><td style="text-align:center"></td><td style="text-align:center"></td></tr><tr><td style="text-align:center">-XX:+PrintGCDateStamps</td><td style="text-align:center">启用在每个 GC 上打印日期戳。默认情况下，此选项被禁用。</td><td style="text-align:center"></td><td style="text-align:center"></td></tr><tr><td style="text-align:center">-XX:+UseGCLogFileRotation</td><td style="text-align:center">此参数主要定义GC Log 的滚动功能</td><td style="text-align:center"></td><td style="text-align:center"></td></tr><tr><td style="text-align:center">-XX:NumberOfGCLogFiles</td><td style="text-align:center">此参数主要定义滚动日志文件的个数，此参数值必须大于等于1，对应的日志文件命名策略为：<filename>.0、<filename>.1、 … 、 <filename>.n-1等，其中 n 是 该参数的值。</filename></filename></filename></td><td style="text-align:center"></td><td style="text-align:center"></td></tr><tr><td style="text-align:center">-XX:GCLogFileSize</td><td style="text-align:center">此参数主要定义滚动日志文件的大小，必须大于 8k，当前写日志文件大小超过该参数值时，日志将写入下一个文件，依次类推。</td><td style="text-align:center"></td><td style="text-align:center"></td></tr><tr><td style="text-align:center">-XX:-OmitStackTraceInFastThrow</td><td style="text-align:center">禁用fast throw。fast throw：优化这个抛出异常的地方，同一个异常多次抛出会直接抛出一个事先分配好的、类型匹配的对象，这个对象的message和stack trace都被清空</td><td style="text-align:center"></td><td style="text-align:center"></td></tr><tr><td style="text-align:center">-XX:+UseCMSCompactAtFullCollection</td><td style="text-align:center">使用并发收集器时,开启对年老代的压缩.</td><td style="text-align:center"></td><td style="text-align:center"></td></tr><tr><td style="text-align:center">-XX:+CMSParallelRemarkEnabled</td><td style="text-align:center">降低标记停顿</td><td style="text-align:center"></td><td style="text-align:center"></td></tr><tr><td style="text-align:center">-XX:+UseLargePages</td><td style="text-align:center">启用大页面内存的使用。默认情况下，禁用此选项并且不使用大页面内存。</td><td style="text-align:center"></td></tr></tbody></table></div>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
          <category> JVM </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JVM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>shell脚本相关笔记</title>
      <link href="/2022/11/27/syntax-format/shell-syntax/"/>
      <url>/2022/11/27/syntax-format/shell-syntax/</url>
      
        <content type="html"><![CDATA[<h3 id="a到-z的含义"><a href="#a到-z的含义" class="headerlink" title="-a到-z的含义"></a>-a到-z的含义</h3><p>变量    含义<br>[ -a FILE ]    如果 FILE 存在则为真<br>[ -b FILE ]    如果 FILE 存在且是一个块特殊文件则为真<br>[ -c FILE ]    如果 FILE 存在且是一个字特殊文件则为真<br>[ -e FILE ]    如果 FILE 存在则为真<br>[ -f FILE ]    如果 FILE 存在且是一个普通文件则为真<br>[ -g FILE ]    如果 FILE 存在且已经设置了SGID则为真<br>[ -h FILE ]    如果 FILE 存在且是一个符号连接则为真<br>[ -k FILE ]    如果 FILE 存在且已经设置了粘制位则为真<br>[ -r FILE ]    如果 FILE 存在且是可读的则为真<br>[ -s FILE ]    如果 FILE 存在且大小不为0则为真<br>[ -t FD ]    如果文件描述符 FD 打开且指向一个终端则为真<br>[ -u FILE ]    如果 FILE 存在且设置了SUID (set user ID)则为真<br>[ -w FILE ]    如果 FILE 如果 FILE 存在且是可写的则为真<br>[ -x FILE ]    如果 FILE 存在且是可执行的则为真<br>[ -O FILE ]    如果 FILE 存在且属有效用户ID则为真<br>[ - G FILE ]    如果 FILE 存在且属有效用户组则为真<br>[ -L FILE ]    如果 FILE 存在且是一个符号连接则为真<br>[ -N FILE ]    如果 FILE 存在 and has been mod如果ied since it was last read则为真<br>[ -S FILE ]    如果 FILE 存在且是一个套接字则为真<br>[ -z STRING ]    “STRING” 的长度为零则为真</p><p>字符串判断<br>变量    含义<br>str1 = str2    两个字符串完全相等为真<br>str1 != str2    两个字符串不完全相等为真<br>-n str1    当串的长度大于0时为真(串非空)<br>-z str1    当串的长度为0时为真(空串)<br>str1    当串str1为非空时为真<br>数字判断<br>变量    含义<br>int1 -eq int2    两数字相等为真<br>int1 -ne int2    两数字不相等为真<br>int1 -gt int2    int1大于int2为真<br>int1 -ge int2    int1&gt;= int2为真<br>in1 -lt int2    int1&lt;int2 为真<br>int1 -le int2    int1 &lt;= int2为真<br>文件判断<br>变量名    含义<br>-r file    用户可读为真<br>-w file    用户可写为真<br>-f file    文件为正规文件为真<br>-x file    用户可执行为真<br>-d file    文件为目录为真<br>-c file    闻见味特殊字符文件为真<br>-s file    文件大小非0为真<br>-b file    文件为块特殊文件为真<br>-t file    文件描述符(默认1)指定的设备为终端时为真<br>复杂逻辑<br>变量名    含义<br>-a    与<br>-o    或<br>!    非<br>!=    不等于</p><p>作者：PengboGai<br>链接：<a href="https://www.jianshu.com/p/73b562050e83">https://www.jianshu.com/p/73b562050e83</a><br>来源：简书<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>MQ原理和技术选型</title>
      <link href="/2022/11/13/message-queue/mq-yuan-li-he-ji-zhu-xuan-xing/"/>
      <url>/2022/11/13/message-queue/mq-yuan-li-he-ji-zhu-xuan-xing/</url>
      
        <content type="html"><![CDATA[<h1 id="MQ原理及选型"><a href="#MQ原理及选型" class="headerlink" title="MQ原理及选型"></a>MQ原理及选型</h1><h2 id="一、消息队列概念"><a href="#一、消息队列概念" class="headerlink" title="一、消息队列概念"></a>一、消息队列概念</h2><h3 id="1-1、概述"><a href="#1-1、概述" class="headerlink" title="1.1、概述"></a>1.1、概述</h3><p><strong>消息队列（英语：Message queue，简称：MQ）</strong>：是一种进程间通信或同一进程的不同线程间的通信方式。</p><ul><li>消息（Message）：是指在应用之间传送的数据，消息可以非常简单，比如只包含文本字符串，也可以更复杂，可能包含嵌入对象。</li><li>队列（Queue）：保持消息的容器，本质上为队列。</li></ul><p><strong>原始模型：</strong><br><img src="https://raw.githubusercontent.com/cmeng-CM/image-hosting/master/img/MQ/MQ_basic_model.jpg" alt="MQ基本模型"></p><p>消息队列的本质很好理解，本质都是：<strong><font color="red">一发、一存、一消</font></strong>，所有复杂模型和中间件实现都是基于这个最初原理和模型来实现的。</p><h3 id="1-2、MQ模型"><a href="#1-2、MQ模型" class="headerlink" title="1.2、MQ模型"></a>1.2、MQ模型</h3><p>现在有MQ产品都是在上面的原始模型基础上进行演化、扩展出来的功能更完善、性能更稳定的中间件。目前比较通用的MQ模型有两种：</p><ul><li>点对点模型（point to point，queue）模型。</li><li>发布/订阅（publish/subscribe，topic）模型。</li></ul><h4 id="点对点模型"><a href="#点对点模型" class="headerlink" title="点对点模型"></a>点对点模型</h4><p><img src="https://raw.githubusercontent.com/cmeng-CM/image-hosting/master/img/MQ/MQ_peertopeer_model.jpg" alt="MQ_peertopeer_model"></p><p><strong>特点：</strong></p><ul><li>消息的消费顺序和生产顺序一致。</li><li>它允许多个生产者往同一个队列发送消息。</li><li>若多消费者接收同一队列的消息，这些消费者间就是竞争关系。一条消息只能被其中一个消费者接收到，读完即被删除。</li><li>接收者在成功接收消息之后需向队列应答成功</li></ul><h4 id="发布-订阅模型"><a href="#发布-订阅模型" class="headerlink" title="发布/订阅模型"></a>发布/订阅模型</h4><p><img src="https://raw.githubusercontent.com/cmeng-CM/image-hosting/master/img/MQ/MQ_pub-sub_model.jpg" alt="MQ_pub-sub_model"></p><p><strong>特点：</strong></p><ul><li>每个消息可以有多个消费者：和点对点方式不同，发布消息可以被所有订阅者消费。</li><li>发布者和订阅者之间有时间上的依赖性。</li><li>针对某个主题 <strong>（Topic）</strong> 的订阅者，它必须创建一个订阅者之后，才能消费发布者的消息。</li><li>为了消费消息，订阅者必须保持运行的状态。</li></ul><hr><h2 id="二、消息队列优、缺"><a href="#二、消息队列优、缺" class="headerlink" title="二、消息队列优、缺"></a>二、消息队列优、缺</h2><p>消息队列使用三个经典的场景：异步、解耦、削峰。无论因为什么都是这三点的延伸。下面就这三个模块展开细说。</p><h3 id="2-1、优-异步"><a href="#2-1、优-异步" class="headerlink" title="2.1、优-异步"></a>2.1、优-异步</h3><p>消息队列的主要特点就是异步执行，以异步的方式执行非核心业务逻辑来降低 <strong>RT（Response Time）</strong>，提高用户体验和流畅性。</p><p>比如某个充值场景，最初可能就是个简单的充值，充值支付成功就OK。但随着迭代和推广，出现了充值返利、积分、充值赠券、充值后短信通知等等功能。这个时候同步操作就很影响响应时间了。</p><p>此时就需要考虑异步操作，将非必要的放在MQ异步完成，压缩响应时间。</p><p><img src="https://raw.githubusercontent.com/cmeng-CM/image-hosting/master/img/MQ/MQ_Async_model.jpeg" alt="异步模型"></p><h3 id="2-2、优-解耦"><a href="#2-2、优-解耦" class="headerlink" title="2.2、优-解耦"></a>2.2、优-解耦</h3><p>还是上面充值的场景，假如不用MQ，我直接使用异步线程或者分布式情况下调用其它服务接口不一样实现异步的操作么。</p><p>其实是可以的，但弊端就是后续再有相关的流程加入到充值操作里面，就需要改代码、加调用。流程越多改的次数越多。</p><p>所以MQ的另一个特性就体现出来了：<strong>解耦</strong>。如果使用MQ充值成功后发布个充值成功到队列，谁需要谁就去消费，这样充值就直负责充值，其它的就不用管了。各自系统负责自己的任务就可以了。</p><p>所以MQ可实现模块、服务、接口等不同粒度上实现解耦。</p><h3 id="2-3、优-削峰"><a href="#2-3、优-削峰" class="headerlink" title="2.3、优-削峰"></a>2.3、优-削峰</h3><p>削峰就比较好理解了，比如系统推广或秒杀的时候，突然<strong>QPS</strong>（QPS：Queries Per Second：每秒查询率）极速上涨。这个时候就得考虑服务是否能承载这么大的访问，如果超出系统负责可能直接就是崩掉了。</p><p>这个时候就可以把请求先放到MQ中，至于每秒消费多少就根据数据库、中间件以及服务本身的实际情况来判断并消费对应的消息就可以了。虽然响应慢一些，但不至于直接把服务干蹦掉。</p><p><img src="https://raw.githubusercontent.com/cmeng-CM/image-hosting/master/img/MQ/MQ_weaken_peak_model.jpg" alt="削峰模型"></p><h3 id="2-4、使用MQ的缺点"><a href="#2-4、使用MQ的缺点" class="headerlink" title="2.4、使用MQ的缺点"></a>2.4、使用MQ的缺点</h3><p>以上均为系统加入MQ的优点，那么有没有缺点呢？当然有了，所有东西都要辩证的来得。</p><ul><li>系统复杂性：原本系统的基础上增加中间件，就要考虑其使用、维护、问题定位等问题。再加上MQ机制本身也要考虑：重复消费、消息丢失、消息的顺序消费等等问题。系统复杂性的增加不言而喻了。</li><li>数据一致性：比如刚刚的充值，充值操作是完成了，那返利是否完成？优惠券是否发放？短信是否已通知到位？</li><li>可用性：原本只需要考虑系统的健壮性就可以，现在增加了中间件MQ，那MQ挂了怎么处理？系统是否就直接宕掉了？</li></ul><p>当然这些都是可以处理，只不过增加相应的开发、维护成本。最终是否使用MQ还是需要根据实际的系统和业务需求来考虑其使用情况</p><hr><h2 id="三、消息队列协议"><a href="#三、消息队列协议" class="headerlink" title="三、消息队列协议"></a>三、消息队列协议</h2><h3 id="3-1、JMS：Java-Message-Service（Java-消息服务）"><a href="#3-1、JMS：Java-Message-Service（Java-消息服务）" class="headerlink" title="3.1、JMS：Java Message Service（Java 消息服务）"></a>3.1、JMS：Java Message Service（Java 消息服务）</h3><p><a href="https://www.oracle.com/technical-resources/articles/java/intro-java-message-service.html">JMS</a>：Java 消息服务 (JMS) API 是一种消息传递标准，它允许基于 Java 平台企业版 (Java EE) 的应用程序组件创建、发送、接收和读取消息。它支持松耦合、可靠和异步的分布式通信。</p><font size="5" color="#b9268d">支持两种模型： </font><ul><li>点对点（队列目的地）：在此模型中，消息从生产者传递到一个消费者。</li><li>发布/订阅（主题目的地）：在此模型中，消息从生产者传递到任意数量的消费者。</li></ul><font size="5" color="#b9268d">JMS优点：</font><ul><li>同时支持同步和异步<ul><li>同步：在这种模式下，客户端通过调用对象的receive()方法来接收消息MessageConsumer。应用程序线程阻塞直到方法返回，这会导致如果消息不可用，它会阻塞直到消息可用或receive()方法超时。</li><li>异步：在这种模式下，客户端MessageListener向消息消费者注册一个对象。这类似于回调，其中客户端在会话调用onMessage()方法时使用消息。</li></ul></li><li>可靠的；JMS 定义了两种传递模式：<ul><li>持久化消息：保证一次且仅一次成功消费。消息不会丢失。</li><li>非持久消息：保证最多传递一次。消息丢失不是问题。<br>JMS 提供了确保消息将被传递一次且仅一次的设施。我们知道重复的消息会产生问题。JMS 可以帮助您避免此类问题。</li></ul></li></ul><p><a href="https://activemq.apache.org/">ActiveMQ</a>：就是<strong>JMS</strong>规范中的一种消息中间件。</p><hr class="dotted"><h3 id="3-2、AMQP：Advanced-Message-Queuing-Protocol（高级消息队列协议）"><a href="#3-2、AMQP：Advanced-Message-Queuing-Protocol（高级消息队列协议）" class="headerlink" title="3.2、AMQP：Advanced Message Queuing Protocol（高级消息队列协议）"></a>3.2、AMQP：Advanced Message Queuing Protocol（高级消息队列协议）</h3><p><strong>AMQP：</strong> 是一个二进制的、面向消息的中间件的开放标准，应用层协议。</p><ul><li>旨在有效地支持各种消息传递应用程序和通信模式。</li><li>其特征是消息导向、队列、路由（包括点对点和发布-订阅）、可靠性和安全性。</li><li>基于此协议的客户端与消息中间件可传递消息，并不受客户端/中间件不同产品，不同开发语言等条件的限制。</li></ul><p><a href="https://www.rabbitmq.com/">RabbitMQ</a>：就是AMQP协议的标准实现。<br><strong>基础模型：</strong><br><img src="https://raw.githubusercontent.com/cmeng-CM/image-hosting/master/img/MQ/MQ_amqp_model.jpg" alt="MQ_amqp_model"></p><hr class="dotted"><h3 id="3-3、STOMP：The-Simple-Text-Oriented-Messaging-Protocol（面向简单文本的消息协议）"><a href="#3-3、STOMP：The-Simple-Text-Oriented-Messaging-Protocol（面向简单文本的消息协议）" class="headerlink" title="3.3、STOMP：The Simple Text Oriented Messaging Protocol（面向简单文本的消息协议）"></a>3.3、STOMP：The Simple Text Oriented Messaging Protocol（面向简单文本的消息协议）</h3><p><strong>STOMP：</strong> 是简单（或流式）文本导向消息传递协议，其设计的主要理念是简单性和互操作性。<br><strong>STOMP：</strong> 是一种基于框架的协议，框架以 <strong>HTTP</strong> 为模型。一个框架由一个命令、一组可选的头部和一个可选的主体组成。<strong>STOMP</strong> 基于文本，但也允许传输二进制消息。</p><p><strong>兼容STOMP协议的中间件：</strong><br><img src="https://raw.githubusercontent.com/cmeng-CM/image-hosting/master/img/MQ/MQ_compatible_stomp_server.jpg" alt="MQ_compatible_stomp_server"></p><hr class="dotted"><h3 id="3-4、MQTT"><a href="#3-4、MQTT" class="headerlink" title="3.4、MQTT"></a>3.4、MQTT</h3><p><strong>MQTT：</strong> 最初IBM最初发布时定义名称为：Message Queuing Telemetry Transport（消息队列遥测传输协议），但随着在物联网内的应用和发展 <strong>MQTT</strong> 正迅速成为IOT（物联网）部署的主要协议之一。所以称它为：<strong>用于物联网 (IoT) 的 OASIS 标准消息传递协议</strong> 更为准确。</p><p><strong>MQTT：</strong> 被设计为一种极其轻量级的发布/订阅消息传输，非常适合连接具有小代码占用空间和最小网络带宽的远程设备。如今，MQTT 被广泛用于各种行业，例如汽车、制造、电信、石油和天然气等。</p><p><strong>官方架构图：</strong><br><img src="https://raw.githubusercontent.com/cmeng-CM/image-hosting/master/img/MQ/MQ_mqtt_official_architecture.jpg" alt="MQ_mqtt_official_architecture"></p><hr class="dotted"><h3 id="3-5、XMPP：Extensible-Messaging-and-Presence-Protocol（可扩展消息与存在协议）"><a href="#3-5、XMPP：Extensible-Messaging-and-Presence-Protocol（可扩展消息与存在协议）" class="headerlink" title="3.5、XMPP：Extensible Messaging and Presence Protocol（可扩展消息与存在协议）"></a>3.5、XMPP：Extensible Messaging and Presence Protocol（可扩展消息与存在协议）</h3><p><strong>XXMP：</strong> 是一种以XML为基础的开放式即时通信协议。该协议于 1999 年从 Jabber 开源社区出现，最初旨在为 ICQ、AIM 和 MSN 等面向消费者的即时消息 (IM) 服务提供一种开放、安全、去中心化的替代方案。核心技术于 2004 年在IETF中以可扩展消息传递和存在协议 (XMPP) 的名称正式确定  。这些核心技术包括：</p><ul><li>基本 XML 流层</li><li>使用传输层安全性 (TLS) 的通道加密</li><li>使用简单身份验证和安全层 (SASL) 的强身份验证</li><li>使用 UTF-8 获得完整的 Unicode 支持，包括完全国际化的地址</li><li>关于网络可用性的内置信息（“存在”）</li><li>用于双向授权的 Presence 订阅</li><li>启用在线状态的联系人列表（“花名册”）</li></ul><h2 id="四、MQ中间件"><a href="#四、MQ中间件" class="headerlink" title="四、MQ中间件"></a>四、MQ中间件</h2><h4 id="参照网络数据形成的各MQ不同维度的对比"><a href="#参照网络数据形成的各MQ不同维度的对比" class="headerlink" title="参照网络数据形成的各MQ不同维度的对比"></a>参照网络数据形成的各MQ不同维度的对比</h4><div class="table-container"><table><thead><tr><th>特性</th><th>ActiveMQ</th><th>RabbitMQ</th><th>RocketMQ</th><th>Kafka</th></tr></thead><tbody><tr><td>开发语言</td><td>java</td><td>Erlang</td><td>Java</td><td>Scala</td></tr><tr><td>支持的协议</td><td>OpenWire、STOMP、REST、XMPP、AMQP</td><td>AMQP</td><td>自定义</td><td>基于TCP自定义的一套</td></tr><tr><td>客户端支持语言</td><td>JAVA、C、C++、Python、PHP、Pert、net等</td><td>官方支持Erlang、Java/Ruby等，社区产出多种语言API，几乎支持所有常用语言</td><td>JAVA、C++（不成熟）</td><td>官方支持JAVA,开源社区有多语言版本，如PHP,Python,GO,C/C++，Ruby，NodeJS等编程语言</td></tr><tr><td>单机吞吐量</td><td>万级</td><td>万级</td><td>10万级</td><td>10万级别</td></tr><tr><td>topic数量对吞吐量的影响</td><td></td><td></td><td>topic可以达到几百，几千个的级别，吞吐量会有较小幅度的下降 这是RocketMQ的一大优势，在同等机器下，可以支撑大量的topic</td><td>topic从几十个到几百个的时候，吞吐量会大幅度下降 所以在同等机器下，kafka尽量保证topic数量不要过多。如果要支撑大规模topic，需要增加更多的机器资源</td></tr><tr><td>时效性</td><td>ms级</td><td>微秒级</td><td>ms级</td><td>延迟在ms级以内</td></tr><tr><td>可用性</td><td>高，基于主从架构实现高可用性</td><td>高，基于主从架构实现高可用性</td><td>非常高，分布式架构</td><td>非常高，kafka是分布式的，一个数据多个副本，少数机器宕机，不会丢失数据，不会导致不可用</td></tr><tr><td>消息可靠性</td><td>有较低的概率丢失数据</td><td>基本不丢</td><td>经过参数优化配置，可以做到0丢失</td><td>经过参数优化配置，消息可以做到0丢失</td></tr><tr><td>事物</td><td>支持</td><td>支持</td><td>支持</td><td>支持</td></tr><tr><td>持久化</td><td>内存、文件、数据库</td><td>内存、文件，支持数据堆积，但数据堆积会影响生产速率</td><td>磁盘文件</td><td>磁盘文件，只要磁盘容量足够，可以做到无限消息堆积</td></tr><tr><td>功能支持</td><td>MQ领域的功能极其完备</td><td>基于erlang开发，所以并发能力很强，性能极其好，延时很低</td><td>MQ功能较为完善，还是分布式的，扩展性好</td><td>功能较为简单，主要支持简单的MQ功能，在大数据领域的实时计算以及日志采集被大规模使用，是事实上的标准</td></tr><tr><td>社区活跃度</td><td>低</td><td>中</td><td>高</td><td>高</td></tr></tbody></table></div><p>综合上面的对比数据再结合项目实际的业务需求其实就已经可以很好的总结出具体的技术选型了。</p><font size="5" color="#b9268d">记住，没有最好的技术，只有最适合的技术，不要为了用而用。</font><style>.dotted {    border-top: 2px dotted #eed5d2;}</style>]]></content>
      
      
      <categories>
          
          <category> MQ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MQ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>RocketMQ——《1、启动脚本》</title>
      <link href="/2022/11/13/message-queue/rocketmq/"/>
      <url>/2022/11/13/message-queue/rocketmq/</url>
      
        <content type="html"><![CDATA[<h1 id="RocketMQ使用记录"><a href="#RocketMQ使用记录" class="headerlink" title="RocketMQ使用记录"></a>RocketMQ使用记录</h1><p><strong>RocketMQ</strong> 相关的操作和使用官方的文档是有具体步骤讲解的：<a href="https://rocketmq.apache.org/zh/docs/">RocketMQ官方</a>。本文基于官方文档的基础上 <strong>深入每步的具体操作</strong> 及后续 <strong>运行原理和源码</strong> 进行进一步分析和讨论。</p><h2 id="一、启动"><a href="#一、启动" class="headerlink" title="一、启动"></a>一、启动</h2><p>安装好Rocket后，启动操作如下：<br></p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token comment">### 启动namesrv</span>$ <span class="token function">nohup</span> <span class="token function">sh</span> bin/mqnamesrv <span class="token operator">&amp;</span> <span class="token comment">### 验证namesrv是否启动成功</span>$ <span class="token function">tail</span> <span class="token parameter variable">-f</span> ~/logs/rocketmqlogs/namesrv.logThe Name Server boot success<span class="token punctuation">..</span>.<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><br>下面分解启动流程内包含的所有操作和配置。<p></p><h3 id="1-1、mqnamesrv"><a href="#1-1、mqnamesrv" class="headerlink" title="1.1、mqnamesrv"></a>1.1、mqnamesrv</h3><p>源码：<br></p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token keyword">if</span> <span class="token punctuation">[</span> <span class="token parameter variable">-z</span> <span class="token string">"<span class="token variable">$ROCKETMQ_HOME</span>"</span> <span class="token punctuation">]</span> <span class="token punctuation">;</span> <span class="token keyword">then</span>  <span class="token comment">## resolve links - $0 may be a link to maven's home</span>  <span class="token comment"># 获取执行文件名称   </span>  <span class="token assign-left variable">PRG</span><span class="token operator">=</span><span class="token string">"<span class="token variable">$0</span>"</span>  <span class="token comment"># 如果 $0 是软连接则通过迭代获取其绝对路径</span>  <span class="token comment"># need this for relative symlinks</span>  <span class="token keyword">while</span> <span class="token punctuation">[</span> <span class="token parameter variable">-h</span> <span class="token string">"<span class="token variable">$PRG</span>"</span> <span class="token punctuation">]</span> <span class="token punctuation">;</span> <span class="token keyword">do</span>    <span class="token assign-left variable">ls</span><span class="token operator">=</span><span class="token variable"><span class="token variable">`</span><span class="token function">ls</span> <span class="token parameter variable">-ld</span> <span class="token string">"<span class="token variable">$PRG</span>"</span><span class="token variable">`</span></span>    <span class="token assign-left variable">link</span><span class="token operator">=</span><span class="token variable"><span class="token variable">`</span><span class="token function">expr</span> <span class="token string">"<span class="token variable">$ls</span>"</span> <span class="token builtin class-name">:</span> <span class="token string">'.*-&gt; \(.*\)$'</span><span class="token variable">`</span></span>    <span class="token keyword">if</span> <span class="token function">expr</span> <span class="token string">"<span class="token variable">$link</span>"</span> <span class="token builtin class-name">:</span> <span class="token string">'/.*'</span> <span class="token operator">&gt;</span> /dev/null<span class="token punctuation">;</span> <span class="token keyword">then</span>      <span class="token assign-left variable">PRG</span><span class="token operator">=</span><span class="token string">"<span class="token variable">$link</span>"</span>    <span class="token keyword">else</span>      <span class="token assign-left variable">PRG</span><span class="token operator">=</span><span class="token string">"<span class="token variable"><span class="token variable">`</span><span class="token function">dirname</span> <span class="token string">"<span class="token variable">$PRG</span>"</span><span class="token variable">`</span></span>/<span class="token variable">$link</span>"</span>    <span class="token keyword">fi</span>  <span class="token keyword">done</span>  <span class="token assign-left variable">saveddir</span><span class="token operator">=</span><span class="token variable"><span class="token variable">`</span><span class="token builtin class-name">pwd</span><span class="token variable">`</span></span>  <span class="token assign-left variable">ROCKETMQ_HOME</span><span class="token operator">=</span><span class="token variable"><span class="token variable">`</span><span class="token function">dirname</span> <span class="token string">"<span class="token variable">$PRG</span>"</span><span class="token variable">`</span></span>/<span class="token punctuation">..</span>  <span class="token comment"># make it fully qualified</span>  <span class="token assign-left variable">ROCKETMQ_HOME</span><span class="token operator">=</span><span class="token variable"><span class="token variable">`</span><span class="token builtin class-name">cd</span> <span class="token string">"<span class="token variable">$ROCKETMQ_HOME</span>"</span> <span class="token operator">&amp;&amp;</span> <span class="token builtin class-name">pwd</span><span class="token variable">`</span></span>  <span class="token builtin class-name">cd</span> <span class="token string">"<span class="token variable">$saveddir</span>"</span><span class="token keyword">fi</span><span class="token builtin class-name">export</span> ROCKETMQ_HOME<span class="token comment"># 执行runserver.sh脚本，启动 NamesrvStartup 类文件</span><span class="token function">sh</span> <span class="token variable">${ROCKETMQ_HOME}</span>/bin/runserver.sh org.apache.rocketmq.namesrv.NamesrvStartup <span class="token variable">$@</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><br>所以mqnamesrv内容很简单：<p></p><ul><li>找到 <strong>ROCKETMQ_HOME</strong> 的绝对路径，即下载包所在的绝对路径。</li><li>设置环境变量 <strong>ROCKETMQ_HOME</strong></li><li>启动 <strong>runserver.sh</strong> 脚本，并带有指定类 <strong>NamesrvStartup</strong>。</li><li>如果运行 <strong>mqnamesrv</strong> 时有额外参数也一并带入 <strong>runserver.sh</strong> 脚本中。</li></ul><h3 id="1-2、runserver"><a href="#1-2、runserver" class="headerlink" title="1.2、runserver"></a>1.2、runserver</h3><p>源码：<br></p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token comment"># 错误日志输出</span><span class="token function-name function">error_exit</span> <span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token builtin class-name">echo</span> <span class="token string">"ERROR: <span class="token variable">$1</span> !!"</span>    <span class="token builtin class-name">exit</span> <span class="token number">1</span><span class="token punctuation">}</span><span class="token comment"># 校验JAVA环境是否存在</span><span class="token punctuation">[</span> <span class="token operator">!</span> <span class="token parameter variable">-e</span> <span class="token string">"<span class="token variable">$JAVA_HOME</span>/bin/java"</span> <span class="token punctuation">]</span> <span class="token operator">&amp;&amp;</span> <span class="token assign-left variable">JAVA_HOME</span><span class="token operator">=</span><span class="token environment constant">$HOME</span>/jdk/java<span class="token punctuation">[</span> <span class="token operator">!</span> <span class="token parameter variable">-e</span> <span class="token string">"<span class="token variable">$JAVA_HOME</span>/bin/java"</span> <span class="token punctuation">]</span> <span class="token operator">&amp;&amp;</span> <span class="token assign-left variable">JAVA_HOME</span><span class="token operator">=</span>/usr/java<span class="token punctuation">[</span> <span class="token operator">!</span> <span class="token parameter variable">-e</span> <span class="token string">"<span class="token variable">$JAVA_HOME</span>/bin/java"</span> <span class="token punctuation">]</span> <span class="token operator">&amp;&amp;</span> error_exit <span class="token string">"Please set the JAVA_HOME variable in your environment, We need java(x64)!"</span><span class="token comment"># 定义环境变量</span><span class="token builtin class-name">export</span> JAVA_HOME<span class="token builtin class-name">export</span> <span class="token assign-left variable">JAVA</span><span class="token operator">=</span><span class="token string">"<span class="token variable">$JAVA_HOME</span>/bin/java"</span><span class="token builtin class-name">export</span> <span class="token assign-left variable">BASE_DIR</span><span class="token operator">=</span><span class="token variable"><span class="token variable">$(</span><span class="token function">dirname</span> $0<span class="token variable">)</span></span>/<span class="token punctuation">..</span><span class="token builtin class-name">export</span> <span class="token assign-left variable">CLASSPATH</span><span class="token operator">=</span>.:<span class="token variable">${BASE_DIR}</span>/conf:<span class="token variable">${BASE_DIR}</span>/lib/*:<span class="token variable">${CLASSPATH}</span><span class="token comment">#===========================================================================================</span><span class="token comment"># JVM Configuration</span><span class="token comment">#===========================================================================================</span><span class="token comment"># The RAMDisk initializing size in MB on Darwin OS for gc-log</span><span class="token assign-left variable">DIR_SIZE_IN_MB</span><span class="token operator">=</span><span class="token number">600</span><span class="token comment"># 选择GC日志目录</span><span class="token function-name function">choose_gc_log_directory</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">case</span> <span class="token string">"<span class="token variable"><span class="token variable">`</span><span class="token function">uname</span><span class="token variable">`</span></span>"</span> <span class="token keyword">in</span>        Darwin<span class="token punctuation">)</span>            <span class="token keyword">if</span> <span class="token punctuation">[</span> <span class="token operator">!</span> <span class="token parameter variable">-d</span> <span class="token string">"/Volumes/RAMDisk"</span> <span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token keyword">then</span>                <span class="token comment"># create ram disk on Darwin systems as gc-log directory</span>                <span class="token assign-left variable">DEV</span><span class="token operator">=</span><span class="token variable"><span class="token variable">`</span>hdiutil attach <span class="token parameter variable">-nomount</span> ram://<span class="token punctuation">$((</span><span class="token number">2</span> * <span class="token number">1024</span> * DIR_SIZE_IN_MB<span class="token punctuation">))</span><span class="token variable">`</span></span> <span class="token operator">&gt;</span> /dev/null                diskutil eraseVolume HFS+ RAMDisk <span class="token variable">${DEV}</span> <span class="token operator">&gt;</span> /dev/null                <span class="token builtin class-name">echo</span> <span class="token string">"Create RAMDisk /Volumes/RAMDisk for gc logging on Darwin OS."</span>            <span class="token keyword">fi</span>            <span class="token assign-left variable">GC_LOG_DIR</span><span class="token operator">=</span><span class="token string">"/Volumes/RAMDisk"</span>        <span class="token punctuation">;</span><span class="token punctuation">;</span>        *<span class="token punctuation">)</span>            <span class="token comment"># check if /dev/shm exists on other systems</span>            <span class="token keyword">if</span> <span class="token punctuation">[</span> <span class="token parameter variable">-d</span> <span class="token string">"/dev/shm"</span> <span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token keyword">then</span>                <span class="token assign-left variable">GC_LOG_DIR</span><span class="token operator">=</span><span class="token string">"/dev/shm"</span>            <span class="token keyword">else</span>                <span class="token assign-left variable">GC_LOG_DIR</span><span class="token operator">=</span><span class="token variable">${BASE_DIR}</span>            <span class="token keyword">fi</span>        <span class="token punctuation">;</span><span class="token punctuation">;</span>    <span class="token keyword">esac</span><span class="token punctuation">}</span><span class="token comment"># 设置JVM启动参数</span><span class="token function-name function">choose_gc_options</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token comment"># Example of JAVA_MAJOR_VERSION value : '1', '9', '10', '11', ...</span>    <span class="token comment"># '1' means releases befor Java 9</span>    <span class="token assign-left variable">JAVA_MAJOR_VERSION</span><span class="token operator">=</span><span class="token variable"><span class="token variable">$(</span>"$JAVA<span class="token string">" -version 2&gt;&amp;1 | sed -r -n 's/.* version "</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token number">0</span>-9<span class="token punctuation">]</span>*<span class="token punctuation">)</span>.*$/<span class="token punctuation">\</span><span class="token number">1</span>/p'<span class="token variable">)</span></span>    <span class="token keyword">if</span> <span class="token punctuation">[</span> <span class="token parameter variable">-z</span> <span class="token string">"<span class="token variable">$JAVA_MAJOR_VERSION</span>"</span> <span class="token punctuation">]</span> <span class="token operator">||</span> <span class="token punctuation">[</span> <span class="token string">"<span class="token variable">$JAVA_MAJOR_VERSION</span>"</span> <span class="token parameter variable">-lt</span> <span class="token string">"9"</span> <span class="token punctuation">]</span> <span class="token punctuation">;</span> <span class="token keyword">then</span>      <span class="token assign-left variable">JAVA_OPT</span><span class="token operator">=</span><span class="token string">"<span class="token variable">${JAVA_OPT}</span> -server -Xms4g -Xmx4g -Xmn2g -XX:MetaspaceSize=128m -XX:MaxMetaspaceSize=320m"</span>      <span class="token assign-left variable">JAVA_OPT</span><span class="token operator">=</span><span class="token string">"<span class="token variable">${JAVA_OPT}</span> -XX:+UseConcMarkSweepGC -XX:+UseCMSCompactAtFullCollection -XX:CMSInitiatingOccupancyFraction=70 -XX:+CMSParallelRemarkEnabled -XX:SoftRefLRUPolicyMSPerMB=0 -XX:+CMSClassUnloadingEnabled -XX:SurvivorRatio=8 -XX:-UseParNewGC"</span>      <span class="token assign-left variable">JAVA_OPT</span><span class="token operator">=</span><span class="token string">"<span class="token variable">${JAVA_OPT}</span> -verbose:gc -Xloggc:<span class="token variable">${GC_LOG_DIR}</span>/rmq_srv_gc_%p_%t.log -XX:+PrintGCDetails -XX:+PrintGCDateStamps"</span>      <span class="token assign-left variable">JAVA_OPT</span><span class="token operator">=</span><span class="token string">"<span class="token variable">${JAVA_OPT}</span> -XX:+UseGCLogFileRotation -XX:NumberOfGCLogFiles=5 -XX:GCLogFileSize=30m"</span>    <span class="token keyword">else</span>      <span class="token assign-left variable">JAVA_OPT</span><span class="token operator">=</span><span class="token string">"<span class="token variable">${JAVA_OPT}</span> -server -Xms4g -Xmx4g -XX:MetaspaceSize=128m -XX:MaxMetaspaceSize=320m"</span>      <span class="token assign-left variable">JAVA_OPT</span><span class="token operator">=</span><span class="token string">"<span class="token variable">${JAVA_OPT}</span> -XX:+UseG1GC -XX:G1HeapRegionSize=16m -XX:G1ReservePercent=25 -XX:InitiatingHeapOccupancyPercent=30 -XX:SoftRefLRUPolicyMSPerMB=0"</span>      <span class="token assign-left variable">JAVA_OPT</span><span class="token operator">=</span><span class="token string">"<span class="token variable">${JAVA_OPT}</span> -Xlog:gc*:file=<span class="token variable">${GC_LOG_DIR}</span>/rmq_srv_gc_%p_%t.log:time,tags:filecount=5,filesize=30M"</span>    <span class="token keyword">fi</span><span class="token punctuation">}</span>choose_gc_log_directorychoose_gc_options<span class="token assign-left variable">JAVA_OPT</span><span class="token operator">=</span><span class="token string">"<span class="token variable">${JAVA_OPT}</span> -XX:-OmitStackTraceInFastThrow"</span><span class="token assign-left variable">JAVA_OPT</span><span class="token operator">=</span><span class="token string">"<span class="token variable">${JAVA_OPT}</span> -XX:-UseLargePages"</span><span class="token comment">#JAVA_OPT="${JAVA_OPT} </span><span class="token parameter variable">-Xdebug</span> <span class="token parameter variable">-Xrunjdwp:transport</span><span class="token operator">=</span>dt_socket,address<span class="token operator">=</span><span class="token number">9555</span>,server<span class="token operator">=</span>y,suspend<span class="token operator">=</span>n<span class="token string">"JAVA_OPT="</span><span class="token variable">${JAVA_OPT}</span> <span class="token variable">${JAVA_OPT_EXT}</span><span class="token string">"JAVA_OPT="</span><span class="token variable">${JAVA_OPT}</span> <span class="token parameter variable">-cp</span> <span class="token variable">${CLASSPATH}</span>"<span class="token variable">$JAVA</span> <span class="token variable">${JAVA_OPT}</span> <span class="token variable">$@</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><br>流程：<p></p><ol><li>校验JAVA环境信息</li><li>定义环境变量，包含JAVA、RocketMQ等。</li><li>设置JVM的GC日志目录</li><li>设置JVM启动信息，设置参数如下：<ul><li>-Xms4g：堆的最小和初始大小4G。</li><li>-Xmx4g：堆的最大值4G。</li><li>-Xmn2g：新生代2G。</li><li>-XX:MetaspaceSize=128m：元数据空间为128M</li><li>-XX:MaxMetaspaceSize=320m：类元数据的最大本机内存量为320M</li><li>-XX:+UseConcMarkSweepGC：为老年代启用 CMS 垃圾收集器。</li><li>-XX:CMSInitiatingOccupancyFraction=70：设置开始 CMS 收集周期的老年代占用百分比（0 到 100）。</li><li>-XX:SoftRefLRUPolicyMSPerMB=0：设置软可达对象在上次被引用后在堆上保持活动状态的时间量（以毫秒为单位）。</li><li>-XX:+CMSClassUnloadingEnabled：使用并发标记清除 (CMS) 垃圾收集器时启用类卸载。</li><li>-XX:SurvivorRatio=8：设置伊甸园空间大小和幸存者空间大小之间的比率。</li><li>-verbose:gc：显示有关每个垃圾回收 (GC) 事件的信息。</li><li>-Xloggc：设置详细 GC 事件信息应重定向到的文件以进行日志记录。</li><li>-XX:+PrintGCDetails：允许在每次 GC 时打印详细消息。默认情况下，此选项被禁用。</li><li>-XX:+PrintGCDateStamps：启用在每个 GC 上打印日期戳。默认情况下，此选项被禁用。</li><li>-XX:+UseGCLogFileRotation：此参数主要定义GC Log 的滚动功能</li><li>-XX:NumberOfGCLogFiles=5：此参数主要定义滚动日志文件的个数</li><li>-XX:GCLogFileSize=30m：此参数主要定义滚动日志文件的大小</li><li>-XX:-OmitStackTraceInFastThrow：禁用fast throw。fast throw：优化这个抛出异常的地方，同一个异常多次抛出会直接抛出一个事先分配好的、类型匹配的对象，这个对象的message和stack trace都被清空</li><li>-XX:+UseCMSCompactAtFullCollection：使用并发收集器时,开启对年老代的压缩.</li><li>-XX:+CMSParallelRemarkEnabled：降低标记停顿</li><li>-XX:+UseLargePages：启用大页面内存的使用。默认情况下，禁用此选项并且不使用大页面内存。</li></ul></li><li>启动org.apache.rocketmq.namesrv.NamesrvStartup类。</li></ol>]]></content>
      
      
      <categories>
          
          <category> MQ </category>
          
          <category> RocketMQ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> RocketMQ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Markdowm语法</title>
      <link href="/2022/11/13/syntax-format/markdown-yu-fa/"/>
      <url>/2022/11/13/syntax-format/markdown-yu-fa/</url>
      
        <content type="html"><![CDATA[<h2 id="超链接"><a href="#超链接" class="headerlink" title="超链接"></a>超链接</h2><p>markdown内超链接分为两种形式，分别是 <strong>行内式</strong> 和 <strong>参考式</strong></p><ol><li>行内式：<ul><li>格式：<pre class="line-numbers language-none"><code class="language-none">[链接名称](链接地址)或：&lt;连接&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre></li><li>示例：<pre class="line-numbers language-none"><code class="language-none">[这是一个连接](https://cmeng-cm.github.io/)<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>效果：<a href="https://cmeng-cm.github.io/">这是一个连接</a></li></ul></li><li>参考式：参考式链接的写法相当于行内式拆分成两部分，并通过一个 识别符 来连接两部分。<ul><li>示例<pre class="line-numbers language-none"><code class="language-none">[这是一个连接][link][link]: https://cmeng-cm.github.io/<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>效果：<br><a href="https://cmeng-cm.github.io/">这是一个连接</a></li></ul></li></ol><hr><h2 id="分割线"><a href="#分割线" class="headerlink" title="分割线"></a>分割线</h2><h3 id="1、markdown官方提供的分割线语法"><a href="#1、markdown官方提供的分割线语法" class="headerlink" title="1、markdown官方提供的分割线语法"></a>1、markdown官方提供的分割线语法</h3><p>三个星号（*）、三个中划线（-）、三个下划线（-）三者都能达到下面的效果：</p><hr><h3 id="2、特殊效果"><a href="#2、特殊效果" class="headerlink" title="2、特殊效果"></a>2、特殊效果</h3><p><strong>Markdown</strong> 只控制文档的结构，不控制文档的样式。但是既然依托于<strong>html</strong>语法，那我们就依然能通过HTML+CSS的方式定制分割线的样式。<br></p><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup"><span class="token comment">&lt;!-- 简单示例 --&gt;</span><span class="token comment">&lt;!-- 实线： --&gt;</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>hr</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>solid<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span><span class="token comment">&lt;!-- 虚线 --&gt;</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>hr</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>dashed<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span><span class="token comment">&lt;!-- 点状 --&gt;</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>hr</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>dotted<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span><span class="token comment">&lt;!-- 双线 --&gt;</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>hr</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>double<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>hr</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>double<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>style</span><span class="token punctuation">&gt;</span></span><span class="token style"><span class="token language-css"><span class="token selector">.solid</span> <span class="token punctuation">{</span>    <span class="token property">border-top</span><span class="token punctuation">:</span> 5px solid #FFDEAD<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token selector">.dashed</span> <span class="token punctuation">{</span>    <span class="token property">border-top</span><span class="token punctuation">:</span> 6px dashed #00F5FF<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token selector">.dotted</span> <span class="token punctuation">{</span>    <span class="token property">border-top</span><span class="token punctuation">:</span> 7px dotted #C0FF3E<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token selector">.double</span> <span class="token punctuation">{</span>    <span class="token property">border-top</span><span class="token punctuation">:</span> 8px double #FF7F24<span class="token punctuation">;</span><span class="token punctuation">}</span></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>style</span><span class="token punctuation">&gt;</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p></p><p><img src="https://raw.githubusercontent.com/cmeng-CM/image-hosting/master/img/markdown/dividing_line.jpg" alt="效果图"></p><style>.dashed {    border-top: 3px dashed #D3D3D3;}</style>]]></content>
      
      
      <categories>
          
          <category> Markdowm </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Markdowm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>主题标题相关设置</title>
      <link href="/2022/09/16/syntax-format/front-matter-xuan-xiang-xiang-jie/"/>
      <url>/2022/09/16/syntax-format/front-matter-xuan-xiang-xiang-jie/</url>
      
        <content type="html"><![CDATA[<div class="table-container"><table><thead><tr><th style="text-align:center">配置选项</th><th style="text-align:center">默认值</th><th style="text-align:center">描述</th></tr></thead><tbody><tr><td style="text-align:center">title</td><td style="text-align:center">Markdown的文件标题</td><td style="text-align:center">文章标题，强烈建议填写此选项</td></tr><tr><td style="text-align:center">date</td><td style="text-align:center">文件创建时的日期时间</td><td style="text-align:center">发布时间，强烈建议填写此选项，且最好保证全局唯一</td></tr><tr><td style="text-align:center">author</td><td style="text-align:center">根 _config.yml 中的 author</td><td style="text-align:center">文章作者</td></tr><tr><td style="text-align:center">img</td><td style="text-align:center">featureImages中的某个值</td><td style="text-align:center">文章特征图，推荐使用图床(腾讯云、七牛云、又拍云等)来做图片的路径.如: <a href="http://xxx.com/xxx.jpg">http://xxx.com/xxx.jpg</a></td></tr><tr><td style="text-align:center">top</td><td style="text-align:center">true</td><td style="text-align:center">推荐文章（文章是否置顶），如果 top 值为 true，则会作为首页推荐文章</td></tr><tr><td style="text-align:center">hide</td><td style="text-align:center">false</td><td style="text-align:center">隐藏文章，如果hide值为true，则文章不会在首页显示</td></tr><tr><td style="text-align:center">cover</td><td style="text-align:center">false</td><td style="text-align:center">v1.0.2版本新增，表示该文章是否需要加入到首页轮播封面中</td></tr><tr><td style="text-align:center">coverImg</td><td style="text-align:center">无</td><td style="text-align:center">v1.0.2版本新增，表示该文章在首页轮播封面需要显示的图片路径，如果没有，则默认使用文章的特色图片</td></tr><tr><td style="text-align:center">password</td><td style="text-align:center">无</td><td style="text-align:center">文章阅读密码，如果要对文章设置阅读验证密码的话，就可以设置 password 的值，该值必须是用 SHA256 加密后的密码，防止被他人识破。前提是在主题的 config.yml 中激活了 verifyPassword 选项</td></tr><tr><td style="text-align:center">toc</td><td style="text-align:center">true</td><td style="text-align:center">是否开启 TOC，可以针对某篇文章单独关闭 TOC 的功能。前提是在主题的 config.yml 中激活了 toc 选项</td></tr><tr><td style="text-align:center">mathjax</td><td style="text-align:center">false</td><td style="text-align:center">是否开启数学公式支持 ，本文章是否开启 mathjax，且需要在主题的 _config.yml 文件中也需要开启才行</td></tr><tr><td style="text-align:center">summary</td><td style="text-align:center">无</td><td style="text-align:center">文章摘要，自定义的文章摘要内容，如果这个属性有值，文章卡片摘要就显示这段文字，否则程序会自动截取文章的部分内容作为摘要</td></tr><tr><td style="text-align:center">categories</td><td style="text-align:center">无</td><td style="text-align:center">文章分类，本主题的分类表示宏观上大的分类，只建议一篇文章一个分类</td></tr><tr><td style="text-align:center">tags</td><td style="text-align:center">无</td><td style="text-align:center">文章标签，一篇文章可以多个标签</td></tr><tr><td style="text-align:center">keywords</td><td style="text-align:center">文章标题</td><td style="text-align:center">文章关键字，SEO 时需要</td></tr><tr><td style="text-align:center">reprintPolicy</td><td style="text-align:center">cc_by</td><td style="text-align:center">文章转载规则， 可以是 cc_by, cc_by_nd, cc_by_sa, cc_by_nc, cc_by_nc_nd, cc_by_nc_sa, cc0, noreprint 或 pay 中的一个</td></tr></tbody></table></div>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>markdown思维导图demo</title>
      <link href="/2022/09/08/syntax-format/markmap/"/>
      <url>/2022/09/08/syntax-format/markmap/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>并发模型比较</title>
      <link href="/2022/07/17/theoretical-knowledge/concurrency-model/"/>
      <url>/2022/07/17/theoretical-knowledge/concurrency-model/</url>
      
        <content type="html"><![CDATA[<h2 id="一、进程、线程、协程"><a href="#一、进程、线程、协程" class="headerlink" title="一、进程、线程、协程"></a>一、进程、线程、协程</h2><h3 id="1-1、进程"><a href="#1-1、进程" class="headerlink" title="1.1、进程"></a>1.1、进程</h3><p><strong>进程：</strong> 是系统进行资源分配的一个独立单位，内核通过进程控制块（PCB，process control block）来感知进程。</p><blockquote><p>一个计算机系统进程包括（或者说“拥有”）下列资料：</p><blockquote><ul><li>那个程序的可执行机器代码的一个在存储器的映像。</li><li>分配到的存储器（通常是虚拟的一个存储器区域）。存储器的内容包括可执行代码、特定于进程的资料（输入、输出）、调用堆栈、堆栈（用于保存运行时运输中途产生的资料）。</li><li>分配给该进程的资源的操作系统描述符，诸如文件描述符（Unix术语）或文件句柄（Windows）、资料源和资料终端。</li><li>安全特性，诸如进程拥有者和进程的权限集（可以容许的操作）。</li><li>处理器状态（内文），诸如寄存器内容、物理存储器寻址等。当进程正在执行时，状态通常存储在寄存器，其他情况在存储器。</li></ul></blockquote></blockquote><h3 id="1-2、线程"><a href="#1-2、线程" class="headerlink" title="1.2、线程"></a>1.2、线程</h3><ol><li><p>是独立调度和分派的基本单位。内核通过<a href="https://en.wikipedia.org/wiki/Thread_control_block">线程控制块（TCB，thread control block）</a>来感知线程。  </p></li><li><p>同一进程中的多条线程将共享该进程中的全部系统资源，如虚拟地址空间，文件描述符和信号处理等等。但同一进程中的多个线程有各自的调用栈（call stack），自己的寄存器环境（register context），自己的线程本地存储（thread-local storage）。</p></li></ol><h3 id="1-3、线程的实现和调度方式"><a href="#1-3、线程的实现和调度方式" class="headerlink" title="1.3、线程的实现和调度方式"></a>1.3、线程的实现和调度方式</h3><h4 id="1-3-1、线程的实现"><a href="#1-3-1、线程的实现" class="headerlink" title="1.3.1、线程的实现"></a>1.3.1、线程的实现</h4><ol><li><p><strong>内核支持线程（KST，Kernel Supported Threads）</strong></p><ul><li>内核级线程的 TCB 保存在内核空间，其创建、阻塞、撤销、切换等活动也都是在内核空间实现的。</li><li>内核线程的调度是由内核完成的，一般是抢占式调度。     </li></ul></li><li><p>用户级线程(UST, User Supported Threads)</p><ul><li>用户级线程则是内核无关的，用户级线程的实现在用户空间，内核感知不到用户线程的存在。</li><li>用户线程的调度算法可以是进程专用的，不会被内核调度，但同时，用户线程也无法利用多处理机的并行执行。调度也发生在用户态，一般是由线程库或编程语言运行时自行实现的。</li><li>一个拥有多个用户线程的进程，一旦有一个线程阻塞，该进程所有的线程都会被阻塞。</li><li>内核的切换需要转换到内核空间，而用户线程不需要，所以前者开销会更大。</li><li>用户线程需要内核的支持，一般是通过运行时系统或内核控制线程来连接一个内核线程，有 1:1、1:n、n:m 的不同实现。</li></ul></li></ol><h4 id="1-3-2、调度方式"><a href="#1-3-2、调度方式" class="headerlink" title="1.3.2、调度方式"></a>1.3.2、调度方式</h4><p>在分时操作系统中，处理机的调度一般基于时间片的轮转（RR, round robin)，多个就绪线程排成队列，轮流执行时间片。所以进程调度主要有抢占式调度和协作式调度两种：<strong>抢占式(Preemptive)</strong> 与 <strong>协作式(Cooperative)</strong>。</p><ol><li><p><strong>抢占式(Preemptive)</strong><br>抢占式调度往往在一些重要位置（Sleep Call，Timer Tick）放置了中断信号，通过这个信号通知操作系统调度器(Scheduler)进行进程切换。在抢占式模型中，正在运行的进程可能会被强行挂起，这是由于这些中断信号引发的。</p></li><li><p><strong>协作式(Cooperative)</strong>。<br>协作式调度也叫非抢占式调度，是指当前运行的进程通过自身代码逻辑出让CPU控制权。与抢占式调度的区别在于进程运行不会被中断信号打断，除非其主动出让控制权给其他进程。  </p></li><li><p>结构示意图<br><img src="https://raw.githubusercontent.com/cmeng-CM/image-hosting/master/img/theoretical_knowledge/线程调度方式.png" alt="调度方式"></p></li></ol><h3 id="1-4、协程-Coroutines-Cooperative-User-Level-Threads"><a href="#1-4、协程-Coroutines-Cooperative-User-Level-Threads" class="headerlink" title="1.4、协程(Coroutines - Cooperative User-Level Threads)"></a>1.4、协程(Coroutines - Cooperative User-Level Threads)</h3><p><strong>协程：</strong> 又称微线程，纤程。英文名Coroutine。是应用程序通过线程库自行实现的 <strong>协作式调度</strong> 的运行在用户空间的用户线程，是编译器级别的。<strong>系统的并发是时间片的轮转</strong> ，单处理器交互执行不同的执行流，营造不同线程同时执行的感觉；而 <strong>协程的并发，是单线程内控制权的轮转</strong> 。相比抢占式调度，协程是主动让权，实现协作。</p><h2 id="二、并发模型"><a href="#二、并发模型" class="headerlink" title="二、并发模型"></a>二、并发模型</h2><h3 id="2-1、、模型：单进（线）程·循环处理请求"><a href="#2-1、、模型：单进（线）程·循环处理请求" class="headerlink" title="2.1、、模型：单进（线）程·循环处理请求"></a>2.1、、模型：单进（线）程·循环处理请求</h3><p>单进程和单线程其实没有区别，因为一个进程至少有一个线程。循环处理请求应该是最初级的做法。当大量请求进来时，单线程一个一个处理请求，请求很容易就积压起来，得不到响应。这是无并发的做法。</p><h3 id="2-2、模型：多进程（Multiprocessing）"><a href="#2-2、模型：多进程（Multiprocessing）" class="headerlink" title="2.2、模型：多进程（Multiprocessing）"></a>2.2、模型：多进程（Multiprocessing）</h3><p>主进程监听和管理连接，当有客户请求的时候，<strong>fork</strong> 一个子进程来处理连接，父进程继续等待其他客户的请求。</p><p><strong>优点</strong>：<strong>好处是隔离性</strong>，子进程万一 crash 并不会影响到父进程。<br><strong>缺点</strong>：<strong>缺点就是对系统的负担过重</strong>。  </p><p>典型的是 <strong>Apache Web Server</strong>，每个用户请求接入的时候都会创建一个进程，这样应用就可以同时支持多个用户。</p><p><img src="https://raw.githubusercontent.com/cmeng-CM/image-hosting/master/img/theoretical_knowledge/Apache-Web-Server-Thread.jpeg" alt="Apache-Web-Server-Thread"></p><p>在图中M1、M2与M3都代表内存资源，在多进程中如果不同进程想共享内存中的数据必须通过 <strong>进程间通信</strong>的方式来实现。</p><h3 id="2-3、模型：多线程（Multithreaded）"><a href="#2-3、模型：多线程（Multithreaded）" class="headerlink" title="2.3、模型：多线程（Multithreaded）"></a>2.3、模型：多线程（Multithreaded）</h3><p>在操作系统的视角看，比如Linux中，在进程中创建线程是通过 <strong>clone()</strong> 系统调用来实现，这和创建子进程的区别不大。线程与进程的区别在于同一个进程内的线程共享着进程分配的资源，线程不被分配资源，只是操作系统调度执行任务的抽象的最小单元。</p><p>比如下图中，PID为10的进程P0通过clone()系统调用创建了3个线程，这些线程都可以访问进程分配的内存资源M0。<br><img src="https://raw.githubusercontent.com/cmeng-CM/image-hosting/master/img/theoretical_knowledge/多线程模型.jpeg" alt="多线程模型"></p><h4 id="2-3-1、多线程：通信方式——共享内存通信-Shared-memory-communication"><a href="#2-3-1、多线程：通信方式——共享内存通信-Shared-memory-communication" class="headerlink" title="2.3.1、多线程：通信方式——共享内存通信(Shared memory communication)"></a>2.3.1、多线程：通信方式——共享内存通信(Shared memory communication)</h4><p><strong>共享内存通信(Shared memory communication)</strong> ：不同线程间可以访问同一内存地址空间，并可修改此地址空间的数据。</p><h5 id="同步-Synchronize-访问"><a href="#同步-Synchronize-访问" class="headerlink" title="同步(Synchronize)访问"></a>同步(Synchronize)访问</h5><p>因为线程间共享内存资源，所以在访问临界区域时会出现数据竞争。解决竞态条件的方式是对数据进行 <strong>同步(Synchronize)访问</strong> 。要实现同步访问常见的方式有：</p><pre><code>* **锁(Lock)** ：通过锁定临界区域来实现同步访问。* **信号量(Semaphores)** ：可以通过信号量的增减控制对一个或多个线程对临界区域的访问。* **同步屏障(Barriers)** ：通过设置屏障控制不同线程执行周期实现同步访问。  </code></pre><p><strong>此模型的优点：</strong>  </p><ul><li>大多编程语言都支持此模型；</li><li>贴近硬件架构，使用得当性能很高；</li><li>是其他并发模型的基础；</li></ul><p><strong>此模型的缺点：</strong></p><ul><li>不支持分布式内存模型，只解决了进程内的并发同步；</li><li>不好调试与测试，想用好不容易；    </li></ul><h5 id="STM-Software-transactional-memory"><a href="#STM-Software-transactional-memory" class="headerlink" title="STM(Software transactional memory)"></a>STM(Software transactional memory)</h5><p>STM是用软件的方式去实现事务内存(Transactional memory)，而事务内存中的事务(Transactional)正是关系型数据库中的概念，一个事务必须满足ACID性质，在STM的事务中尽可能避免副作用，比如在事务中去修改原子变量这种操作，可能会导致事务回滚失败。</p><p><strong>此模型的优点：</strong></p><ul><li>相比锁模型更简单；</li><li>大部分情况下更高效；</li></ul><p><strong>此模型的缺点：</strong></p><ul><li>在事务内需要避免产生副作用；</li><li>不支持分布式内存模型，只解决了进程内的并发同步；</li></ul><h4 id="2-3-2、多线程：通信方式——消息传递通信-Message-passing-communication"><a href="#2-3-2、多线程：通信方式——消息传递通信-Message-passing-communication" class="headerlink" title="2.3.2、多线程：通信方式——消息传递通信(Message passing communication)"></a>2.3.2、多线程：通信方式——消息传递通信(Message passing communication)</h4><p><strong>消息传递通信(Message passing communication)</strong> ：不同线程间只能通过收发消息的形式去通信，数据只能被拥有它的线程修改。</p><h5 id="通信顺序进程-CSP-Communicating-sequential-processes"><a href="#通信顺序进程-CSP-Communicating-sequential-processes" class="headerlink" title="通信顺序进程(CSP(Communicating sequential processes))"></a>通信顺序进程(CSP(Communicating sequential processes))</h5><p><strong>CSP</strong>：是一种形式语言，用来描述基于消息传递通信的安全并发模型。各任务模块之间的通信是基于 <strong>通道(Channel)</strong> 来完成的。<strong>通道可以被不同的任务块共享</strong> 。通道两端任务块的通信可以是<strong>同步的，也可以是异步的</strong>。</p><p><strong>此模型的优点：</strong></p><ul><li>相比锁模型更简单；</li><li>很容易实现高并发；</li></ul><p><strong>此模型的缺点：</strong></p><ul><li>不支持分布式内存模型，只解决了进程内的并发同步；</li></ul><h5 id="Actor"><a href="#Actor" class="headerlink" title="Actor"></a>Actor</h5><p><strong>演员模型(Actor)</strong> 是一种类似面向对象编程思想的安全并发模型。Actor模型=数据+行为+消息。Actor模型内部的状态由自己的行为维护，外部线程不能直接调用对象的行为，必须通过消息才能激发行为，这样就保证Actor内部数据只有被自己修改。</p><p>相比CSP模型，Actor模型可以跨节点在 <strong>分布式集群中运行</strong>。实际上Actor模型的代表Erlang正是天然分布式容错的编程语言。</p><p>二者的区别：Actor之间直接通讯，而CSP是通过Channel通讯，在耦合度上两者是有区别的，后者更加松耦合。</p><p><strong>此模型的优点：</strong></p><ul><li>相比锁模型更简单；</li><li>很容易实现高并发；</li><li>支持分布式内存模型，能实现跨节点的并发同步；</li></ul><p><strong>此模型的缺点：</strong></p><ul><li>存在信箱满后消息丢失的问题;</li></ul><h3 id="2-4、事件驱动模型"><a href="#2-4、事件驱动模型" class="headerlink" title="2.4、事件驱动模型"></a>2.4、事件驱动模型</h3><p><strong>事件驱动编程</strong> 是一种编程范式，这里程序的执行流由外部事件来决定。它的特点是包含一个事件循环，当外部事件发生时使用回调机制来触发相应的处理。<br><strong>Event Loop with Multiplexing</strong>：此模型巧妙的利用了系统内核提供的I/O多路复用系统调用，将多个socket连接转换成一个事件队列(event queue)，只需要单个线程即可循环处理这个事件队列。当然这个线程是有可能被阻塞或长期占用的，针对这种类型的任务处理可以单独使用一个线程池去做，这样就不会阻塞Event Loop的线程了。</p><p><strong>此模型的优点：</strong></p><ul><li>单线程对系统资源的占用很小；</li><li>很容易实现高并发；</li></ul><p>此模型的缺点：</p><ul><li>不支持分布式内存模型，只解决了进程内的并发同步；</li></ul><h2 id="三、总结"><a href="#三、总结" class="headerlink" title="三、总结"></a>三、总结</h2><p>高并发的关键在于实现异步非阻塞，更加高效地利用 CPU，涉及的两大安全难题则是<strong>线程安全</strong>与<strong>内存安全</strong>。多线程可以达到非阻塞，但占用资源多，切换开销大。协程用栈的动态增长、用户态的调度来避免多线程的两个问题。事件驱动用单线程的方式，避免了占用太多系统资源，不需要关心线程安全，但无法利用多核。具体要采用哪种模型，还是要看需求。</p><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><p><a href="https://gobomb.github.io/post/high-concurrency-model/">https://gobomb.github.io/post/high-concurrency-model/</a><br><a href="https://www.bmpi.dev/dev/deep-in-program-language/how-to-implement-concurrency/concurrency-model/">https://www.bmpi.dev/dev/deep-in-program-language/how-to-implement-concurrency/concurrency-model/</a>  </p>]]></content>
      
      
      <categories>
          
          <category> 理论知识 </category>
          
          <category> 并发相关 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 并发 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>分库分表</title>
      <link href="/2021/08/18/database/fen-ku-fen-biao/"/>
      <url>/2021/08/18/database/fen-ku-fen-biao/</url>
      
        <content type="html"><![CDATA[<h2 id="一、概述"><a href="#一、概述" class="headerlink" title="一、概述"></a>一、概述</h2><h3 id="1-1、为什么分库？"><a href="#1-1、为什么分库？" class="headerlink" title="1.1、为什么分库？"></a>1.1、为什么分库？</h3><p>分库主要解决并发及磁盘存储的问题。</p><ul><li><strong>并发支撑：</strong> 数据库的连接数是有限，即使能调整也不是无限的。所以并发量一上来，数据库就是服务的瓶颈。<br>所以，当数据库的读或者写的QPS过高，导致你的数据库连接数不足了的时候，就需要考虑分库了，通过增加数据库实例的方式来提供更多的可用数据库链接，从而提升系统的并发度。</li></ul><p><img src="/image/mysql/分库概念图.png" alt="分库概念图">  </p><ul><li><strong>磁盘存储：</strong> 业务量剧增，MySQL单机磁盘容量会撑爆，拆成多个数据库，磁盘使用率大大降低。</li></ul><h3 id="1-2、为什么分表？"><a href="#1-2、为什么分表？" class="headerlink" title="1.2、为什么分表？"></a>1.2、为什么分表？</h3><p>分库主要解决的是并发量大的问题，那分表其实主要解决的是数据量大的问题。</p><p>数据量太大的话，SQL的查询就会变慢。如果一个查询SQL没命中索引，千百万数据量的表可能会拖垮这个数据库。</p><p>一般我们认为，单表行数超过 <strong>500 万行</strong> 或者单表容量超过 <strong>2GB</strong> 之后，才需要考虑做分库分表了，小于这个数据量，遇到性能问题先建议大家通过其他优化来解决。</p><p><img src="/image/mysql/分表概念图.png" alt="分表概念图">  </p><h3 id="1-3、即分库又分表？"><a href="#1-3、即分库又分表？" class="headerlink" title="1.3、即分库又分表？"></a>1.3、即分库又分表？</h3><p>当并发和数据量都起来的时候就需要即分库又分表了。切分就需要考虑怎么分了。分库分表有两种拆分机制：</p><ul><li>水平拆分</li><li>垂直拆分</li></ul><h2 id="二、垂直（纵向）拆分"><a href="#二、垂直（纵向）拆分" class="headerlink" title="二、垂直（纵向）拆分"></a>二、垂直（纵向）拆分</h2><p>垂直拆分有垂直分库和垂直分表两种。</p><h3 id="2-1、垂直分库"><a href="#2-1、垂直分库" class="headerlink" title="2.1、垂直分库"></a>2.1、垂直分库</h3><p><strong>垂直分库：</strong> 就是根据业务耦合性将关联度低的表分别存储在不同的数据，以此来降低各个数据连接数据和磁盘占用。和微服务治理的理念非常相似，每一个独立的服务都拥有自己的数据库，需要不同业务的数据需接口调用。它的核心理念是专库专用。</p><p><img src="/image/mysql/分库概念图.png" alt="垂直分库">  </p><h3 id="2-2、垂直分表"><a href="#2-2、垂直分表" class="headerlink" title="2.2、垂直分表"></a>2.2、垂直分表</h3><p><strong>垂直分表：</strong> 就是将表内字段进行拆分，根据使用情况及关联性，将一张表垂直切割成多张表。每张表留有原表的部分字段，多张表合起来和原表一样。</p><p><img src="/image/mysql/垂直拆分表.png" alt="垂直拆分表"> </p><p>当然，分开的每张表都会保留唯一值字段，一般是主键，也可以是唯一值索引。这样也是为了方便查询命中。</p><h2 id="三、水平拆分"><a href="#三、水平拆分" class="headerlink" title="三、水平拆分"></a>三、水平拆分</h2><p>水平切分分为 <strong>库内分表</strong> 和 <strong>分库分表</strong> ，是根据表内数据内在的逻辑关系，将同一个表按不同的条件分散到多个数据库或多个表中。</p><h3 id="3-1、水平分表"><a href="#3-1、水平分表" class="headerlink" title="3.1、水平分表"></a>3.1、水平分表</h3><p>库内分表：即水平分表，每个表中只包含一部分数据，从而使得单个表的数据量变小，达到分布式的效果。即：每张表结构完全一样，只是数据不一样。<br><img src="/image/mysql/水平拆分表.png" alt="水平拆分表"> </p><h3 id="3-2、水平分库"><a href="#3-2、水平分库" class="headerlink" title="3.2、水平分库"></a>3.2、水平分库</h3><p>分库分表：即水平分库，单表分为多个结构一样且存储在不同的数据库中</p><p><img src="/image/mysql/水平拆分两种模式.png" alt="水平拆分两种模式"> </p><h3 id="3-3、分表策略——Range"><a href="#3-3、分表策略——Range" class="headerlink" title="3.3、分表策略——Range"></a>3.3、分表策略——Range</h3><p><strong>Range</strong>：范围划分，比如按照时间将数据划分为每月一张表。或者根据id范围，如：【1-100000】放一张表，【100001-10000000】放在一张等依次类推。</p><p><img src="/image/mysql/Range分表.png" alt="Range分表"> </p><p><strong>优缺点：</strong></p><ul><li>优点：是自带水平扩展，不需要过多干预。</li><li>缺点：存在热点数据，比如某个月请求暴增。</li></ul><h3 id="3-4、分表策略——mod-hash-mod"><a href="#3-4、分表策略——mod-hash-mod" class="headerlink" title="3.4、分表策略——mod/hash+mod"></a>3.4、分表策略——mod/hash+mod</h3><p><strong>mod</strong>: 取余模式，指定路由的key（一般是id）通过分表的数量进行取余，然后根据余数指定将数据存储入表中。<br><strong>hash+mod</strong>：在取余之前，针对路由的key进行Hash取值，取值后再取余。这种方式与 <strong>HashMap的key</strong> 存储机制类似。</p><p><img src="/image/mysql/mod分表.png" alt="mod分表"> </p><p><strong>分表数量</strong>：具体分表数量要根据业务的实际情况，以及对未来业务发展情况及数据量级增加情况进行划分。此处扩展较为麻烦，比如原数据 <strong>16%4</strong> 分配在表 <strong>union_bill_0</strong> 中，扩展表数量为 <strong>8</strong> 后，数据存储在 <strong>16%8</strong> 表 <strong>union_bill_2</strong> 中，此种方式在扩展表时，需要针对历史数据进行数据迁移。</p><p><strong>优缺点：</strong></p><ul><li>优点：不存在热点数据。</li><li>缺点：不利于水平扩展。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 分库分表 </category>
          
          <category> ShardingSphere </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Database </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>血常规/血分析</title>
      <link href="/2021/08/01/yi-xue-xin-xi/xie-fen-xi-xie-chang-gui/"/>
      <url>/2021/08/01/yi-xue-xin-xi/xie-fen-xi-xie-chang-gui/</url>
      
        <content type="html"><![CDATA[<h2 id="血常规相关指标解读"><a href="#血常规相关指标解读" class="headerlink" title="血常规相关指标解读"></a>血常规相关指标解读</h2><p>  按照每项指标进行解读，单纯的单项指标的意义，不具备临床参考意义。具体病因须整体分析。</p><h3 id="报告示例"><a href="#报告示例" class="headerlink" title="报告示例"></a>报告示例</h3><p><img src="/image/医学信息/血分析.jpg" alt="血分析"></p><h3 id="白细胞（WBC）"><a href="#白细胞（WBC）" class="headerlink" title="白细胞（WBC）"></a>白细胞（WBC）</h3><p>白细胞(white blood cell), 旧称白血球,是血液中一种重要的血细胞。白细胞与红血球，血小板并称三大血细胞。除白细胞外，人体血液中还含有红血球、血小板和血浆。</p><p>白细胞也通常被称为免疫细胞, 作为免疫系统的一部分帮助身体抵抗传染病以及外来的病原。正常情况下白细胞在健康成人体内为4×10^9到10×10^9/每升血液。</p><p>白细胞无色，呈球形，直径在7～20μm之间。白细胞有细胞核，能作变形运动。白细胞一般有活跃的移动能力，它们可以从血管内迁移到血管外，或从血管外组织迁移到血管内。因此, 除了在血液外，白细胞还存在于淋巴系统、脾以及身体的其它组织中。</p><p>由于白细胞的增生失去控制而引起的一种癌症称为“白血病”。</p><h4 id="白细胞意义"><a href="#白细胞意义" class="headerlink" title="白细胞意义"></a>白细胞意义</h4><h5 id="正常值范围"><a href="#正常值范围" class="headerlink" title="正常值范围"></a>正常值范围</h5><ul><li>成人：（4.0-10.0）×10^9个/L</li><li>新生儿：（15-20）×10^9个/L</li><li>6个月到2岁：（11-12）×10^9个/L</li><li>4到14岁：8×10^9个/L</li><li>儿童：（5.0-12.0）×10^9/L<h5 id="临床意义"><a href="#临床意义" class="headerlink" title="临床意义"></a>临床意义</h5>1.升高<br>白细胞计数升高并不完全是疾病的表现，因此有生理性和病理性升高之分。<br>各种细胞感染,炎症,严重烧伤.明显升高时应除外白血病.</li><li>降低：白细胞减少症,脾功能亢进,造血功能障碍,放射线,药物,化学毒素等引起骨髓抑制,疟疾,伤寒,病毒感染,副伤寒.</li></ul>]]></content>
      
      
      <categories>
          
          <category> 化验 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 化验-验血 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/2021/04/15/database/zhi-xing-ji-hua/"/>
      <url>/2021/04/15/database/zhi-xing-ji-hua/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Docker之MySQL安装</title>
      <link href="/2020/08/18/docker/mysql/"/>
      <url>/2020/08/18/docker/mysql/</url>
      
        <content type="html"><![CDATA[<h1 id="docker-安装-mysql"><a href="#docker-安装-mysql" class="headerlink" title="docker 安装 mysql"></a>docker 安装 mysql</h1><h2 id="一、下载镜像"><a href="#一、下载镜像" class="headerlink" title="一、下载镜像"></a>一、下载镜像</h2><p>以最新版为例：<br></p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">docker</span> pull mysql<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><br>下载后通过 <strong>docker images</strong> 查看：<p></p><blockquote><p>REPOSITORY              TAG       IMAGE ID       CREATED        SIZE<br>mysql                   latest    7b94cda7ffc7   2 weeks ago    446MB<br>redis                   latest    7614ae9453d1   8 months ago   113MB</p></blockquote><h2 id="二、启动mysql容器"><a href="#二、启动mysql容器" class="headerlink" title="二、启动mysql容器"></a>二、启动mysql容器</h2><h3 id="2-1、启动"><a href="#2-1、启动" class="headerlink" title="2.1、启动"></a>2.1、启动</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">docker</span> run <span class="token parameter variable">-d</span> <span class="token punctuation">\</span><span class="token parameter variable">--name</span> mysql-2 <span class="token punctuation">\</span><span class="token parameter variable">-p</span> <span class="token number">9000</span>:3306 <span class="token punctuation">\</span><span class="token parameter variable">-e</span> <span class="token assign-left variable">MYSQL_ROOT_PASSWORD</span><span class="token operator">=</span><span class="token number">123456</span> <span class="token punctuation">\</span>mysql:latest<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li><strong>-d</strong>：后台运行</li><li><strong>—name</strong>：设置容器名称</li><li><strong>-p</strong>：将主机的9000端口绑定到容器的3306端口，<strong>-p格式：主机(宿主)端口:容器端口</strong></li><li><strong>-e</strong>：设置root用户密码</li><li><strong>mysql:latest</strong>：指定镜像和版本</li></ul><h3 id="2-2、数据用户密码加密机制"><a href="#2-2、数据用户密码加密机制" class="headerlink" title="2.2、数据用户密码加密机制"></a>2.2、数据用户密码加密机制</h3><p><strong>mysql8及以上</strong>，需要使用navicat链接的话需要修改用户密码的加密方式，该版本有修改：<br></p><pre class="line-numbers language-mysql" data-language="mysql"><code class="language-mysql">ALTER USER 'root'@'%' IDENTIFIED WITH mysql_native_password BY 'password';<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><br>修改后可查看 mysql库下的user表：<p></p><blockquote><p>mysql&gt; select host,user,plugin from user;<br>+—————-+—————————+———————————-+<br>| host      | user             | plugin                |<br>+—————-+—————————+———————————-+<br>| %         | root             | mysql_native_password |<br>| localhost | mysql.infoschema | caching_sha2_password |<br>| localhost | mysql.session    | caching_sha2_password |<br>| localhost | mysql.sys        | caching_sha2_password |<br>+—————-+—————————+———————————-+<br>4 rows in set (0.01 sec)</p></blockquote><h2 id="三、文件挂载"><a href="#三、文件挂载" class="headerlink" title="三、文件挂载"></a>三、文件挂载</h2><p>以为启动容器，但文件及配置信息均在容器内部，为了防止数据丢失可将容器内文件挂在到宿主机上，命令如下：<br></p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token comment"># 将容器中的 mysql 配置文件复制到宿主机中指定路径下，路径你可以根据需要，自行修改</span><span class="token function">docker</span> <span class="token function">cp</span> mysql:/etc/mysql/mysql.conf.d/mysqld.cnf /usr/local/docker/mysql/config<span class="token comment"># 将容器中的 mysql 存储目录复制到宿主机中</span><span class="token function">docker</span> <span class="token function">cp</span> mysql:/var/lib/mysql/ /usr/local/docker/mysql/data<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p></p><p>总和挂在一起创建及启动容器的命令如下：<br></p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">docker</span> run <span class="token parameter variable">-d</span> <span class="token punctuation">\</span><span class="token parameter variable">--name</span> mysql <span class="token punctuation">\</span><span class="token parameter variable">-p</span> <span class="token number">3306</span>:3306 <span class="token punctuation">\</span><span class="token parameter variable">-v</span> /usr/local/docker/mysql/config/mysqld.cnf:/etc/mysql/mysql.conf.d/mysqld.cnf <span class="token punctuation">\</span><span class="token parameter variable">-v</span> /usr/local/docker/mysql/data/mysql:/var/lib/mysql <span class="token punctuation">\</span><span class="token parameter variable">-e</span> <span class="token assign-left variable">MYSQL_ROOT_PASSWORD</span><span class="token operator">=</span><span class="token number">123456</span> <span class="token punctuation">\</span>mysql:latest<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><br>其余命令不变，多了两个 <strong>-v</strong> 参数用于文件挂载。<br>后续即可直接使用数据库。<p></p><h2 id="MySQL配置文件"><a href="#MySQL配置文件" class="headerlink" title="MySQL配置文件"></a>MySQL配置文件</h2><p>通过 <strong>mysql —help</strong> 可以获得以下描述：</p><blockquote><p>Default options are read from the following files in the given order:<br>/etc/my.cnf /etc/mysql/my.cnf /usr/etc/my.cnf ~/.my.cnf</p></blockquote><p><strong>/etc/my.cnf</strong> 文件结尾处：<br></p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token operator">!</span>includedir /etc/mysql/conf.d/<span class="token operator">!</span>includedir /etc/mysql/mysql.conf.d/<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p></p><p>所以几处的配置文件按照顺序都会加载到mysql中，所以只需求一处即可，因此本文挂载文件为：<strong>/etc/mysql/mysql.conf.d/mysqld.cnf</strong></p>]]></content>
      
      
      <categories>
          
          <category> docker </category>
          
          <category> mysql </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MySQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>docker日常命令</title>
      <link href="/2020/08/18/docker/ri-chang-ming-ling/"/>
      <url>/2020/08/18/docker/ri-chang-ming-ling/</url>
      
        <content type="html"><![CDATA[<h3 id="容器挂载文件相关"><a href="#容器挂载文件相关" class="headerlink" title="容器挂载文件相关"></a>容器挂载文件相关</h3><ol><li>查看容器挂的文件信息：<ul><li>命令：docker inspect containerID | grep Source -A 1</li><li>结果：<blockquote><p>“Source”: “/Users/workerspace/mysql/mysql2/mysql”,<br>“Destination”: “/var/lib/mysql”,</p><p>“Source”: “/host_mnt/Users/workerspace/mysql/mysql2/mysqld.cnf”,<br>“Destination”: “/etc/mysql/mysql.conf.d/mysqld.cnf”,</p></blockquote></li></ul></li></ol>]]></content>
      
      
      <categories>
          
          <category> Docker </category>
          
      </categories>
      
      
        <tags>
            
            <tag> command </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MySQL主从、主主、主备模式</title>
      <link href="/2020/08/18/database/master-slave-sync/"/>
      <url>/2020/08/18/database/master-slave-sync/</url>
      
        <content type="html"><![CDATA[<h2 id="一、主从、主主、主备模式介绍"><a href="#一、主从、主主、主备模式介绍" class="headerlink" title="一、主从、主主、主备模式介绍"></a>一、主从、主主、主备模式介绍</h2><p><img src="/image/mysql/MySQL主主、主从、主备、单点模型.png" alt="主从、主主、主备模式">  </p><p>主从、主主、主备的基层逻辑都是数据的同步，而主从则将相关的数据同步机制全涉及，所以数据同步逻辑以解析主从逻辑为主。</p><p><strong>mysql主从配置分为三种模式，分别是：</strong></p><ul><li>异步复制（Asynchronous replication）：即使用二进制日志文件进行异步操作。master在执行完事后会直接给返回客户端，不考虑从库同步是否完成，从库的同步操做是通过异步线程读取二进制日志文件完成的。</li><li>全同步复制（Fully synchronous replication）：指当主库执行完一个事务，所有的从库都执行了该事务才返回给客户端。因为需要等待所有从库执行完该事务才能返回，所以全同步复制的性能必然会收到严重的影响。</li><li>半同步复制（Semisynchronous replication）：介于异步复制和全同步复制之间，主库在执行完客户端提交的事务后不是立刻返回给客户端，而是等待至少一个从库接收到并写到relay log中才返回给客户端。相对于异步复制，半同步复制提高了数据的安全性，同时它也造成了一定程度的延迟，这个延迟最少是一个TCP/IP往返的时间。所以，半同步复制最好在低延时的网络中使用。</li></ul><h2 id="二、主从同步——异步复制（Asynchronous-replication）"><a href="#二、主从同步——异步复制（Asynchronous-replication）" class="headerlink" title="二、主从同步——异步复制（Asynchronous replication）"></a>二、主从同步——异步复制（Asynchronous replication）</h2><h3 id="2-1、异步复制——原理"><a href="#2-1、异步复制——原理" class="headerlink" title="2.1、异步复制——原理"></a>2.1、异步复制——原理</h3><h4 id="2-1-1、复制线程"><a href="#2-1-1、复制线程" class="headerlink" title="2.1.1、复制线程"></a>2.1.1、复制线程</h4><p>MySQL 复制功能使用三个主线程实现，一个在源服务器上，两个在副本上：</p><ul><li><p><strong>二进制日志转储线程（Binary log dump thread）</strong>：当副本连接时，源创建一个线程以将二进制日志内容发送到副本。该线程可以在 <strong>SHOW PROCESSLIST</strong> 源上的输出中标识为该Binlog Dump线程。<br>二进制日志转储线程获取源二进制日志上的锁，以读取要发送到副本的每个事件。一旦事件被读取，锁就会被释放，甚至在事件被发送到副本之前。<br>具备多个从库的主库会为每个链接到主库的从库创建一个Binary log dump thread。</p></li><li><p><strong>复制 I/O 线程（Replication I/O thread）</strong>：当 <strong>START SLAVE</strong> 在副本服务器上发出语句时，副本会创建一个 I/O 线程，该线程连接到源并要求它发送记录在其二进制日志中的更新。<br>复制 I/O 线程读取源 Binlog Dump线程发送的更新（参见上一项）并将它们复制到组成 <strong>副本中继日志的本地文件中</strong>。<br>该线程的状态：可以通过<strong>SHOW SLAVE STATUS</strong>语句查询 <strong>Slave_IO_running</strong>字段的状态值。</p></li><li><p><strong>复制 SQL 线程（Replication SQL thread）</strong>。  副本创建一个 SQL 线程来读取由复制 I/O 线程写入的中继日志并执行其中包含的事务。</p></li></ul><h4 id="2-1-2、主从复制流程图"><a href="#2-1-2、主从复制流程图" class="headerlink" title="2.1.2、主从复制流程图"></a>2.1.2、主从复制流程图</h4><p><img src="/image/mysql/主从同步流程图.jpeg" alt="主从复制流程图"> </p><h3 id="2-2、异步复制——配置"><a href="#2-2、异步复制——配置" class="headerlink" title="2.2、异步复制——配置"></a>2.2、异步复制——配置</h3><h4 id="2-2-1、编码值设置"><a href="#2-2-1、编码值设置" class="headerlink" title="2.2.1、编码值设置"></a>2.2.1、编码值设置</h4><p>主从同步或多数据源同步时，一定要保证多个数据的编码值一致，否则在同步阶段会出现乱码，甚至无法解析的情况。编码设置如下：<br></p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token comment"># mysqld.cnf</span><span class="token punctuation">[</span>client<span class="token punctuation">]</span><span class="token comment"># 客户端设置</span><span class="token assign-left variable">default_character_set</span><span class="token operator">=</span>utf8mb4<span class="token punctuation">[</span>mysqld<span class="token punctuation">]</span><span class="token comment"># 服务端设置</span>default-storage-engine<span class="token operator">=</span>INNODBcharacter-set-server<span class="token operator">=</span>utf8mb4collation-server<span class="token operator">=</span>utf8mb4_general_ci<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><br>主从库均需要设置编码。<p></p><h4 id="2-2-2、主库配置"><a href="#2-2-2、主库配置" class="headerlink" title="2.2.2、主库配置"></a>2.2.2、主库配置</h4><p><strong>主库设置分为：server-id设置、二进制日志设置、同步用户设置等三部。</strong></p><h5 id="1-服务ID"><a href="#1-服务ID" class="headerlink" title="1. 服务ID"></a>1. 服务ID</h5><p>要将源配置为使用基于二进制日志文件位置的复制，必须确保启用二进制日志记录，并建立唯一的服务ID。并且必须是介于 1 和 (2 32 )-1 之间的正整数。<br>使用默认服务器 ID 为 0，且拒绝来自副本的任何连接，所以必须保证服务ID各个数据库服务不重复且大于0。配置如下：<br></p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token comment"># 服务唯一ID</span>server-id<span class="token operator">=</span><span class="token number">9000</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p></p><h5 id="2-二进制日志（binlog）"><a href="#2-二进制日志（binlog）" class="headerlink" title="2. 二进制日志（binlog）"></a>2. 二进制日志（binlog）</h5><h6 id="日志格式"><a href="#日志格式" class="headerlink" title="日志格式"></a><strong>日志格式</strong></h6><p><strong>binlog日志</strong>：数据库每提交一次事务，都会把数据变更，记录到一个二进制文件中，这个二进制文件就叫binlog。需注意：只有写操作才会记录至binlog，只读操作是不会的（如select、show语句）。<br><strong>binlog的3种格式：</strong><br><strong>1. statement格式：</strong> <strong>MySQL</strong> 中的复制功能最初是基于 <strong>SQL</strong> 语句从源到副本的传播，即记录的是实际执行的sql语句。这称为 <strong>基于语句的日志记录</strong>。</p><ul><li>优点：<ul><li>成熟的技术</li><li>写入日志文件的数据更少。当更新或删除影响许多行时，这会导致 日志文件所需的存储空间大大减少。</li><li>日志文件包含进行任何更改的所有语句，因此它们可用于审计数据库。</li></ul></li><li>缺点：<ul><li>对 SBR 不安全的语句。</li><li><strong>INSERT … SELECT</strong> 与基于行的复制相比，它需要更多的行级锁。</li><li><strong>UPDATE</strong> 需要表扫描的语句（因为 WHERE子句中没有使用索引）必须锁定比基于行的复制更多的行。</li><li>For InnoDB： INSERT使用 AUTO_INCREMENT阻塞其他非冲突语句的INSERT 语句。</li><li>对于复杂的语句，在更新或插入行之前，必须在副本上评估和执行该语句。使用基于行的复制，副本只需要修改受影响的行，而不是执行完整的语句。</li><li>如果对副本的评估存在错误，尤其是在执行复杂语句时，基于语句的复制可能会随着时间的推移慢慢增加受影响行的误差幅度。</li><li>存储函数以与 NOW()调用语句相同的值执行。但是，存储过程并非如此。</li><li>确定性可加载函数必须应用于副本。</li><li>表定义在源和副本上必须（几乎）相同。</li></ul></li></ul><p><strong>2. row格式：</strong> binlog记录的是变化前后的数据（涉及所有列），例如update table_a set col1=value1, col2=value2 … where col1=condition1 and col2=condition2 …，这称为 <strong>基于行的日志记录</strong>。</p><ul><li>优点：<ul><li>所有更改都可以复制。这是最安全的复制形式。</li><li>INSERT对于任何、UPDATE或 DELETE语句，副本上需要的行锁更少。</li><li>对于以下类型的语句，源上需要更少的行锁，从而实现更高的并发性：<ul><li>INSERT … SELECT</li><li>INSERT与声明 AUTO_INCREMENT</li><li>UPDATE或 带有不使用键或不更改大多数检查行的子句的 DELETE语句 。WHERE</li></ul></li></ul></li><li>缺点：<ul><li><strong>RBR</strong> 可以生成更多必须记录的数据。</li><li>生成大  <strong>BLOB</strong> 值的确定性可加载函数使用基于行的复制进行复制比使用基于语句的复制花费更长的间。这是因为 BLOB记录的是列值，而不是生成数据的语句。</li><li>无法在副本上看到从源接收并执行了哪些语句。</li><li>对于使用存储引擎的表，与将它们作为语句应用时相比，将它们作为基于行的事件应用到二进制日志时，语句<strong>MyISAM</strong>的副本需要更强的锁定。INSERT这意味着MyISAM在使用基于行的复制时不支持对表进行并发插入。</li></ul></li></ul><p><strong>3. mixed格式</strong>：默认选择statement格式，只在需要时改用row格式。这称为 <strong>混合日志记录</strong>。</p><p><strong>为获取前后变化的数据，建议使用 <font color="red">基于行的日志记录</font>，具体配置信息如下：</strong><br></p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>mysqld<span class="token punctuation">]</span><span class="token comment"># 配置bin-log信息</span><span class="token comment"># 日志文件名</span>log-bin<span class="token operator">=</span>master-binlog_bin_index <span class="token operator">=</span> master-bin.index<span class="token comment"># 日志格式</span><span class="token assign-left variable">binlog_format</span><span class="token operator">=</span>row<span class="token comment"># 日志保存天数</span>expire-logs-days<span class="token operator">=</span><span class="token number">7</span><span class="token comment"># 从 mysql 8.0.x 引进的，单位：秒</span><span class="token comment"># binlog_expire_logs_seconds=2592000</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p></p><h6 id="同步过滤"><a href="#同步过滤" class="headerlink" title="同步过滤"></a><strong>同步过滤</strong></h6><p>基于业务情况，我们的数据库中并不是所有的库都需要进行复制同步。所以在开启同步前需要指定哪些库是需要进行同步操作的，即同步过滤。同步过滤有两种方式可以设置，分别是直接指定过滤库以及通过指定库记录二进制日志的方式，两种方式情况如下：</p><ul><li>指定复制库方式<ul><li>同步：<strong>replicate-do-db=db_name</strong></li><li>不同步：<strong>replicate-ignore-db=db_name</strong></li></ul></li><li>记录二进制方式：<ul><li>加入记录即同步：<strong>binlog-do-db=db_name</strong></li><li>不加入记录即不同步：<strong>binlog-ignore-db=db_name</strong></li></ul></li></ul><p><strong>两种方式区别：</strong></p><ul><li>相同点：都可以达到过滤的目的；可每个库需单独配置，可配置多个</li><li>不同点：针对日志的解析和复制有细微区别，详细可查看 <a href="https://dev.mysql.com/doc/refman/5.7/en/replication-options-binary-log.html#replication-optvars-binlog">二进制日志记录选项和变量</a></li></ul><p>配置示例：<br></p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>mysqld<span class="token punctuation">]</span><span class="token comment"># 需要同步的数据库</span>binlog-do-db<span class="token operator">=</span>test_sync<span class="token comment"># 不需要同步的库</span>binlog-ignore-db<span class="token operator">=</span>mysqlbinlog-ignore-db<span class="token operator">=</span>sysbinlog-ignore-db<span class="token operator">=</span>information_schemabinlog-ignore-db<span class="token operator">=</span>performance_schema<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p></p><h5 id="3-为复制创建用户"><a href="#3-为复制创建用户" class="headerlink" title="3. 为复制创建用户"></a>3. 为复制创建用户</h5><p>每个从库都需要用于读取master库日志的账户信息，前提是它已被授予 <strong>REPLICATION SLAVE</strong> 特权。虽然可以直接使用root用户，但还是建议单独创建一个独立用户用于从库同步，因为 <strong>复制用户名和密码以纯文本形式存储在复制元数据存储库（slave的mysql.slave_master_info表）中</strong>。<br>创建用户示例：如果只是为了同步数据，该账户只需要 <strong>REPLICATION SLAVE</strong> 权限即可<br></p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">CREATE</span> <span class="token keyword">USER</span> <span class="token string">'slave_read'</span><span class="token variable">@'%'</span> IDENTIFIED <span class="token keyword">BY</span> <span class="token string">'password'</span><span class="token punctuation">;</span><span class="token keyword">GRANT</span> <span class="token keyword">REPLICATION</span> SLAVE <span class="token keyword">ON</span> <span class="token operator">*</span><span class="token punctuation">.</span><span class="token operator">*</span> <span class="token keyword">TO</span> <span class="token string">'slave_read'</span><span class="token variable">@'%'</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p></p><h4 id="2-2-3、从库及同步机制配置"><a href="#2-2-3、从库及同步机制配置" class="headerlink" title="2.2.3、从库及同步机制配置"></a>2.2.3、从库及同步机制配置</h4><p>主库设置好之后，进入从库配置及主从同步机制配置</p><h5 id="1-设置从库配置"><a href="#1-设置从库配置" class="headerlink" title="1. 设置从库配置"></a>1. 设置从库配置</h5><ul><li>编码设置</li><li>服务ID：设置服务ID，原因同主库。</li><li>日志：副本不需要启用二进制日志记录以进行复制。但是，副本上的二进制日志记录意味着副本的二进制日志可用于数据备份和崩溃恢复。启用了二进制日志记录的副本也可以用作更复杂的复制拓扑的一部分。</li><li>配置如下：<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token comment"># 客户端设置编码字符集为UTF8mb4</span><span class="token punctuation">[</span>client<span class="token punctuation">]</span><span class="token assign-left variable">default_character_set</span><span class="token operator">=</span>utf8mb4<span class="token punctuation">[</span>mysqld<span class="token punctuation">]</span><span class="token comment"># 服务端设置编码</span>default-storage-engine<span class="token operator">=</span>INNODBcharacter-set-server<span class="token operator">=</span>utf8mb4collation-server<span class="token operator">=</span>utf8mb4_general_ci<span class="token comment"># 服务唯一ID</span>server-id<span class="token operator">=</span><span class="token number">9001</span><span class="token comment"># 配置bin-log信息</span><span class="token comment"># 日志文件名</span>log-bin<span class="token operator">=</span>slave-bin<span class="token assign-left variable">log_bin_index</span><span class="token operator">=</span>slave-bin.index<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ul><h5 id="2-从库设置主库链接信息"><a href="#2-从库设置主库链接信息" class="headerlink" title="2. 从库设置主库链接信息"></a>2. 从库设置主库链接信息</h5><p>要将从库设置为与主库通信，则要进行必要的连接信息配置，主要分为三个模块：</p><ul><li>主库ip，port等信息</li><li>主库用户同步的账户信息</li><li>二进制相关信息。</li></ul><p>主库ip、port和账户信息在上面已经获取或配置好，下面获取主库的二进制日志相关的信息，获取脚本如下：<br></p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">SHOW</span> MASTER <span class="token keyword">STATUS</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p></p><p><strong>查询结果如下：</strong>   </p><div class="table-container"><table><thead><tr><th style="text-align:left">File</th><th style="text-align:left">Position</th><th style="text-align:left">Binlog_Do_DB</th><th style="text-align:left">Binlog_Ignore_DB</th></tr></thead><tbody><tr><td style="text-align:left">master-bin.000001</td><td style="text-align:left">86</td><td style="text-align:left">cm_sync</td><td style="text-align:left">mysql,sys,information_schema,performance_schema</td></tr></tbody></table></div><ul><li>File：显示日志文件的名称，表格中二进制日志文件是mysql-bin.000001</li><li>Position：显示文件中的位置。表格中位置是位置是 86</li><li>Binlog_Do_DB：启用二进制日志的库</li><li>Binlog_Ignore_DB：未启用二进制日志的库</li></ul><p><strong>File和Position</strong> 稍后在设置副本时需要它们。它们表示副本应该开始处理来自源的新更新的复制坐标。</p><p>通过 <strong>CHANGE MASTER TO</strong> （更多信息请查看官方文档：<a href="https://dev.mysql.com/doc/refman/5.7/en/change-master-to.html">CHANGE MASTER TO 语句</a>）语句进行设置，登录MySQL数据，执行以下Sql：<br></p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql">mysql<span class="token operator">&gt;</span> CHANGE MASTER <span class="token keyword">TO</span> MASTER_HOST <span class="token operator">=</span> <span class="token string">'172.17.0.2'</span><span class="token punctuation">,</span>    MASTER_USER <span class="token operator">=</span> <span class="token string">'slave_read'</span><span class="token punctuation">,</span>    MASTER_PASSWORD <span class="token operator">=</span> <span class="token string">'123456'</span><span class="token punctuation">,</span>    MASTER_PORT <span class="token operator">=</span> <span class="token number">3306</span><span class="token punctuation">,</span>    MASTER_LOG_FILE <span class="token operator">=</span> <span class="token string">'master-bin.000001'</span><span class="token punctuation">,</span>    MASTER_LOG_POS <span class="token operator">=</span> <span class="token number">86</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p></p><p><strong>此处只使用几个常用参数：</strong></p><div class="table-container"><table><thead><tr><th style="text-align:left">参数</th><th style="text-align:left">含义</th><th style="text-align:left">最大长度</th></tr></thead><tbody><tr><td style="text-align:left">MASTER_HOST</td><td style="text-align:left">主库IP</td><td style="text-align:left">60</td></tr><tr><td style="text-align:left">MASTER_USER</td><td style="text-align:left">用于连接主库的用户</td><td style="text-align:left">96</td></tr><tr><td style="text-align:left">MASTER_PASSWORD</td><td style="text-align:left">用于连接主库的密码</td><td style="text-align:left">32</td></tr><tr><td style="text-align:left">MASTER_PORT</td><td style="text-align:left">主库端口</td><td style="text-align:left"></td></tr><tr><td style="text-align:left">MASTER_LOG_FILE</td><td style="text-align:left">日志文件名称</td><td style="text-align:left">511</td></tr><tr><td style="text-align:left">MASTER_LOG_POS</td><td style="text-align:left">日志文件中的位置</td><td style="text-align:left"></td></tr></tbody></table></div><blockquote><p>注：如果使用docker部署mysql，则ip为容器的ip，端口为容器内部mysql端口。MASTER_LOG_POS参数一定要与主库查询出来的结果一致，否则无法同步。</p></blockquote><h5 id="3-新的主库和从库配置"><a href="#3-新的主库和从库配置" class="headerlink" title="3. 新的主库和从库配置"></a>3. 新的主库和从库配置</h5><p>无历史数据，全新的主库和从库，上面两步配置完毕后，直接启动复制线程：<br></p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql">mysql<span class="token operator">&gt;</span> <span class="token keyword">START</span> SLAVE<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><br>执行此过程后，从库将连接到主库并复制自拍摄快照以来在主库上发生的任何更新。<p></p><h5 id="4-使用现有数据设置复制"><a href="#4-使用现有数据设置复制" class="headerlink" title="4. 使用现有数据设置复制"></a>4. 使用现有数据设置复制</h5><p>针对已有数据的主库，主从启动之前需要先将主库数据通过快照方式导入从库，以便数据同步。<br>步骤如下：</p><ul><li><p>1、先锁定主库，以防止数据新增遗漏</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql">mysql<span class="token operator">&gt;</span> FLUSH <span class="token keyword">TABLES</span> <span class="token keyword">WITH</span> <span class="token keyword">READ</span> <span class="token keyword">LOCK</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><blockquote><p>1、此过程使用FLUSH TABLES WITH READ LOCK, 阻止 表COMMIT的操作 InnoDB。<br>2、 FLUSH TABLES语句的客户端保持运行，以便读取锁保持有效。如果退出客户端，锁就会被释放。</p></blockquote></li><li><p>2、创建数据快照</p><ul><li>使用 <strong><a href="https://dev.mysql.com/doc/refman/5.7/en/mysqldump.html">mysqldump</a></strong> 创建数据快照：<pre class="line-numbers language-sql" data-language="sql"><code class="language-sql">mysqldump <span class="token comment">--all-databases --master-data &gt; dbdump.db</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li>使用原始数据文件创建数据快照</li></ul></li><li><p>3、重新启动源服务器。</p></li><li>4、在从库导入快照数据</li><li>5、启动复制线程</li><li>6、解锁<pre class="line-numbers language-sql" data-language="sql"><code class="language-sql">mysql<span class="token operator">&gt;</span> <span class="token keyword">UNLOCK</span> <span class="token keyword">TABLES</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li></ul><h5 id="5-将新的从库添加到复制拓扑"><a href="#5-将新的从库添加到复制拓扑" class="headerlink" title="5. 将新的从库添加到复制拓扑"></a>5. 将新的从库添加到复制拓扑</h5><p>可以在不停止源服务器的情况下将另一个副本添加到现有复制配置。方式为通过复制现有副本的数据目录来设置新副本，并为新副本提供不同的 <strong>服务器 ID（由用户指定）</strong>和 <strong>服务器 UUID（在启动时生成）</strong>。</p><ul><li><p>1、停止现有副本并记录副本状态信息，特别是源的二进制日志文件和中继日志文件位置。</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql">mysql<span class="token operator">&gt;</span> STOP SLAVE<span class="token punctuation">;</span>mysql<span class="token operator">&gt;</span> <span class="token keyword">SHOW</span> SLAVE <span class="token keyword">STATUS</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></li><li><p>2、关闭现有副本</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql">$<span class="token operator">&gt;</span> mysqladmin <span class="token keyword">shutdown</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li><p>3、将现有副本的数据目录复制到新副本，包括日志文件和中继日志文件。可以通过使用tar或创建存档来执行此操作 ，或者使用cp或rsyncWinZip等工具执行直接复制 。</p><ul><li>在复制之前，请验证与现有副本相关的所有文件实际上都存储在数据目录中。例如，InnoDB 系统表空间、撤消表空间和重做日志可能存储在其他位置。</li><li>在复制期间，如果文件已用于复制元数据存储库，确保还将这些文件从现有副本复制到新副本。如果表已用于存储库，则表位于数据目录中。</li><li>复制后，从新副本上的数据目录副本中删除该 auto.cnf文件，以便新副本以不同的生成服务器 UUID 启动。服务器 UUID 必须是唯一的。</li></ul></li><li><p>4、复制完成后，重新启动现有副本。</p></li><li><p>5、在新副本上，编辑配置并为新副本提供唯一的服务器 ID（使用 server_id系统变量），源或任何现有副本均未使用该 ID。</p></li><li><p>6、启动新的副本服务器，指定 —skip-slave-start选项以便复制尚未开始。使用性能模式复制表或问题SHOW SLAVE STATUS来确认新副本与现有副本相比具有正确的设置。还要显示服务器 ID 和服务器 UUID，并验证这些对于新副本是否正确且唯一。</p></li><li>7、通过发出一条 <strong>START SLAVE</strong> 语句来启动复制线程。</li></ul><h4 id="2-2-4、从库状态查询"><a href="#2-2-4、从库状态查询" class="headerlink" title="2.2.4、从库状态查询"></a>2.2.4、从库状态查询</h4><p>异步复制线程开启后，查看从库的相关状态：<br></p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql">mysql<span class="token operator">&gt;</span> <span class="token keyword">SHOW</span> SLAVE <span class="token keyword">STATUS</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><br><strong>结果中关键字段是：</strong><p></p><ul><li>Slave_IO_State：副本的当前状态。</li><li>Slave_IO_Running: 读取源二进制日志的I/O线程是否正在运行。执行完 <strong>START SLAVE</strong> 后为 <strong>Yes</strong>。</li><li>Slave_SQL_Running：用于执行中继日志中事件的SQL线程是否正在运行。与 I/O 线程一样，执行完 <strong>START SLAVE</strong> 后为 <strong>Yes</strong>。</li><li>Last_IO_Error, Last_SQL_Error: I/O 和 SQL 线程在处理中继日志时注册的最后一个错误。理想情况下，这些应该是空白的，表示没有错误。</li><li>Seconds_Behind_Master：复制 SQL 线程在处理源的二进制日志之后的秒数。较大的数字（或增加的数字）可能表明副本无法及时处理来自源的事件。</li></ul><p>在主库上进行状态查询的语句有：</p><ul><li><strong>SHOW PROCESSLIST</strong>：用于检查正在运行的进程列表。</li><li><strong>SHOW SLAVE HOSTS</strong>：显示有关副本的基本信息。</li></ul><h4 id="2-2-5、配置汇总"><a href="#2-2-5、配置汇总" class="headerlink" title="2.2.5、配置汇总"></a>2.2.5、配置汇总</h4><p><strong>主库配置</strong><br></p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token comment"># mysqld.cnf</span><span class="token punctuation">[</span>client<span class="token punctuation">]</span><span class="token comment"># 客户端设置编码字符集为UTF8mb4</span><span class="token assign-left variable">default_character_set</span><span class="token operator">=</span>utf8mb4<span class="token punctuation">[</span>mysqld<span class="token punctuation">]</span><span class="token comment"># 服务端设置编码</span>default-storage-engine<span class="token operator">=</span>INNODBcharacter-set-server<span class="token operator">=</span>utf8mb4collation-server<span class="token operator">=</span>utf8mb4_general_ci<span class="token comment"># 服务唯一ID</span>server-id<span class="token operator">=</span><span class="token number">9000</span><span class="token comment"># 配置bin-log信息</span><span class="token comment"># 日志文件名</span>log-bin<span class="token operator">=</span>master-binlog_bin_index <span class="token operator">=</span> master-bin.index<span class="token comment"># 日志格式</span><span class="token assign-left variable">binlog_format</span><span class="token operator">=</span>row<span class="token comment"># 日志保存天数</span>expire-logs-days<span class="token operator">=</span><span class="token number">7</span><span class="token comment"># 需要同步的数据库</span><span class="token comment">#binlog-do-db=cm_sync</span><span class="token comment"># 不需要同步的库</span>binlog-ignore-db<span class="token operator">=</span>mysqlbinlog-ignore-db<span class="token operator">=</span>sysbinlog-ignore-db<span class="token operator">=</span>information_schemabinlog-ignore-db<span class="token operator">=</span>performance_schema<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p></p><p><strong>从库配置</strong><br></p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token comment"># mysqld.cnf</span><span class="token comment"># 客户端设置编码字符集为UTF8mb4</span><span class="token punctuation">[</span>client<span class="token punctuation">]</span><span class="token assign-left variable">default_character_set</span><span class="token operator">=</span>utf8mb4<span class="token punctuation">[</span>mysqld<span class="token punctuation">]</span><span class="token comment"># 服务端设置编码</span>default-storage-engine<span class="token operator">=</span>INNODBcharacter-set-server<span class="token operator">=</span>utf8mb4collation-server<span class="token operator">=</span>utf8mb4_general_ci<span class="token comment"># 服务唯一ID</span>server-id<span class="token operator">=</span><span class="token number">9001</span><span class="token comment"># 配置bin-log信息</span><span class="token comment"># 日志文件名</span>log-bin<span class="token operator">=</span>slave-bin<span class="token assign-left variable">log_bin_index</span><span class="token operator">=</span>slave-bin.index<span class="token assign-left variable">relay_log</span><span class="token operator">=</span>slave-relay-bin<span class="token assign-left variable">read_only</span><span class="token operator">=</span><span class="token number">1</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p></p><h3 id="2-3、强一致性——GTID"><a href="#2-3、强一致性——GTID" class="headerlink" title="2.3、强一致性——GTID"></a>2.3、强一致性——GTID</h3><h4 id="2-3-1、GTID"><a href="#2-3-1、GTID" class="headerlink" title="2.3.1、GTID"></a>2.3.1、GTID</h4><p>GTID：<strong>全局事务标识符</strong> 是在源服务器（master）上创建并与提交的每个事务相关联的唯一标识符。这个标识符不仅对于它起源的服务器是唯一的，而且在给定的复制拓扑中的所有服务器中都是唯一的。<br>针对GTID相关操作可以分为两部分：</p><ul><li>客户端事务在master上提交：提交时它会被分配一个新的 GTID，前提是该事务已写入二进制日志。保证客户端事务具有单调递增的 GTID，生成的数字之间没有间隙。如果客户端事务没有写入二进制日志（例如，因为事务被过滤掉，或者事务是只读的），则不会在源服务器上为其分配 GTID。</li><li>同步复制事务：从库会根据主库日志中各个GTID对应的事务操作进行数据同步操作，且在主库上提交的事务只能在副本上应用一次，这有助于保证一致性。</li></ul><h5 id="GTID组成"><a href="#GTID组成" class="headerlink" title="GTID组成"></a>GTID组成</h5><p>GTID 表示为一对坐标，由冒号字符 ( : ) 分隔，如下所示：</p><blockquote><p>GTID = source_id:transaction_id</p></blockquote><p><strong>source_id</strong>：标识始发服务器 。通常，源 server_uuid用于此目的。<br><strong>transaction_id</strong>：是一个序列号，由在源上提交事务的顺序确定。其实就是一个自增序列，从1递增。</p><p>MySQL 系统表 <strong>mysql.gtid_executed</strong> 用于保存在 MySQL 服务器上应用的所有事务的分配 GTID，但存储在当前活动的二进制日志文件中的事务除外。</p><h4 id="2-3-2、使用-GTID-设置复制"><a href="#2-3-2、使用-GTID-设置复制" class="headerlink" title="2.3.2、使用 GTID 设置复制"></a>2.3.2、使用 GTID 设置复制</h4><p><strong>GTID</strong> 模式是基于开启二进制服务的基础上进行的，下面操作步骤均已 <strong>开启二进制日志为前提</strong>。</p><h5 id="1、同步服务器"><a href="#1、同步服务器" class="headerlink" title="1、同步服务器"></a>1、同步服务器</h5><p>将mysql服务设置为只读，保证操作期间无数据丢失。<br></p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql">mysql<span class="token operator">&gt;</span> <span class="token keyword">SET</span> @<span class="token variable">@GLOBAL.read_only</span> <span class="token operator">=</span> <span class="token keyword">ON</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p></p><p>等待所有正在进行的事务提交或回滚。然后，让副本赶上源。在继续之前确保副本已处理所有更新非常重要。</p><p>如果是新服务则直接从第三步开始</p><h5 id="2、停止所有服务器"><a href="#2、停止所有服务器" class="headerlink" title="2、停止所有服务器"></a>2、停止所有服务器</h5><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$<span class="token operator">&gt;</span>  mysqladmin <span class="token parameter variable">-uusername</span> <span class="token parameter variable">-p</span> <span class="token function">shutdown</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h5 id="3、开启主库和从库的GTID设置"><a href="#3、开启主库和从库的GTID设置" class="headerlink" title="3、开启主库和从库的GTID设置"></a>3、开启主库和从库的GTID设置</h5><p>开启方式增加配置文件：<br></p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>mysqld<span class="token punctuation">]</span><span class="token assign-left variable">gtid_mode</span><span class="token operator">=</span>ONenforce-gtid-consistency<span class="token operator">=</span>ON<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><br>主库和从库均需设置，设置后重启mysql服务。<p></p><h5 id="4、将副本配置为使用基于-GTID-的自动定位"><a href="#4、将副本配置为使用基于-GTID-的自动定位" class="headerlink" title="4、将副本配置为使用基于 GTID 的自动定位"></a>4、将副本配置为使用基于 GTID 的自动定位</h5><p>在副本上发出一条 <strong>CHANGE MASTER TO</strong> 语句，包括 <strong>MASTER_AUTO_POSITION</strong> 在语句中告诉副本源的事务由 GTID 标识的选项。如果除 <strong>MASTER_AUTO_POSITION</strong> 参数外其它参数均已设置，则可以不进行重复设置。</p><blockquote><font color="red">MASTER_LOG_FILE选项和 选项 都MASTER_LOG_POS不能与 MASTER_AUTO_POSITION=1 一起使用。尝试这样做会导致CHANGE MASTER TO语句失败并出现错误。</font></blockquote><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql">mysql<span class="token operator">&gt;</span> CHANGE MASTER <span class="token keyword">TO</span>     <span class="token operator">&gt;</span>     MASTER_HOST <span class="token operator">=</span> host<span class="token punctuation">,</span>     <span class="token operator">&gt;</span>     MASTER_PORT <span class="token operator">=</span> port<span class="token punctuation">,</span>     <span class="token operator">&gt;</span>     MASTER_USER <span class="token operator">=</span> <span class="token keyword">user</span><span class="token punctuation">,</span>     <span class="token operator">&gt;</span>     MASTER_PASSWORD <span class="token operator">=</span> password<span class="token punctuation">,</span>     <span class="token operator">&gt;</span>     MASTER_AUTO_POSITION <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h5 id="5、启动复制线程并禁用只读模式"><a href="#5、启动复制线程并禁用只读模式" class="headerlink" title="5、启动复制线程并禁用只读模式"></a>5、启动复制线程并禁用只读模式</h5><p>启动复制线程：<br></p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql">mysql<span class="token operator">&gt;</span> <span class="token keyword">START</span> SLAVE<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p></p><p>仅当在 <strong>步骤 1</strong> 中将服务器配置为只读时，才需要执行以下步骤。要允许服务器再次开始接受更新，请发出以下语句：<br></p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql">mysql<span class="token operator">&gt;</span> <span class="token keyword">SET</span> @<span class="token variable">@GLOBAL.read_only</span> <span class="token operator">=</span> <span class="token keyword">OFF</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p></p><h4 id="2-3-3、使用-GTID-复制的限制"><a href="#2-3-3、使用-GTID-复制的限制" class="headerlink" title="2.3.3、使用 GTID 复制的限制"></a>2.3.3、使用 GTID 复制的限制</h4><p>因为基于 GTID 的复制依赖于事务，所以在使用 MySQL 时不支持一些原本在 MySQL 中可用的特性。相关限制如下：</p><ul><li>涉及非事务性存储引擎的更新。 </li><li>CREATE TABLE … SELECT 语句。基于 GTID 的复制时不允许使用语句。</li><li>临时表。  使用 GTID 时（即当 系统变量设置为时），事务、过程、函数和触发器中不支持CREATE TEMPORARY TABLE和 语句。</li><li>防止执行不受支持的语句。  为了防止执行会导致基于 GTID 的复制失败的语句，所有服务器都必须 —enforce-gtid-consistency在启用 GTID 时使用该选项启动。</li><li>跳过交易。  sql_slave_skip_counter使用 GTID 时不支持。</li><li>忽略服务器。  使用 GTID 时不推荐使用该语句的 IGNORE_SERVER_IDS 选项CHANGE MASTER TO，因为已应用的事务将被自动忽略。</li></ul><h2 id="三、主从同步——半同步复制（Semisynchronous-replication）"><a href="#三、主从同步——半同步复制（Semisynchronous-replication）" class="headerlink" title="三、主从同步——半同步复制（Semisynchronous replication）"></a>三、主从同步——半同步复制（Semisynchronous replication）</h2><p>主从同步的三种机制分别是异步、半同步、全同步，异步逻辑已经分析完了，下面看下半同步和全同步。先了解下全同步。</p><p><strong>全同步（完全同步复制）</strong>：当源提交事务时，所有副本也必须在源返回到执行事务的会话之前提交事务。即master每次提交都要等所有副本接收并记录了事件，所有副本都通知master记录成功，master才能提交本次事务。</p><ul><li>优点：完全同步复制意味着可以随时从源故障转移到任何副本。</li><li>缺点完全同步复制的缺点是完成事务可能会有很多延迟。</li></ul><p><strong>半同步复制（Semisynchronous Replication）</strong>：介于异步复制和完全同步复制之间。源等待直到至少一个副本接收并记录了事件（所需的副本数量是可配置的），然后提交事务。源不等待所有副本确认接收，它只需要来自副本的确认，而不是事件已在副本端完全执行并提交。因此，半同步复制保证如果源崩溃，它已提交的所有事务都已传输到至少一个副本。</p><ul><li>与完全同步复制相比，半同步复制更快，因为它可以配置为平衡您对数据完整性的要求（确认收到事务的副本数）和提交速度，提交速度由于需要等待而较慢复制品。</li><li>与异步复制相比，半同步复制的性能影响是提高数据完整性的权衡。</li></ul><p><strong>源与其副本之间的半同步复制操作如下：</strong></p><ul><li>副本在连接到源时指示它是否具有半同步能力。</li><li>如果在源端启用了半同步复制并且至少有一个半同步副本，则在源上执行事务提交的线程会阻塞并等待，直到至少一个半同步副本确认它已收到事务的所有事件，或者直到发生超时。</li><li>只有在将事件写入其中继日志并刷新到磁盘后，副本才会确认收到事务的事件。</li><li>如果在没有任何副本确认事务的情况下发生超时，则源将恢复为异步复制。当至少一个半同步副本赶上时，源返回到半同步复制。</li><li>必须在源端和副本端都启用半同步复制。如果在源上禁用半同步复制，或者在源上启用但没有副本，则源使用异步复制。</li></ul><h3 id="3-1、半同步实现"><a href="#3-1、半同步实现" class="headerlink" title="3.1、半同步实现"></a>3.1、半同步实现</h3><p>半同步复制是使用插件实现的，因此必须将插件安装到服务器中以使其可用。安装插件后，可以通过与其关联的系统变量来控制它。</p><h4 id="3-1-1、插件安装"><a href="#3-1-1、插件安装" class="headerlink" title="3.1.1、插件安装"></a>3.1.1、插件安装</h4><h5 id="1、介绍"><a href="#1、介绍" class="headerlink" title="1、介绍"></a>1、介绍</h5><p>服务器插件必须先加载到服务器中才能使用。MySQL 支持在服务器启动和运行时加载插件。还可以在启动时控制已加载插件的激活状态，并在运行时卸载它们。</p><p><strong>INSTALL PLUGIN</strong> 语句安装的插件：</p><ul><li>位于插件库文件中的插件可以在运行时使用该 <strong>INSTALL PLUGIN</strong> 语句加载。</li><li>该语句还在 mysql.plugin表中注册插件，以使服务器在后续重新启动时加载它。</li><li>插件库文件的基本名称取决于您的平台。常见的后缀 <strong>.so</strong> 适用于 Unix 和类 Unix 系统，<strong>.dll</strong> 适用于 Windows。</li></ul><h5 id="2、安装"><a href="#2、安装" class="headerlink" title="2、安装"></a>2、安装</h5><p><strong>安装语句：</strong><br></p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token comment">-- 基于mac环境</span><span class="token comment">-- 主库</span>INSTALL PLUGIN rpl_semi_sync_master <span class="token keyword">SONAME</span> <span class="token string">'semisync_master.so'</span><span class="token punctuation">;</span><span class="token comment">-- 从库</span>INSTALL PLUGIN rpl_semi_sync_slave <span class="token keyword">SONAME</span> <span class="token string">'semisync_slave.so'</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p></p><p><strong>安装查看</strong></p><ul><li>可以查看 <strong>INFORMATION_SCHEMA.PLUGINS</strong> 表</li><li>使用 <strong>SHOW PLUGINS</strong> 语句</li></ul><p>此处查看PLUGINS表信息<br></p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">SELECT</span>PLUGIN_NAME<span class="token punctuation">,</span>PLUGIN_STATUS <span class="token keyword">FROM</span>INFORMATION_SCHEMA<span class="token punctuation">.</span>PLUGINS <span class="token keyword">WHERE</span>PLUGIN_NAME <span class="token operator">LIKE</span> <span class="token string">'%semi%'</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p></p><p><strong>结果：</strong><br><img src="/image/mysql/查看插件信息.png" alt="安装的插件信息"></p><h5 id="3、配置"><a href="#3、配置" class="headerlink" title="3、配置"></a>3、配置</h5><p>半同步相关的配置项主要使用以下几项：</p><ul><li><strong>rpl_semi_sync_master_enabled：</strong> 控制是否在源上启用半同步复制。要启用或禁用插件，请将此变量分别设置为 1 或 0。默认值为 0（关闭）。</li><li><strong>rpl_semi_sync_master_timeout：</strong> 一个以毫秒为单位的值，用于控制源在超时和恢复到异步复制之前等待来自副本的确认提交的时间。默认值为 10000（10 秒）。</li><li><strong>rpl_semi_sync_slave_enabled：</strong> 类似于 rpl_semi_sync_master_enabled，但控制副本插件。</li></ul><p>mysql实例运行时：<br></p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token comment">-- 主库</span><span class="token keyword">SET</span> <span class="token keyword">GLOBAL</span> rpl_semi_sync_master_enabled <span class="token operator">=</span> {<span class="token number">0</span><span class="token operator">|</span><span class="token number">1</span>}<span class="token punctuation">;</span><span class="token keyword">SET</span> <span class="token keyword">GLOBAL</span> rpl_semi_sync_master_timeout <span class="token operator">=</span> N<span class="token punctuation">;</span><span class="token comment">-- 从库</span><span class="token keyword">SET</span> <span class="token keyword">GLOBAL</span> rpl_semi_sync_slave_enabled <span class="token operator">=</span> {<span class="token number">0</span><span class="token operator">|</span><span class="token number">1</span>}<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p></p><p>如果在运行时在副本上启用半同步复制，则还必须启动复制 I/O 线程（如果它已经在运行，则首先停止它）以使副本连接到源并注册为半同步副本：<br></p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql">STOP SLAVE IO_THREAD<span class="token punctuation">;</span><span class="token keyword">START</span> SLAVE IO_THREAD<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p></p><p>实例启动时配置文件配置：<br></p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token comment"># 主库</span><span class="token punctuation">[</span>mysqld<span class="token punctuation">]</span><span class="token assign-left variable">rpl_semi_sync_master_enabled</span><span class="token operator">=</span><span class="token number">1</span><span class="token assign-left variable">rpl_semi_sync_master_timeout</span><span class="token operator">=</span><span class="token number">1000</span> <span class="token comment"># 1 second</span><span class="token comment"># 从库</span><span class="token punctuation">[</span>mysqld<span class="token punctuation">]</span><span class="token assign-left variable">rpl_semi_sync_slave_enabled</span><span class="token operator">=</span><span class="token number">1</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><br>自此半同步配置即完成<p></p><h2 id="四、延迟复制"><a href="#四、延迟复制" class="headerlink" title="四、延迟复制"></a>四、延迟复制</h2><p>MySQL 5.7 支持延迟复制，这样副本服务器故意滞后源至少指定的时间量。默认延迟为 0 秒。设置：<br></p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token comment">-- N 为延迟秒数</span>CHANGE MASTER <span class="token keyword">TO</span> MASTER_DELAY <span class="token operator">=</span> N<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><br>从源接收到的事件直到在源上执行至少 N几秒钟后才会执行。例外情况是格式描述事件或日志文件轮换事件没有延迟，它们只影响 SQL 线程的内部状态。<p></p><p>作用：</p><ul><li>防止用户在源上出错。DBA 可以将延迟的副本回滚到灾难发生前的时间。</li><li>测试存在滞后时系统的行为。</li><li>检查数据库很久以前的样子，而无需重新加载备份。</li></ul>]]></content>
      
      
      <categories>
          
          <category> MySQL </category>
          
          <category> 同步 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Database </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JVM调优之jps jinfo jstat jmap jhat</title>
      <link href="/2020/08/18/java/jvm/jvm-diao-you/"/>
      <url>/2020/08/18/java/jvm/jvm-diao-you/</url>
      
        <content type="html"><![CDATA[<h2 id="JVM调优"><a href="#JVM调优" class="headerlink" title="JVM调优"></a>JVM调优</h2><h4 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h4><p>虽然jvm调优成熟的工具已经有很多：jconsole、大名鼎鼎的VisualVM，IBM的Memory Analyzer等等。但生产环境出现问题时，一是受环境所限，二是所有工具几乎都是依赖JDK的接口和底层连接命令，所以研究JDK的这些命令有助我们进一步了解JDK的构成和特性。</p><h4 id="调优原则"><a href="#调优原则" class="headerlink" title="调优原则"></a>调优原则</h4><p>多数应用在服务器不需要怎么进行GC优化，多数导致GC问题的应用，主要问题并不在于GC的参数上，而更多的在代码上面。如：全局变量对象创建过多等。GC是最后不得已下的手段而已。所以通过GC情况分析并优化代码比GC调优要更多。</p><p>本文基于JDK8，相关监控和处理故障的命令有：jps、jinfo、jstat、jmap、jhat。</p><h2 id="jps"><a href="#jps" class="headerlink" title="jps"></a>jps</h2><p>jps（JVM Process Status Tool）：显示指定系统内所有Hotspot虚拟机进程</p><p>命令格式：<br></p><pre class="line-numbers language-xshell" data-language="xshell"><code class="language-xshell">jps [options] [hostid]<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><br>options参数：  <p></p><ul><li>-l：输入主类的全名或路径  </li><li>-q：输出LVMID  </li><li>-m：输出JVM启动时传递给main()的参数  </li><li>-v：输出JVM启动时显示指定的参数    </li></ul><p>示例：<br></p><pre class="line-numbers language-xshell" data-language="xshell"><code class="language-xshell">λ jps -l39392 org.jetbrains.jps.cmdline.Launcher77060 sun.tools.jps.Jps115404 org.jetbrains.idea.maven.server.RemoteMavenServer<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p></p><h2 id="jinfo"><a href="#jinfo" class="headerlink" title="jinfo"></a>jinfo</h2><p>jinfo(JVM Configuration info)：生成指定进程的JVM配置信息。</p><p>命令格式：<br></p><pre class="line-numbers language-xshell" data-language="xshell"><code class="language-xshell">jinfo -&lt;options&gt; vmid<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p></p><h3 id="options参数"><a href="#options参数" class="headerlink" title="options参数"></a>options参数</h3><ul><li>-flag <name>：打印指定参数的名称和值。</name></li><li>-flag [+|-]name：启用或禁用指定的布尔命令标志。</li><li>-flag <name>=<value>：设定指定参数的值。</value></name></li><li>-flags：输出所有JVM参数。</li><li>-sysprops：以key-value形式，输出Java系统属性。</li></ul><p>示例：<br></p><pre class="line-numbers language-xshell" data-language="xshell"><code class="language-xshell">λ jinfo -flag MaxNewSize 75052  -XX:MaxNewSize=1418723328<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p></p><h2 id="jstat"><a href="#jstat" class="headerlink" title="jstat"></a>jstat</h2><p>jstat（JVM Statistics Monitoring）：监视虚拟机运行时状态信息的命令，它可显示JVM的类加载、内存、垃圾收集、JIT编译等运行数据等。</p><p>命令格式：<br></p><pre class="line-numbers language-xshell" data-language="xshell"><code class="language-xshell">jstat -&lt;option&gt; [-t] [-h&lt;lines&gt;] &lt;vmid&gt; [&lt;interval&gt; [&lt;count&gt;]]<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p></p><ul><li>option：操作参数</li><li>-t ：将时间戳列显示为输出的第一列。时间戳是自目标JVM启动时间以来的时间。</li><li>-h<lines>：即-h跟数字，代表隔几行显示标题，默认为0</lines></li><li>vmid ：代表vm进程id</li><li>interval：代表监控间隔时间段，默认毫秒做单位</li><li>count：代表取数次数</li></ul><h3 id="options参数-1"><a href="#options参数-1" class="headerlink" title="options参数"></a>options参数</h3><h4 id="总览"><a href="#总览" class="headerlink" title="总览"></a>总览</h4><div class="table-container"><table><thead><tr><th style="text-align:left">参数</th><th style="text-align:left">描述</th><th style="text-align:left">备注</th></tr></thead><tbody><tr><td style="text-align:left">class</td><td style="text-align:left">class loader的行为统计<br>Statistics about the behavior of the class loader.</td><td style="text-align:left"></td></tr><tr><td style="text-align:left">compiler</td><td style="text-align:left">HotSpt JIT编译器行为统计。<br>Statistics about the behavior of the Java HotSpot VM Just-in-Time compiler.</td><td style="text-align:left"></td></tr><tr><td style="text-align:left">gc</td><td style="text-align:left">垃圾收集堆行为统计.<br>Statistics about the behavior of the garbage collected heap.</td><td style="text-align:left"></td></tr><tr><td style="text-align:left">gccapacity</td><td style="text-align:left">代的容量及其相应空间的统计信息。<br>Statistics about the capacities of the generations and their corresponding spaces.</td><td style="text-align:left"></td></tr><tr><td style="text-align:left">gccause</td><td style="text-align:left">垃圾收集器统计概述(同gcutil)，及最近两次垃圾回收原因。<br>A summary about garbage collection statistics (same as -gcutil), with the cause of the last and current (when applicable) garbage collection events.</td><td style="text-align:left"></td></tr><tr><td style="text-align:left">gcnew</td><td style="text-align:left">新生代代行为统计<br>Statistics about the behavior of the new generation.</td><td style="text-align:left"></td></tr><tr><td style="text-align:left">gcnewcapacity</td><td style="text-align:left">新生代与其相应的内存空间统计。<br>Statistics about the sizes of the new generations and their corresponding spaces.</td><td style="text-align:left"></td></tr><tr><td style="text-align:left">gcold</td><td style="text-align:left">老年代和元空间的行为统计。<br>Statistics about the behavior of the old generation and metaspace statistics.</td><td style="text-align:left"></td></tr><tr><td style="text-align:left">gcoldcapacity</td><td style="text-align:left">老年代大小统计。<br>Statistics about the sizes of the old generation.</td><td style="text-align:left"></td></tr><tr><td style="text-align:left">gcmetacapacity</td><td style="text-align:left">元空间大小统计。<br>Statistics about the sizes of the metaspace.</td><td style="text-align:left"></td></tr><tr><td style="text-align:left">gcutil</td><td style="text-align:left">垃圾收集器统计概述。<br>A summary about garbage collection statistics.</td><td style="text-align:left"></td></tr><tr><td style="text-align:left">printcompilation</td><td style="text-align:left">HotSpot编译方法统计。<br>Java HotSpot VM compilation method statistics.</td><td style="text-align:left"></td></tr></tbody></table></div><h4 id="options参数详解"><a href="#options参数详解" class="headerlink" title="options参数详解"></a>options参数详解</h4><h5 id="class"><a href="#class" class="headerlink" title="-class"></a>-class</h5><p>Class loader statistics.<br></p><pre class="line-numbers language-xshell" data-language="xshell"><code class="language-xshell">λ jstat -class 62044  Loaded  Bytes    Unloaded  Bytes     Time  6152    12149.8     0       0.0       8.72<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p></p><ul><li>Loaded：加载class数量。  </li><li>Bytes：加载的class字节大小（KB）。</li><li>Unloaded：未加载的class数量。</li><li>Bytes：未加载calss字节大小（KB）。</li><li>Time：执行类加载和卸载的总时间。</li></ul><h5 id="compiler"><a href="#compiler" class="headerlink" title="-compiler"></a>-compiler</h5><p>Java HotSpot VM Just-in-Time compiler statistics.<br></p><pre class="line-numbers language-xshell" data-language="xshell"><code class="language-xshell">λ jstat -compiler 62044  Compiled Failed Invalid   Time   FailedType FailedMethod      8306      2       0    34.24          1 com/alibaba/druid/pool/DruidDataSource shrink<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p></p><ul><li>Compilerd：编译数量</li><li>Failed：编译失败的数量</li><li>Invalid：无效的数量</li><li>Time：执行编译时长</li><li>FailedType : 失败类型</li><li>FailedMethod : 失败方法的全限定名</li></ul><h5 id="gc"><a href="#gc" class="headerlink" title="-gc"></a>-gc</h5><p>Garbage collected heap statistics.<br></p><pre class="line-numbers language-xshell" data-language="xshell"><code class="language-xshell">λ jstat -gc 62044 S0C    S1C    S0U    S1U      EC       EU        OC         OU       MC     MU    CCSC   CCSU   YGC     YGCT    FGC    FGCT     GCT512.0  512.0   0.0    96.0  27648.0   6616.5   67584.0    55474.4   42112.0 41055.1 4736.0 4522.8  50299   94.002  12      0.677   94.679<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><br>C：Capacity，即总容量，容量单位为KB；U：Used，即已使用容量。  <p></p><ul><li>S0C：survivor0总容量  </li><li>S1C：survivor1总容量  </li><li>S0U：survivor0已使用容量</li><li>S1U：survivor1已使用容量</li><li>EC：Eden区总容量</li><li>EU：Eden区已使用容量</li><li>OC：老年代总容量</li><li>OU：老年代已使用容量</li><li>MC：元空间承诺大小</li><li>MU：元空间已使用容量</li><li>CCSC：压缩类容量大小</li><li>CCSU：压缩类已使用容量</li><li>YGC：新生代垃圾回收次数</li><li>YGCT：新生代垃圾回收时间</li><li>FGC：老年代垃圾回收次数</li><li>FGCT：老年代垃圾回收时间</li><li>GCT：垃圾回收总耗时</li></ul><h5 id="gccapacity"><a href="#gccapacity" class="headerlink" title="-gccapacity"></a>-gccapacity</h5><p>Memory pool generation and space capacities.<br></p><pre class="line-numbers language-xshell" data-language="xshell"><code class="language-xshell">jstat -gccapacity 62044 NGCMN    NGCMX     NGC     S0C   S1C       EC      OGCMN      OGCMX       OGC         OC       MCMN     MCMX      MC     CCSMN    CCSMX     CCSC    YGC    FGC 86528.0 1385472.0  32256.0  512.0  512.0  30720.0   173568.0  2771968.0    83968.0    83968.0      0.0 1085440.0  39936.0      0.0 1048576.0   4608.0   1306     2<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p></p><ul><li>NGCMN：新生代最小容量</li><li>NGCMX：新生代最大容量</li><li>NGC：当前新生代容量</li><li>S0C：survivor0总容量  </li><li>S1C：survivor1总容量  </li><li>EC：Eden区总容量  </li><li>OGCMN：老年代最小容量</li><li>OGCMX：老年代最大容量</li><li>OGC：当前老年代容量</li><li>OC：老年代总容量</li><li>MCMN：元空间最小容量</li><li>MCMX：元空间最大容量</li><li>MC：元空间当前容量</li><li>CCSMN：压缩类空间最小容量</li><li>CCSMX：压缩类空间最大容量</li><li>CCSC：当前压缩类空间容量</li><li>YGC：年轻的GC次数</li><li>FGC：老年代GC次数</li></ul><h5 id="gccause"><a href="#gccause" class="headerlink" title="-gccause"></a>-gccause</h5><p>垃圾收集器统计概述(同gcutil)，及最近两次垃圾回收原因。<br></p><pre class="line-numbers language-xshell" data-language="xshell"><code class="language-xshell">λ jstat -gccause 62044  S0     S1     E      O      M     CCS    YGC     YGCT    FGC    FGCT     GCT    LGCC                 GCC 25.00   0.00  49.19  37.97  97.21  96.06   2360    4.765     2    0.099    4.865 Allocation Failure   No GC<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p></p><ul><li>LGCC：上次垃圾回收原因</li><li>GCC：当前垃圾回收原因</li></ul><h5 id="gcnew"><a href="#gcnew" class="headerlink" title="-gcnew"></a>-gcnew</h5><p>新生代代行为统计<br></p><pre class="line-numbers language-xshell" data-language="xshell"><code class="language-xshell">λ jstat -gcnew 62044 S0C    S1C    S0U    S1U   TT MTT  DSS      EC       EU     YGC     YGCT 512.0  512.0    0.0   96.0 15  15  512.0  30720.0   6082.8   2557    5.169<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p></p><ul><li>S0C：survivor0总容量  </li><li>S1C：survivor1总容量  </li><li>S0U：survivor0已使用容量</li><li>S1U：survivor1已使用容量</li><li>TT：Tenuring threshold.(任期阈值)</li><li>DTT： Maximum tenuring threshold.</li><li>DSS：DSS: Desired survivor size (KB).survivor的容量</li><li>EC：Eden区总容量</li><li>EU：Eden区已使用容量</li><li>YGC：新生代垃圾回收次数</li><li>YGCT：新生代垃圾回收时间</li></ul><h4 id="gcnewcapacity"><a href="#gcnewcapacity" class="headerlink" title="-gcnewcapacity"></a>-gcnewcapacity</h4><p>新生代与其相应的内存空间统计。<br></p><pre class="line-numbers language-xshell" data-language="xshell"><code class="language-xshell">λ jstat -gcnewcapacity 105308  NGCMN      NGCMX       NGC      S0CMX     S0C     S1CMX     S1C       ECMX        EC      YGC   FGC   86528.0  1385472.0    64512.0 461824.0   9728.0 461824.0    512.0  1384448.0    45056.0    25     2<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p></p><ul><li>NGCMN：新生代最小容量</li><li>NGCMX：新生代最大容量</li><li>NGC：当前新生代容量</li><li>S0CMX：survivor0最大容量</li><li>S0C：当前survivor0容量</li><li>ECMX：Eden最大容量</li><li>EC：当前Eden容量</li><li>YGC：新生代垃圾回收次数</li><li>FGC：老年代GC次数</li></ul><h5 id="gcold"><a href="#gcold" class="headerlink" title="-gcold"></a>-gcold</h5><p>老年代和元空间的行为统计。<br></p><pre class="line-numbers language-xshell" data-language="xshell"><code class="language-xshell">λ jstat -gcold 105308   MC       MU      CCSC     CCSU       OC          OU       YGC    FGC    FGCT     GCT 39680.0  38773.6   4608.0   4422.3     80896.0     22094.7    313     2    0.098    0.805<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p></p><ul><li>MC：元空间承诺大小</li><li>MU：元空间已使用容量</li><li>CCSC：压缩类容量大小</li><li>CCSU：压缩类已使用容量</li><li>OC：老年代总容量</li><li>OU：老年代已使用容量</li><li>YGC：新生代垃圾回收次数</li><li>FGC：老年代垃圾回收次数</li><li>FGCT：老年代垃圾回收时间</li><li>GCT：垃圾回收总耗时</li></ul><h5 id="gcoldcapacity"><a href="#gcoldcapacity" class="headerlink" title="-gcoldcapacity"></a>-gcoldcapacity</h5><p>老年代大小统计。<br></p><pre class="line-numbers language-xshell" data-language="xshell"><code class="language-xshell">λ jstat -gcoldcapacity 105308   OGCMN       OGCMX        OGC         OC       YGC   FGC    FGCT     GCT   173568.0   2771968.0     80896.0     80896.0   740     2    0.098    1.668<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p></p><ul><li>OGCMN：老年代最小容量</li><li>OGCMX：老年代最大容量</li><li>OGC：当前老年代容量</li><li>OC：老年代总容量</li><li>YGC：年轻的GC次数</li><li>FGC：老年代GC次数</li><li>FGCT：老年代垃圾回收时间</li><li>GCT：垃圾回收总耗时</li></ul><h5 id="gcmetacapacity"><a href="#gcmetacapacity" class="headerlink" title="-gcmetacapacity"></a>-gcmetacapacity</h5><p>元空间大小统计。<br></p><pre class="line-numbers language-xshell" data-language="xshell"><code class="language-xshell">λ jstat -gcmetacapacity 105308   MCMN       MCMX        MC       CCSMN      CCSMX       CCSC     YGC   FGC    FGCT     GCT       0.0  1085440.0    40448.0        0.0  1048576.0     4608.0   848     2    0.098    1.885<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p></p><ul><li>MCMN：元空间最小容量</li><li>MCMX：元空间最大容量</li><li>MC：元空间当前容量</li><li>CCSMN：压缩类空间最小容量</li><li>CCSMX：压缩类空间最大容量</li><li>CCSC：当前压缩类空间容量</li><li>YGC：年轻的GC次数</li><li>FGC：老年代GC次数</li><li>FGCT：老年代垃圾回收时间</li><li>GCT：垃圾回收总耗时</li></ul><h5 id="gcutil"><a href="#gcutil" class="headerlink" title="-gcutil"></a>-gcutil</h5><p>垃圾收集器统计概述。<br></p><pre class="line-numbers language-xshell" data-language="xshell"><code class="language-xshell">λ jstat -gcutil 105308  S0     S1     E      O      M     CCS    YGC     YGCT    FGC    FGCT     GCT  0.00  31.25  57.06  30.97  97.41  96.00    959    2.047     2    0.098    2.145<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p></p><ul><li>S0、S1、E、O、M、CCS分别为对应内存空间已使用容量占总容量的百分比。</li></ul><h4 id="printcompilation"><a href="#printcompilation" class="headerlink" title="-printcompilation"></a>-printcompilation</h4><p>HotSpot编译方法统计。<br></p><pre class="line-numbers language-xshell" data-language="xshell"><code class="language-xshell">λ jstat -printcompilation 105308Compiled  Size  Type Method    7351     30    1 org/apache/http/message/TokenParser isWhitespace<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p></p><ul><li>Compiled：被执行的编译任务的数量</li><li>Size：方法字节码的字节数</li><li>Type：编译类型</li><li>Method：编译方法的类名和方法名。类名使用”/“ 代替 “.” 作为空间分隔符. 方法名是给出类的方法名. 格式是一致于HotSpot - XX:+PrintComplation 选项</li></ul><h3 id="示例分析"><a href="#示例分析" class="headerlink" title="示例分析"></a>示例分析</h3><pre class="line-numbers language-xshell" data-language="xshell"><code class="language-xshell">λ jstat -gcutil 105308 200 10  S0     S1     E      O      M     CCS    YGC     YGCT    FGC    FGCT     GCT 31.25   0.00  69.70  41.31  97.43  96.12   3050    6.466     2    0.098    6.564  0.00  25.00  25.65  41.31  97.43  96.12   3051    6.468     2    0.098    6.566  0.00  25.00  38.43  41.31  97.43  96.12   3051    6.468     2    0.098    6.566  0.00  25.00  50.31  41.31  97.43  96.12   3051    6.468     2    0.098    6.566  0.00  25.00  63.75  41.31  97.43  96.12   3051    6.468     2    0.098    6.566  0.00  25.00  73.27  41.31  97.43  96.12   3051    6.468     2    0.098    6.566  0.00  25.00  84.72  41.31  97.43  96.12   3051    6.468     2    0.098    6.566  0.00  25.00  99.04  41.31  97.43  96.12   3051    6.468     2    0.098    6.566 31.25   0.00  11.40  41.31  97.43  96.12   3052    6.469     2    0.098    6.567 31.25   0.00  20.88  41.31  97.43  96.12   3052    6.469     2    0.098    6.567<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>示例中vmid为105308，指令含义为输出垃圾收集统计概述，输出策略为每200毫秒一次共输出10次<br>根据结果可得出以下结果：</p><ol><li>10次内进行两次新生代GC</li><li>第一次新生代GC耗时0.002秒，第二次耗时0.001秒。</li><li>没有进行老年代收集，老年代没有空间上的变化，说明Eden区没有对象年龄晋升到老年代</li><li>第一次YGC将S0内对象提升到S1，S1部分对象提升到Eden区</li><li>元空间没有变化，但元空间使用程度已经极高，到了96.12%，这个时候就可以考虑下元空间调优的问题了。</li></ol><h2 id="jmap-print-details-of-a-specified-process"><a href="#jmap-print-details-of-a-specified-process" class="headerlink" title="jmap - print details of a specified process"></a>jmap - print details of a specified process</h2><p>jmap(JVM Memory Map)：用于生成heap dump文件，还可以查询finalize执行队列、Java堆和永久代的详细信息，如当前使用率、当前使用的是哪种收集器等。<br>可以使用XX:+HeapDumpOnOutOfMemoryError参数来让虚拟机出现OOM的时候·自动生成dump文件。</p><p>命令格式：<br></p><pre class="line-numbers language-xshell" data-language="xshell"><code class="language-xshell">jmap -&lt;options&gt; &lt;vmid&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p></p><h3 id="options参数-2"><a href="#options参数-2" class="headerlink" title="options参数"></a>options参数</h3><h4 id="总览-1"><a href="#总览-1" class="headerlink" title="总览"></a>总览</h4><div class="table-container"><table><thead><tr><th style="text-align:left">参数</th><th style="text-align:left">描述</th></tr></thead><tbody><tr><td style="text-align:left">-clstats</td><td style="text-align:left">打印java堆类加载统计信息<br>Prints class loader wise statistics of Java heap.</td></tr><tr><td style="text-align:left">-finalizerinfo</td><td style="text-align:left">打印等待结束的对象信息<br>Prints information about objects that are awaiting finalization.</td></tr><tr><td style="text-align:left">-histo[:live]</td><td style="text-align:left">打印堆的对象统计，包括对象数量，大小等。也可以单独指定子项：live，只打印存活对象。<br>Prints a histogram of the heap. For each Java class, the number of objects, memory size in bytes, and the fully qualified class names are printed. The JVM internal class names are printed with an asterisk (*) prefix. If the live suboption is specified, then only active objects are counted.</td></tr><tr><td style="text-align:left">-dump:[live,] format=b, file=filename</td><td style="text-align:left">将Java堆以hprof二进制格式转储为文件名filename。live子选项选定时，只转储存活对象。<br>Dumps the Java heap in hprof binary format to filename. The live suboption is optional, but when specified, only the active objects in the heap are dumped. To browse the heap dump, you can use the jhat(1) command to read the generated file.</td></tr><tr><td style="text-align:left">-heap</td><td style="text-align:left">输出java堆概览.<br>Prints a heap summary of the garbage collection used, the head configuration, and generation-wise heap usage. In addition, the number and size of interned Strings are printed.</td></tr></tbody></table></div><h4 id="详解"><a href="#详解" class="headerlink" title="详解"></a>详解</h4><h5 id="clstats"><a href="#clstats" class="headerlink" title="-clstats"></a>-clstats</h5><p>连接正在运行的进程，打印类加载器的统计信息<br></p><pre class="line-numbers language-xshell" data-language="xshell"><code class="language-xshell">λ jmap -clstats 75052Attaching to process ID 75052, please wait...Debugger attached successfully.Server compiler detected.JVM version is 25.131-b11finding class loader instances ..done.computing per loader stat ..done.please wait.. computing liveness.liveness analysis may be inaccurate ...class_loader    classes bytes   parent_loader   alive?  type&lt;bootstrap&gt;     3735    6715263   null          live    &lt;internal&gt;0x00000006c24851c8      1       889     0x00000006c24853f0      dead    sun/reflect/DelegatingClassLoader@0x00000007c0009df80x00000006c3220ba0      1       1471    0x00000006c2418f08      dead    sun/reflect/DelegatingClassLoader@0x00000007c0009df80x00000006c3820380      1       1471    0x00000006c2418f08      dead    sun/reflect/DelegatingClassLoader@0x00000007c0009df80x00000006c383c380      1       1471    0x00000006c2418f08      dead    sun/reflect/DelegatingClassLoader@0x00000007c0009df80x00000006c2cea748      1       878       null          dead    sun/reflect/DelegatingClassLoader@0x00000007c0009df80x00000006c2bf8178      1       1472      null          dead    sun/reflect/DelegatingClassLoader@0x00000007c0009df80x00000006c337c6f0      1       1483    0x00000006c2418f08      dead    sun/reflect/DelegatingClassLoader@0x00000007c0009df80x00000006c2485100      1       878       null          dead    sun/reflect/DelegatingClassLoader@0x00000007c0009df80x00000006c2418f08      2749    5382011 0x00000006c2418f68      dead    sun/misc/Launcher$AppClassLoader@0x00000007c000f6a00x00000006c3220c68      1       1471    0x00000006c2418f08      dead    sun/reflect/DelegatingClassLoader@0x00000007c0009df80x00000006c2cea680      1       880       null          dead    sun/reflect/DelegatingClassLoader@0x00000007c0009df80x00000006c337c838      1       1473    0x00000006c2418f08      dead    sun/reflect/DelegatingClassLoader@0x00000007c0009df80x00000006c3908b40      1       1471      null          dead    sun/reflect/DelegatingClassLoader@0x00000007c0009df80x00000006c2ceab58      1       880       null          dead    sun/reflect/DelegatingClassLoader@0x00000007c0009df80x00000006c3908c08      1       1471      null          dead    sun/reflect/DelegatingClassLoader@0x00000007c0009df80x00000006c28bafd0      0       0       0x00000006c2418f08      dead    java/util/ResourceBundle$RBClassLoader@0x00000007c00899500x00000006c2ceaa90      1       1472    0x00000006c2418f08      dead    sun/reflect/DelegatingClassLoader@0x00000007c0009df80x00000006c2bf87a0      1       1473      null          dead    sun/reflect/DelegatingClassLoader@0x00000007c0009df80x00000006c2bf89a0      1       1471      null          dead    sun/reflect/DelegatingClassLoader@0x00000007c0009df80x00000006c2485328      1       1471      null          dead    sun/reflect/DelegatingClassLoader@0x00000007c0009df80x00000006c39089b0      1       1471      null          dead    sun/reflect/DelegatingClassLoader@0x00000007c0009df80x00000006c3222ec0      1       880     0x00000006c2418f08      dead    sun/reflect/DelegatingClassLoader@0x00000007c0009df80x00000006c37cced8      1       1471      null          dead    sun/reflect/DelegatingClassLoader@0x00000007c0009df80x00000006c2bd2298      40      93710   0x00000006c2418f08      dead    com/alibaba/fastjson/util/ASMClassLoader@0x00000007c02af0980x00000006c2cea428      1       1474      null          dead    sun/reflect/DelegatingClassLoader@0x00000007c0009df80x00000006c2bf86d8      1       1473      null          dead    sun/reflect/DelegatingClassLoader@0x00000007c0009df80x00000006c337d290      1       1485    0x00000006c2418f08      dead    sun/reflect/DelegatingClassLoader@0x00000007c0009df80x00000006c3908a78      1       1471      null          dead    sun/reflect/DelegatingClassLoader@0x00000007c0009df80x00000006c2418f68      124     266033    null          dead    sun/misc/Launcher$ExtClassLoader@0x00000007c000fa480x00000006c3222f88      1       1471    0x00000006c2418f08      dead    sun/reflect/DelegatingClassLoader@0x00000007c0009df80x00000006c37cce10      1       1471    0x00000006c2418f08      dead    sun/reflect/DelegatingClassLoader@0x00000007c0009df80x00000006c2cea360      1       1485      null          dead    sun/reflect/DelegatingClassLoader@0x00000007c0009df80x00000006c2bf8610      1       1471      null          dead    sun/reflect/DelegatingClassLoader@0x00000007c0009df80x00000006c2485038      1       1471      null          dead    sun/reflect/DelegatingClassLoader@0x00000007c0009df80x00000006c2cea5b8      1       880       null          dead    sun/reflect/DelegatingClassLoader@0x00000007c0009df80x00000006c2bf8308      1       1471    0x00000006c2418f68      dead    sun/reflect/DelegatingClassLoader@0x00000007c0009df80x00000006c2bf8548      1       1473      null          dead    sun/reflect/DelegatingClassLoader@0x00000007c0009df80x00000006c337cf80      1       878       null          dead    sun/reflect/DelegatingClassLoader@0x00000007c0009df80x00000006c2484ef0      1       880       null          dead    sun/reflect/DelegatingClassLoader@0x00000007c0009df80x00000006c24853f0      12      37276   0x00000006c2418f08      dead    sun/reflect/misc/MethodUtil@0x00000007c0116af80x00000006c2cea4f0      1       880       null          dead    sun/reflect/DelegatingClassLoader@0x00000007c0009df80x00000006c2bf8240      1       1473      null          dead    sun/reflect/DelegatingClassLoader@0x00000007c0009df80x00000006c337d048      1       878       null          dead    sun/reflect/DelegatingClassLoader@0x00000007c0009df80x00000006c37fe380      1       1471      null          dead    sun/reflect/DelegatingClassLoader@0x00000007c0009df8total = 45      6699    12545217            N/A         alive=1, dead=44            N/A<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p></p><ul><li>class_loader：类加载器</li><li>classes：加载的class数</li><li>bytes：加载字节码大小</li><li>parent_loader：父类加载器</li><li>live：存活状态</li><li>type：加载器类型</li></ul><h5 id="finalizerinfo"><a href="#finalizerinfo" class="headerlink" title="-finalizerinfo"></a>-finalizerinfo</h5><p>打印等待结束的对象信息<br></p><pre class="line-numbers language-xshell" data-language="xshell"><code class="language-xshell">λ jmap -finalizerinfo 75052  Attaching to process ID 75052, please wait...  Debugger attached successfully.  Server compiler detected.  JVM version is 25.131-b11  Number of objects pending for finalization: 0<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><br>可以看出来，目前没有等待结束的对象<p></p><h5 id="histo"><a href="#histo" class="headerlink" title="-histo"></a>-histo</h5><p>打印堆的对象统计，包括对象数量，大小等。也可以单独指定子项：live，只打印存活对象。<br></p><pre class="line-numbers language-xshell" data-language="xshell"><code class="language-xshell">λ jmap -histo:live 75052|more num     #instances         #bytes  class name----------------------------------------------   1:          4071        5668128  [I   2:         52491        4982384  [C   3:          3629        1511648  [B   4:         51380        1233120  java.lang.String   5:          6620         751480  java.lang.Class   6:         16354         523328  java.util.concurrent.ConcurrentHashMap$Node   7:         15464         494848  java.util.HashMap$Node   8:          6599         409624  [Ljava.lang.Object;   9:          2787         245256  java.lang.reflect.Method  10:          1363         200728  [Ljava.util.HashMap$Node;  11:          8237         197688  sun.font.TrueTypeFont$DirectoryEntry  12:          6121         195872  java.util.Hashtable$Entry  13:           209         143976  [J-- More  --<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><br>因histo统计对象的类型很多，带上more后，可根据命令窗口大小进行部分展示，可回车后继续展示。<br>其中class name为对象类型的，部分为简写，含义如下：<p></p><ul><li>B  byte</li><li>C  char</li><li>D  double</li><li>F  float</li><li>I  int</li><li>J  long</li><li>Z  boolean</li><li>[  数组，如[I表示int[]</li><li>[L+类名 其他对象</li></ul><h5 id="dump"><a href="#dump" class="headerlink" title="-dump"></a>-dump</h5><p>转储java堆信息，包含子项如下：</p><ul><li>live：当指定后，只转储存活对象</li><li>format=b：转储格式，以hprof二进制格式转储Java堆</li><li>file=filename：转储文件名  </li></ul><pre class="line-numbers language-xshell" data-language="xshell"><code class="language-xshell">λ jmap -dump:live,format=b,file=heap 75052  Dumping heap to C:\Users\Y\heap1 ...  Heap dump file created<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>示例中转储文件会生成在C:\Users\Y\目录下，后续dump文件分析可以根据文件大小进行选择。<br>分析工具：</p><ul><li>JDK自带程序jvisiualvm.exe</li><li>jhat命令</li><li>Eclipse Memory Analyzer(MAT)</li></ul><h5 id="heap"><a href="#heap" class="headerlink" title="-heap"></a>-heap</h5><p>输出java堆概览<br></p><pre class="line-numbers language-xshell" data-language="xshell"><code class="language-xshell">λ jmap -heap 75052Attaching to process ID 75052, please wait...Debugger attached successfully.Server compiler detected.JVM version is 25.131-b11using thread-local object allocation.Parallel GC with 4 thread(s)  //GC方式，并行Heap Configuration://堆初始配置，可以通过 -XX:*(eg:NewSize) 进行对应参数设置   MinHeapFreeRatio         = 0//最小空闲比率   MaxHeapFreeRatio         = 100//最大空闲比率   MaxHeapSize              = 4257218560 (4060.0MB)//最大堆内存   NewSize                  = 88604672 (84.5MB)//新生代内存容量   MaxNewSize               = 1418723328 (1353.0MB)//最大新生代内存容量   OldSize                  = 177733632 (169.5MB)//老年代内存容量   NewRatio                 = 2//新生代和老年代大小比例   SurvivorRatio            = 8//Eden区与Survivor区的大小比值   MetaspaceSize            = 21807104 (20.796875MB)//元空内存容量   CompressedClassSpaceSize = 1073741824 (1024.0MB)//压缩类空间内存容量   MaxMetaspaceSize         = 17592186044415 MB//最大元空间内存   G1HeapRegionSize         = 0 (0.0MB)//G1垃圾回收器中指定分区大小(1MB~32MB，且必须是2的幂)，默认将整堆划分为2048个分区Heap Usage:PS Young GenerationEden Space://Eden区使用情况：总容量、已使用、空闲、使用比例   capacity = 31981568 (30.5MB)   used     = 5003392 (4.7716064453125MB)   free     = 26978176 (25.7283935546875MB)   15.644611296106557% usedFrom Space://survivor0使用情况   capacity = 524288 (0.5MB)   used     = 131072 (0.125MB)   free     = 393216 (0.375MB)   25.0% usedTo Space://survivor1使用情况   capacity = 524288 (0.5MB)   used     = 0 (0.0MB)   free     = 524288 (0.5MB)   0.0% usedPS Old Generation//老年代使用情况   capacity = 88604672 (84.5MB)   used     = 22120552 (21.095802307128906MB)   free     = 66484120 (63.404197692871094MB)   24.965446517312316% used21409 interned Strings occupying 2142768 bytes.<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p></p><h2 id="jhat"><a href="#jhat" class="headerlink" title="jhat"></a>jhat</h2><p>jhat(JVM Heap Analysis Tool)与jmap结合使用，用来分析dump文件。jhat内置了一个微型的HTTP/HTML服务器，生成dump的分析结果后，可以在浏览器中查看.<br>本文基于JDK8来分析使用相关命令，所以依旧存在jhat命令。从JDK9的时候已经删除了（JEP 241: Remove the jhat Tool）。现在Oracle官方推荐的分析工具是Eclipse Memory Analyzer Tool (MAT) 和 VisualVM(jvisualvm.exe)。</p><p>相关操作参数,有兴趣的可以深入了解一下：<br></p><pre class="line-numbers language-xshell" data-language="xshell"><code class="language-xshell">Usage:  jhat [-stack &lt;bool&gt;] [-refs &lt;bool&gt;] [-port &lt;port&gt;] [-baseline &lt;file&gt;] [-debug &lt;int&gt;] [-version] [-h|-help] &lt;file&gt;        -J&lt;flag&gt;          Pass &lt;flag&gt; directly to the runtime system. For                          example, -J-mx512m to use a maximum heap size of 512MB        -stack false:     Turn off tracking object allocation call stack.        -refs false:      Turn off tracking of references to objects        -port &lt;port&gt;:     Set the port for the HTTP server.  Defaults to 7000        -exclude &lt;file&gt;:  Specify a file that lists data members that should                          be excluded from the reachableFrom query.        -baseline &lt;file&gt;: Specify a baseline object dump.  Objects in                          both heap dumps with the same ID and same class will                          be marked as not being "new".        -debug &lt;int&gt;:     Set debug level.                            0:  No debug output                            1:  Debug hprof file parsing                            2:  Debug hprof file parsing, no server        -version          Report version number        -h|-help          Print this help and exit        &lt;file&gt;            The file to read<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p></p>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
          <category> JVM </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JVM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>java的future体系</title>
      <link href="/2020/08/18/java/duo-xian-cheng/future/"/>
      <url>/2020/08/18/java/duo-xian-cheng/future/</url>
      
        <content type="html"><![CDATA[<h2 id="一、Future概念"><a href="#一、Future概念" class="headerlink" title="一、Future概念"></a>一、Future概念</h2><h3 id="1-1、概念"><a href="#1-1、概念" class="headerlink" title="1.1、概念"></a>1.1、概念</h3><p><font color="blue"> <strong><a href="https://docs.oracle.com/en/java/javase/18/docs/api/java.base/java/util/concurrent/Future.html">Oracle官方文档</a></strong> </font> 针对Future接口解释如下：未来表示异步计算的结果。提供了检查计算是否完成，等待计算完成以及检索计算结果的方法。只有在计算完成时，才能使用方法 <strong>get()</strong> 检索结果，如有必要，在计算准备就绪之前将其阻止。取消由取消方法执行。</p><p>举个例子：发快递时的快递单号，整个快递过程中单号就是唯一的重要标识与凭证。<strong>Future</strong> 就类似于这个单号，在异步操作中，可以根据 <strong>Future</strong> 去提取相关的操作结果。所以<strong>Future</strong> 表示的是异步任务还没完成提前给出的未来结果。</p><h3 id="1-2、Future"><a href="#1-2、Future" class="headerlink" title="1.2、Future"></a>1.2、Future</h3><p>java中 Future 就是对于具体的 <strong>Runnable</strong> 或者 <strong>Callable</strong>（下面会详细介绍） 任务的执行结果进行取消、查询是否完成、获取结果。必要时可以通过get方法获取执行结果，该方法会阻塞直到任务返回结果。</p><p><strong>代码定义</strong>：<br></p><pre class="line-numbers language-Java" data-language="Java"><code class="language-Java">public interface Future&lt;V&gt; {    boolean cancel(boolean mayInterruptIfRunning);    boolean isCancelled();    boolean isDone();    V get() throws InterruptedException, ExecutionException;    V get(long timeout, TimeUnit unit)        throws InterruptedException, ExecutionException, TimeoutException;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p></p><p><strong>提供功能点：</strong></p><ul><li>cancel：用来取消任务，成功：true，失败：false。如果任务【已完成】或【未执行】或【被取消过】则返回false。<ul><li>参数 <strong>mayInterruptIfRunning</strong> 表示是否允许取消正在执行却没有执行完毕的任务。</li></ul></li><li>isCancelled：方法表示任务是否被取消成功，如果在任务正常完成前被取消成功，则返回 true。</li><li>isDone方法表示任务是否已经完成，若任务完成，则返回true；</li><li>get()方法用来获取执行结果，这个方法会产生阻塞，会一直等到任务执行完毕才返回；</li><li>get(long timeout, TimeUnit unit)用来获取执行结果，如果在指定时间内，还没获取到结果，就直接返回null。</li></ul><p><strong>也就是说Future提供了三种功能：</strong></p><ul><li>判断任务是否完成；</li><li>能够中断任务；</li><li>能够获取任务执行结果。<br>因为Future只是一个接口，所以是无法直接用来创建对象使用的，因此就有了下面的FutureTask。</li></ul><h3 id="1-2、与Thread区别"><a href="#1-2、与Thread区别" class="headerlink" title="1.2、与Thread区别"></a>1.2、与Thread区别</h3><p>常见的两种创建线程的方式。一种是直接继承Thread，另外一种就是实现Runnable接口。Future与这二者的唯一区别就是：<strong>Thread是没有返回结果的，而Future模式是有返回结果的。</strong></p><h2 id="二、Future使用"><a href="#二、Future使用" class="headerlink" title="二、Future使用"></a>二、Future使用</h2><p>先假设个场景，我们要做烧仙草奶茶。那么就需要分别把烧仙草和奶茶做好，然后再做出烧仙草奶茶，前面的烧仙草的制作和奶茶的制作都耗时不短，而且二者完全独立，所以可以有二者同时进行即有两个线程分别去制作。等均完成后进行最后的制作。<br></p><pre class="line-numbers language-Java" data-language="Java"><code class="language-Java">public static void main(String[] args) throws Exception {    ExecutorService executorService = Executors.newCachedThreadPool();    FutureTask&lt;String&gt; makeGrassJelly = new FutureTask&lt;&gt;(new Callable&lt;String&gt;() {        @Override        public String call() throws Exception {            System.out.println(Thread.currentThread().getName() + ":" + "开始制作烧仙草。。。。。");            // 模拟制作耗时耗时            Thread.sleep(3000);            System.out.println(Thread.currentThread().getName() + ":"  + "烧仙草已经做好了...");            return "烧仙草";        }    });    executorService.submit(makeGrassJelly);    //也可使用如下方式，两种方式的效果一样，只不过一个使用的是ExecutorService，一个使用的是Thread    /*    Thread thread = new Thread(makeGrassJelly);    thread.start();    */    // 在制作烧仙草的同时制作奶茶    System.out.println(Thread.currentThread().getName() + ":"  + " 烧仙草的线程已经开始，下面我们做奶茶...");    // 模拟奶茶制作的耗时    Thread.sleep(2000);    System.out.println(Thread.currentThread().getName() + ":"  + "奶茶准备好了");    String milkTea = "奶茶";    // 开水已经稍好，我们取得烧好的开水    String grassJelly = makeGrassJelly.get();    System.out.println(Thread.currentThread().getName() + ":"  + grassJelly  + milkTea + "：制作完成了，可以开吃了");}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p></p><p>执行结果：</p><blockquote><p>main: 烧仙草的线程已经开始，下面我们做奶茶…<br>pool-1-thread-1:开始制作烧仙草。。。。。<br>main:奶茶准备好了<br>pool-1-thread-1:烧仙草已经做好了…<br>main:烧仙草奶茶：制作完成了，可以开吃了</p></blockquote><p><strong>从demo可知，使用Future步骤如下：</strong></p><ul><li>新建一个Callable匿名函数实现类对象，我们的业务逻辑在Callable的call方法中实现，其中Callable的泛型是返回结果类型；</li><li>然后把Callable匿名函数对象作为FutureTask的构造参数传入，构建一个futureTask对象；</li><li>然后再把futureTask对象作为Thread构造参数传入并开启这个线程执行去执行业务逻辑；</li><li>最后我们调用futureTask对象的get方法得到业务逻辑执行结果。</li></ul><p>可以看到跟 Future 使用有关的JDK类主要有 <strong>FutureTask</strong> 和 <strong>Callable</strong> 两个，下面分别对对 <strong>Callable</strong> 和 <strong>FutureTask</strong> 进行源码分析。</p><h2 id="三、Callable"><a href="#三、Callable" class="headerlink" title="三、Callable"></a>三、Callable</h2><p>正式进入Future模式讲解前，先了解下预备知识之——Callable。</p><h3 id="3-1、Callable-介绍"><a href="#3-1、Callable-介绍" class="headerlink" title="3.1、Callable 介绍"></a>3.1、Callable 介绍</h3><p><strong>Callable：</strong> 代表一段可以调用并返回结果的代码；<strong>Future接口</strong> 表示异步任务，是还没有完成的任务给出的未来结果。所以说 <strong>Callable</strong> 用于产生结果，<strong>Future</strong> 用于获取结果。 </p><p><strong>代码声明</strong>：<br></p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">interface</span> <span class="token class-name">Callable</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">V</span><span class="token punctuation">&gt;</span></span> <span class="token punctuation">{</span>    <span class="token comment">/**     * 计算结果，如果计算失败则抛出异常     *     * @return computed result     * @throws Exception if unable to compute a result     */</span>    <span class="token class-name">V</span> <span class="token function">call</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">Exception</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p></p><p>可以看到，这是一个泛型接口，call()函数返回的类型就是传递进来的V类型。<br>一般情况下是配合 ExecutorService 来使用的，在 ExecutorService 接口中声明了若干个submit方法的重载版本：<br></p><pre class="line-numbers language-Java" data-language="Java"><code class="language-Java">&lt;T&gt; Future&lt;T&gt; submit(Callable&lt;T&gt; task);&lt;T&gt; Future&lt;T&gt; submit(Runnable task, T result);Future&lt;?&gt; submit(Runnable task);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><br>第一个 <strong>submit</strong> 方法里面的参数类型就是 <strong>Callable</strong>。返回的是 <strong>Future</strong> 类型对象。<p></p><h3 id="3-2、与Runnable"><a href="#3-2、与Runnable" class="headerlink" title="3.2、与Runnable"></a>3.2、与Runnable</h3><ol><li><p>相同点</p><ul><li>都可以开发多线程。</li><li>都可以使用ExecutorService来执行。   </li></ul></li><li><p>不同点</p><ul><li>Callable有返回值，可以向上抛异常。Runnable不行。</li><li>都使用 ExecutorService 来执行，Callable 的返回值有意义，Runnable 的返回值为空。</li></ul></li></ol><h3 id="3-3、Callable执行"><a href="#3-3、Callable执行" class="headerlink" title="3.3、Callable执行"></a>3.3、Callable执行</h3><p><strong>Callable</strong> 的使用方式有两种一种是结合 <strong>ExecutorService</strong> 提交使用，一种是构建 <strong>FutureTask</strong> 对象来使用。</p><p>就先聊聊 Callable 的使用方法之一是：ExecutorService 的 submit 方法，那么我们就看下具体的执行逻辑和涉及的相关类型。</p><p><strong>异步执行demo</strong></p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">executeTask</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token class-name">ExecutorService</span> executorService <span class="token operator">=</span> <span class="token class-name">Executors</span><span class="token punctuation">.</span><span class="token function">newCachedThreadPool</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">//提交带有返回值的任务以供执行，并返回表示任务挂起结果的 Future</span>    <span class="token class-name">Future</span> submit <span class="token operator">=</span> executorService<span class="token punctuation">.</span><span class="token function">submit</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">-&gt;</span><span class="token punctuation">{</span>        <span class="token comment">//业务逻辑执行</span>        log<span class="token punctuation">.</span><span class="token function">info</span><span class="token punctuation">(</span><span class="token string">"in callable!!!!"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> <span class="token string">"callable"</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">try</span> <span class="token punctuation">{</span>        <span class="token comment">//获取执行结果</span>        submit<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">Exception</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>        log<span class="token punctuation">.</span><span class="token function">error</span><span class="token punctuation">(</span><span class="token string">"==== Asynchronous execution exception"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">RuntimeException</span><span class="token punctuation">(</span>e<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>执行逻辑：</strong><br><strong>1. 获取 ExecutorService 实例</strong>：<br>获取 <strong>ExecutorService</strong> 实例，用于任务提交操作。<strong>newCachedThreadPool()</strong> 将返回 <strong>ThreadPoolExecutor</strong> 类型对象实例。</p><p><strong>2. submit() 提交任务</strong></p><ul><li>执行对象类型<br><strong>Executors.newCachedThreadPool()</strong> 产生的对象实例类型为 <strong>ThreadPoolExecutor</strong>。其继承实现模型为：<br><img src="https://raw.githubusercontent.com/cmeng-CM/image-hosting/master/img/java/多线程/ThreadPoolExecutor类结构模型.png" alt="ThreadPoolExecutor类结构模型"></li><li>方法调用源码分析<br>提交任务的方法 <strong>submit</strong> 由 <strong>ExecutorService</strong> 接口定义，在 <strong>AbstractExecutorService</strong> 里面实现。<strong>ThreadPoolExecutor</strong> 类没有再次覆盖实现。因此最终调用的代码逻辑为 AbstractExecutorService 内的逻辑，其实现逻辑如下：    </li></ul><pre class="line-numbers language-Java" data-language="Java"><code class="language-Java">// AbstractExecutorService.javapublic &lt;T&gt; Future&lt;T&gt; submit(Callable&lt;T&gt; task) {    if (task == null) throw new NullPointerException();    RunnableFuture&lt;T&gt; ftask = newTaskFor(task);    execute(ftask);    return ftask;}// newTaskFor实现protected &lt;T&gt; RunnableFuture&lt;T&gt; newTaskFor(Callable&lt;T&gt; callable) {    return new FutureTask&lt;T&gt;(callable);}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>由源码可知，submit执行时：</p><ol><li>先将Callable接口实现转化为 <strong>FutureTask</strong> 类型对象。</li><li>然后再通过 <strong>execute</strong> 执行。  </li></ol><p>具体执行逻辑下面聊到 <strong>FutureTask</strong> 会详细说明。此处已经说明了 <strong>Callable 最终一定通过与 Future 结合进行使用</strong>，达到异步执行任务且返回相关结果的功能。所以两种执行方式的底层实现实为一种：即结合 <strong>FutureTask</strong> 进行使用。</p><p>那么接下来就聊聊 <strong>FutureTask</strong> 。</p><h2 id="四、FutureTask"><a href="#四、FutureTask" class="headerlink" title="四、FutureTask"></a>四、FutureTask</h2><h3 id="4-1、FutureTask类结构分析"><a href="#4-1、FutureTask类结构分析" class="headerlink" title="4.1、FutureTask类结构分析"></a>4.1、FutureTask类结构分析</h3><p>FutureTask的类结构：<br><img src="https://raw.githubusercontent.com/cmeng-CM/image-hosting/master/img/java/多线程/FutureTask类结构模型.png" alt="FutureTask类结构模型"></p><p>通过类图我们不难看出,<strong>RunnableFuture</strong> 继承了 <strong>Runable</strong> 以及 <strong>Future</strong> 接口，所以它即可以被线程异步执行，也可作为Future得到callable的计算结果。</p><p>下面进入正题聊聊 <strong>FutureTask</strong>，它实现了<strong>RunnableFuture</strong> 接口，所以也是 <strong>Future</strong> 和<strong>Runnable</strong> 接口的具体实现类，即异步任务执行后我们能够获取到异步任务的执行结果。</p><p>下面就详详细的通过源码分析下 <strong>FutureTask</strong> 的执行逻辑。</p><h3 id="4-2、源码分析——属性"><a href="#4-2、源码分析——属性" class="headerlink" title="4.2、源码分析——属性"></a>4.2、源码分析——属性</h3><p>先看下具体属性，这个在整体运行逻辑中都是很重要的。<br></p><pre class="line-numbers language-Java" data-language="Java"><code class="language-Java">// FutureTask.java/* Possible state transitions: * NEW -&gt; COMPLETING -&gt; NORMAL * NEW -&gt; COMPLETING -&gt; EXCEPTIONAL * NEW -&gt; CANCELLED * NEW -&gt; INTERRUPTING -&gt; INTERRUPTED*/// 任务执行状态标识private volatile int state;//定义运行状态码private static final int NEW          = 0;private static final int COMPLETING   = 1;private static final int NORMAL       = 2;private static final int EXCEPTIONAL  = 3;private static final int CANCELLED    = 4;private static final int INTERRUPTING = 5;private static final int INTERRUPTED  = 6;/** Callable对象实现，用于异步执行 */private Callable&lt;V&gt; callable;/** 从 get() 返回的结果或抛出的异常 */private Object outcome; /** 用来执行callable任务的线程 */private volatile Thread runner;/** 在 Treiber 中记录等待线程的简单链表节点 */private volatile WaitNode waiters;// VarHandle mechanicsprivate static final VarHandle STATE;private static final VarHandle RUNNER;private static final VarHandle WAITERS;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><br>根据Java并发工具类三板斧：<p></p><ul><li>状态</li><li>队列</li><li>CAS操作<br>从这个方面分别对不同的属性进行详细的解析。</li></ul><h4 id="4-2-1、属性——状态"><a href="#4-2-1、属性——状态" class="headerlink" title="4.2.1、属性——状态"></a>4.2.1、属性——状态</h4><pre class="line-numbers language-Java" data-language="Java"><code class="language-Java">// FutureTask.javaprivate static final int NEW          = 0;private static final int COMPLETING   = 1;private static final int NORMAL       = 2;private static final int EXCEPTIONAL  = 3;private static final int CANCELLED    = 4;private static final int INTERRUPTING = 5;private static final int INTERRUPTED  = 6;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>FutureTask</strong> 中定义了七种状态，一种初始状态，四种终态，两种中间态，由 <strong>0-6</strong> 分别代表分别如下：</p><ol><li>初始状态：<ul><li>NEW：初始状态，这是由构造函数保证的。</li></ul></li><li>中间态：<strong>瞬间状态，而且此状态并不代表任务正执行，而是已经执行完成正（成功或失败异常）在设置返回结果</strong><ul><li>COMPLETING： 正在设置任务结果</li><li>INTERRUPTING： 正在中断运行任务的线程</li></ul></li><li>终态<ul><li>NORMAL：任务正常执行完毕</li><li>EXCEPTIONAL：任务执行过程中发生异常</li><li>CANCELLED：任务被取消</li><li>INTERRUPTED：任务被中断</li></ul></li></ol><p><strong>执行状态流转顺序如下</strong>：</p><ol><li><strong>NEW -&gt; COMPLETING -&gt; NORMAL</strong><ul><li>任务正常执行且完成设置返回结果。</li><li>状态由 <strong>set</strong> 方法设置。</li></ul></li><li><strong>NEW -&gt; COMPLETING -&gt; EXCEPTIONAL</strong><ul><li>任务执行异常。</li><li>状态由 <strong>setException</strong> 方法设置。</li></ul></li><li><strong>NEW -&gt; CANCELLED</strong><ul><li>任务取消，即调用了 <strong>cancel(false)</strong></li><li>状态由 <strong>cancel</strong> 方法设置。</li></ul></li><li><strong>NEW -&gt; INTERRUPTING -&gt; INTERRUPTED</strong><ul><li>任务取消，即调用了 <strong>cancel(true)</strong></li><li>状态由 <strong>cancel</strong> 方法设置。</li></ul></li></ol><p>因此涉及状态修改的只有 set、setException、cancel这三个方法，方法的具体逻辑后面再详细分析。</p><h4 id="4-2-2、属性——队列"><a href="#4-2-2、属性——队列" class="headerlink" title="4.2.2、属性——队列"></a>4.2.2、属性——队列</h4><p>聊队列时同时将其它相关操作的属性一块聊一聊，</p><ol><li><strong>处理逻辑（callable）</strong><br>包含具体的异步执行逻辑内容，整个生命周期从构造函数接收，到call()方法调用执行，到最后的移除销毁整个过程与线程的具体执行逻辑息息相关。后面聊到具体执行逻辑再分析。</li><li><strong>执行（runner）</strong><br>用来执行 callable 任务的线程，<strong>runner 属性是在运行时被初始化的。</strong> 简单点说，就是run方法被调用时赋值。</li><li><strong>结果（outcome）</strong><br>任务的执行结果，成功为 callable 内的返回结果，失败为异常对象。</li><li><strong>队列（waiters）</strong><br>所有等待任务执行完毕的线程的集合。</li></ol><p>在并发编程中使用队列通常是将 <strong>当前线程包装成某种类型的数据结构扔到等待队列中，</strong> 接下来看下waiters的结构定义：<br></p><pre class="line-numbers language-Java" data-language="Java"><code class="language-Java">static final class WaitNode {    volatile Thread thread;    volatile WaitNode next;    WaitNode() { thread = Thread.currentThread(); }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><br>简单的单项链表结构，仅有两个属性一个是当前线程 <strong>thread</strong>，一个是下一个队列节点对象 <strong>next</strong>。<p></p><ul><li><strong>thread</strong>：存放当前调用 <strong>FutureTask</strong> 内各相关方法的线程信息。</li><li><strong>next</strong>：指向下一个节点的next属性。</li></ul><p>根据 <strong>WaitNode</strong> 对象的数据结构和属性内容，可以很明显的知道它的作用，即：将当前线程信息存放至链表，按照 <strong>后进先出</strong> 的规则进行相关操作。</p><p>因为 <strong>Future</strong> 的 <strong>get()/get(timeout)</strong> 在 task 处于非完成状态时是需要 <strong>阻塞等待</strong> 的，如果多个线程进行 get 操作，显然需要一个链表/队列来维护这些等待线程，这就是waiters的意义所在。</p><p>简答模拟了一下五个线程同时调用 <strong>get()</strong> 方法，可看到当第5个线程进行时，<strong>队列（waiters）</strong> 已经有五个等待线程了：</p><p><img src="https://raw.githubusercontent.com/cmeng-CM/image-hosting/master/img/java/多线程/Future-waiters模拟.png" alt="Future-waiters模拟"></p><p>其中 <strong>runner</strong> , <strong>waiters</strong> 和 <strong>state</strong> 都是用 <strong>volatile</strong> 关键字修饰，说明这三个变量都是多线程共享的对象（成员变量），会被多线程操作，此时用volatile关键字修饰是为了一个线程操作volatile属性变量值后，能够及时对其他线程可见。当然仅仅如此依旧存在线程安全的问题，所以其相关操作使用的CAS机制来确保线程的安全性。下面就聊下CAS。</p><h4 id="4-2-3、属性——CAS"><a href="#4-2-3、属性——CAS" class="headerlink" title="4.2.3、属性——CAS"></a>4.2.3、属性——CAS</h4><pre class="line-numbers language-Java" data-language="Java"><code class="language-Java">// FutureTask.javaprivate static final VarHandle STATE;private static final VarHandle RUNNER;private static final VarHandle WAITERS;static {    try {        MethodHandles.Lookup l = MethodHandles.lookup();        STATE = l.findVarHandle(FutureTask.class, "state", int.class);        RUNNER = l.findVarHandle(FutureTask.class, "runner", Thread.class);        WAITERS = l.findVarHandle(FutureTask.class, "waiters", WaitNode.class);    } catch (ReflectiveOperationException e) {        throw new ExceptionInInitializerError(e);    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>从这个静态代码块中我们也可以看出，CAS操作主要针对3个属性，包括 <strong>STATE</strong>、<strong>RUNNER</strong> 和  <strong>WAITERS</strong>，说明这3个属性基本是会被多个线程同时访问的。其中 <strong>STATE</strong>属性代表了任务的状态，<strong>WAITERS</strong> 属性代表了指向栈顶节点的指针。<strong>RUNNER</strong> 主要是为了 <strong>中断或者取消任务</strong> 做准备的，只有知道了执行任务的线程是谁，我们才能去中断它。</p><p>具体的操作也是使用了CAS方法即 <strong>compareAndSet</strong> 来完成的。</p><h3 id="4-3、源码分析——构造函数"><a href="#4-3、源码分析——构造函数" class="headerlink" title="4.3、源码分析——构造函数"></a>4.3、源码分析——构造函数</h3><p>FutureTask有两个构造函数，分别看下源码：<br></p><pre class="line-numbers language-Java" data-language="Java"><code class="language-Java">// 构造函数1// FutureTask.javapublic FutureTask(Callable&lt;V&gt; callable) {    if (callable == null)        throw new NullPointerException();    this.callable = callable;    this.state = NEW;       // ensure visibility of callable}// 构造函数2public FutureTask(Runnable runnable, V result) {    this.callable = Executors.callable(runnable, result);    this.state = NEW;       // ensure visibility of callable}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p></p><p>构造函数1很好理解，传入 <strong>Callable</strong> 的实现类，将参数赋值属性 <strong>callable</strong>，同时将状态 <strong>state</strong> 置为初始状态 <strong>NEW</strong>，代表新建任务状态。</p><p>接着看构造函数2，很明显的区别在于入参变成了 <strong>Runnable</strong> 实现类，且增加了返回结果的泛型集。然后将二者通过 <strong>Executors.callable()</strong> 方法转变成了 <strong>callable</strong> 类型，那么就进入方法具体看下源码：<br></p><pre class="line-numbers language-Java" data-language="Java"><code class="language-Java">// FutureTask.javapublic static &lt;T&gt; Callable&lt;T&gt; callable(Runnable task, T result) {    if (task == null)        throw new NullPointerException();    return new RunnableAdapter&lt;T&gt;(task, result);}private static final class RunnableAdapter&lt;T&gt; implements Callable&lt;T&gt; {    private final Runnable task;    private final T result;    RunnableAdapter(Runnable task, T result) {        this.task = task;        this.result = result;    }    public T call() {        task.run();        return result;    }    public String toString() {        return super.toString() + "[Wrapped task = " + task + "]";    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p></p><p>由源码可知，方法直接调用了 <strong>RunnableAdapter</strong> 的构造函数，这个方法采用了设计模式中的适配器模式，将一个Runnable类型对象适配成Callable类型。当然 <strong>result</strong> 参数的存在只是为了将一个Runnable 类型适配成 Callable 类型，确实没什么实际意义。   </p><h3 id="4-4、源码分析——执行-run方法"><a href="#4-4、源码分析——执行-run方法" class="headerlink" title="4.4、源码分析——执行(run方法)"></a>4.4、源码分析——执行(run方法)</h3><h4 id="4-4-1、执行-run方法-——执行逻辑"><a href="#4-4-1、执行-run方法-——执行逻辑" class="headerlink" title="4.4.1、执行(run方法)——执行逻辑"></a>4.4.1、执行(run方法)——执行逻辑</h4><p><strong>FutureTask</strong> 实现了 <strong>Runnable</strong>，覆写了 <strong>run</strong> 方法，即用于异步执行的线程逻辑。<strong>Callable</strong> 即是需要执行的业务逻辑，他是业务逻辑的基本表现形式，保存在类属性callable，在run函数里面，调用callalbe.call()来执行业务逻辑。下面从源码来了解具体的执行逻辑：<br></p><pre class="line-numbers language-Java" data-language="Java"><code class="language-Java">// FutureTask.javapublic void run() {    //1、判断是否满足执行条件，满足条件设置runner属性    if (state != NEW ||        !RUNNER.compareAndSet(this, null, Thread.currentThread()))        return;    try {        // 2、具体执行业务逻辑，根据执行情况做不同处理        Callable&lt;V&gt; c = callable;        // 执行前再次判断状态        if (c != null &amp;&amp; state == NEW) {            V result;            // 执行状态标识            boolean ran;            try {                // 具体业务执行                result = c.call();                ran = true;            } catch (Throwable ex) {                result = null;                ran = false;                // 失败结果集设置                setException(ex);            }            if (ran)            // 成功结果集设置                set(result);        }    } finally {        //3、执行完的后处理逻辑        runner = null;                int s = state;        if (s &gt;= INTERRUPTING)            handlePossibleCancellationInterrupt(s);    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><br>从源码可知，具体执行共三步：<p></p><ol><li>判断是否满足执行条件，满足条件设置runner属性<ul><li>判断任务状态是否为 <strong>NEW</strong> 状态，如果不是，则可能执行完毕或已经被取消，所以直接返回。</li><li>如果任务为 <strong>NEW</strong> 状态，则通过 <strong>CAS操作</strong> 将 <strong>runner</strong> 置为当前正在执行异步任务的线程。此处有两种情况：<ul><li><strong>runner!=null</strong>：则说明任务依旧处于NEW状态，但已经有线程在执行该任务，所以无需再次执行，CAS操作失败，直接返回。</li><li><strong>runner==null</strong> ：说明还未有线程执行过异步任务，此时满足执行异步任务的条件，CAS操作成功，继续执行任务。</li></ul></li></ul></li><li>具体执行，并根据结果进行相关操作<ul><li><strong>if (c != null &amp;&amp; state == NEW)</strong>：再次判断任务状态，状态为NEW则继续执行。</li><li><strong>result = c.call();</strong>：调用call()方法执行具体的业务逻辑，根据结果进行操作。<ul><li>失败则进入异常操作设置结果集 <strong>setException(ex)</strong>；并设置失败标识 <strong>ran = false</strong>。</li><li>成功则设置成功标识 <strong>ran = true</strong> ，并进行成功后结果集的设置 <strong>set(result)</strong>；</li></ul></li></ul></li><li>后处理逻辑<br>不管异步任务执行成功还是失败，首先将当前执行任务线程 <strong>runner</strong> 置为空，若其他线程有调用 <strong>FutureTask.cancel(true)</strong>，此时需要调用<strong>handlePossibleCancellationInterrupt</strong> 方法处理中断。</li></ol><h4 id="4-4-2、执行-run方法-——Java线程的实现"><a href="#4-4-2、执行-run方法-——Java线程的实现" class="headerlink" title="4.4.2、执行(run方法)——Java线程的实现"></a>4.4.2、执行(run方法)——Java线程的实现</h4><p>Java线程的使用方式有很多，但最后都会归于 <strong>Thread.start()</strong>方法，无论是使用 Thread 直接调用 start()方法还是使用线程池进行多线程调用，最终都会归于此处。start()内容：<br></p><pre class="line-numbers language-Java" data-language="Java"><code class="language-Java">// Thread.javapublic synchronized void start() {        if (threadStatus != 0)            throw new IllegalThreadStateException();        group.add(this);        boolean started = false;        try {            start0();            started = true;        } finally {            try {                if (!started) {                    group.threadStartFailed(this);                }            } catch (Throwable ignore) {                /* do nothing. If start0 threw a Throwable then                  it will be passed up the call stack */            }        }    }// 本地方法startprivate native void start0();// 注册本地方法栈private static native void registerNatives();static {    registerNatives();}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><br>可以看到，最终实现都是调用本地方法栈的 <strong>start0();</strong>。而这些native方法的注册是在Thread对象初始化的时候完成的，即上面的静态代码块内调用的 <strong>registerNatives();</strong> 。当该类被加载到 JVM 中的时候，它就会被调用，进而注册相应的本地方法。<p></p><p>而本地方法 <strong>registerNatives</strong> 是定义在 Thread.c 文件中的。Thread.c 是个很小的文件，它定义了各个操作系统平台都要用到的关于线程的公用数据和操作，如下：<br></p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token comment">// openJdk-10版本  THread.c</span><span class="token keyword">static</span> JNINativeMethod methods<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">{</span>    <span class="token punctuation">{</span><span class="token string">"start0"</span><span class="token punctuation">,</span>           <span class="token string">"()V"</span><span class="token punctuation">,</span>        <span class="token punctuation">(</span><span class="token keyword">void</span> <span class="token operator">*</span><span class="token punctuation">)</span><span class="token operator">&amp;</span>JVM_StartThread<span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token comment">//java start0</span>    <span class="token punctuation">{</span><span class="token string">"stop0"</span><span class="token punctuation">,</span>            <span class="token string">"("</span> OBJ <span class="token string">")V"</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token keyword">void</span> <span class="token operator">*</span><span class="token punctuation">)</span><span class="token operator">&amp;</span>JVM_StopThread<span class="token punctuation">}</span><span class="token punctuation">,</span>    <span class="token punctuation">{</span><span class="token string">"isAlive"</span><span class="token punctuation">,</span>          <span class="token string">"()Z"</span><span class="token punctuation">,</span>        <span class="token punctuation">(</span><span class="token keyword">void</span> <span class="token operator">*</span><span class="token punctuation">)</span><span class="token operator">&amp;</span>JVM_IsThreadAlive<span class="token punctuation">}</span><span class="token punctuation">,</span>    <span class="token punctuation">{</span><span class="token string">"suspend0"</span><span class="token punctuation">,</span>         <span class="token string">"()V"</span><span class="token punctuation">,</span>        <span class="token punctuation">(</span><span class="token keyword">void</span> <span class="token operator">*</span><span class="token punctuation">)</span><span class="token operator">&amp;</span>JVM_SuspendThread<span class="token punctuation">}</span><span class="token punctuation">,</span>    <span class="token punctuation">{</span><span class="token string">"resume0"</span><span class="token punctuation">,</span>          <span class="token string">"()V"</span><span class="token punctuation">,</span>        <span class="token punctuation">(</span><span class="token keyword">void</span> <span class="token operator">*</span><span class="token punctuation">)</span><span class="token operator">&amp;</span>JVM_ResumeThread<span class="token punctuation">}</span><span class="token punctuation">,</span>    <span class="token punctuation">{</span><span class="token string">"setPriority0"</span><span class="token punctuation">,</span>     <span class="token string">"(I)V"</span><span class="token punctuation">,</span>       <span class="token punctuation">(</span><span class="token keyword">void</span> <span class="token operator">*</span><span class="token punctuation">)</span><span class="token operator">&amp;</span>JVM_SetThreadPriority<span class="token punctuation">}</span><span class="token punctuation">,</span>    <span class="token punctuation">{</span><span class="token string">"yield"</span><span class="token punctuation">,</span>            <span class="token string">"()V"</span><span class="token punctuation">,</span>        <span class="token punctuation">(</span><span class="token keyword">void</span> <span class="token operator">*</span><span class="token punctuation">)</span><span class="token operator">&amp;</span>JVM_Yield<span class="token punctuation">}</span><span class="token punctuation">,</span>    <span class="token punctuation">{</span><span class="token string">"sleep"</span><span class="token punctuation">,</span>            <span class="token string">"(J)V"</span><span class="token punctuation">,</span>       <span class="token punctuation">(</span><span class="token keyword">void</span> <span class="token operator">*</span><span class="token punctuation">)</span><span class="token operator">&amp;</span>JVM_Sleep<span class="token punctuation">}</span><span class="token punctuation">,</span>    <span class="token punctuation">{</span><span class="token string">"currentThread"</span><span class="token punctuation">,</span>    <span class="token string">"()"</span> THD<span class="token punctuation">,</span>     <span class="token punctuation">(</span><span class="token keyword">void</span> <span class="token operator">*</span><span class="token punctuation">)</span><span class="token operator">&amp;</span>JVM_CurrentThread<span class="token punctuation">}</span><span class="token punctuation">,</span>    <span class="token punctuation">{</span><span class="token string">"countStackFrames"</span><span class="token punctuation">,</span> <span class="token string">"()I"</span><span class="token punctuation">,</span>        <span class="token punctuation">(</span><span class="token keyword">void</span> <span class="token operator">*</span><span class="token punctuation">)</span><span class="token operator">&amp;</span>JVM_CountStackFrames<span class="token punctuation">}</span><span class="token punctuation">,</span>    <span class="token punctuation">{</span><span class="token string">"interrupt0"</span><span class="token punctuation">,</span>       <span class="token string">"()V"</span><span class="token punctuation">,</span>        <span class="token punctuation">(</span><span class="token keyword">void</span> <span class="token operator">*</span><span class="token punctuation">)</span><span class="token operator">&amp;</span>JVM_Interrupt<span class="token punctuation">}</span><span class="token punctuation">,</span>    <span class="token punctuation">{</span><span class="token string">"isInterrupted"</span><span class="token punctuation">,</span>    <span class="token string">"(Z)Z"</span><span class="token punctuation">,</span>       <span class="token punctuation">(</span><span class="token keyword">void</span> <span class="token operator">*</span><span class="token punctuation">)</span><span class="token operator">&amp;</span>JVM_IsInterrupted<span class="token punctuation">}</span><span class="token punctuation">,</span>    <span class="token punctuation">{</span><span class="token string">"holdsLock"</span><span class="token punctuation">,</span>        <span class="token string">"("</span> OBJ <span class="token string">")Z"</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token keyword">void</span> <span class="token operator">*</span><span class="token punctuation">)</span><span class="token operator">&amp;</span>JVM_HoldsLock<span class="token punctuation">}</span><span class="token punctuation">,</span>    <span class="token punctuation">{</span><span class="token string">"getThreads"</span><span class="token punctuation">,</span>        <span class="token string">"()["</span> THD<span class="token punctuation">,</span>   <span class="token punctuation">(</span><span class="token keyword">void</span> <span class="token operator">*</span><span class="token punctuation">)</span><span class="token operator">&amp;</span>JVM_GetAllThreads<span class="token punctuation">}</span><span class="token punctuation">,</span>    <span class="token punctuation">{</span><span class="token string">"dumpThreads"</span><span class="token punctuation">,</span>      <span class="token string">"(["</span> THD <span class="token string">")[["</span> STE<span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token keyword">void</span> <span class="token operator">*</span><span class="token punctuation">)</span><span class="token operator">&amp;</span>JVM_DumpThreads<span class="token punctuation">}</span><span class="token punctuation">,</span>    <span class="token punctuation">{</span><span class="token string">"setNativeName"</span><span class="token punctuation">,</span>    <span class="token string">"("</span> STR <span class="token string">")V"</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token keyword">void</span> <span class="token operator">*</span><span class="token punctuation">)</span><span class="token operator">&amp;</span>JVM_SetNativeThreadName<span class="token punctuation">}</span><span class="token punctuation">,</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">undef</span> <span class="token expression">THD</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">undef</span> <span class="token expression">OBJ</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">undef</span> <span class="token expression">STE</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">undef</span> <span class="token expression">STR</span></span>JNIEXPORT <span class="token keyword">void</span> JNICALL<span class="token function">Java_java_lang_Thread_registerNatives</span><span class="token punctuation">(</span>JNIEnv <span class="token operator">*</span>env<span class="token punctuation">,</span> jclass cls<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token punctuation">(</span><span class="token operator">*</span>env<span class="token punctuation">)</span><span class="token operator">-&gt;</span><span class="token function">RegisterNatives</span><span class="token punctuation">(</span>env<span class="token punctuation">,</span> cls<span class="token punctuation">,</span> methods<span class="token punctuation">,</span> <span class="token function">ARRAY_LENGTH</span><span class="token punctuation">(</span>methods<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><br>下面就要找具体是怎么调用的 <strong>Thread.run()</strong> 方法，在 jvm.cpp 中有如下代码：<br><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">// hotSpot-10版本  jvm.cpp</span><span class="token function">JVM_ENTRY</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">,</span> <span class="token function">JVM_StartThread</span><span class="token punctuation">(</span>JNIEnv<span class="token operator">*</span> env<span class="token punctuation">,</span> jobject jthread<span class="token punctuation">)</span><span class="token punctuation">)</span>  <span class="token function">JVMWrapper</span><span class="token punctuation">(</span><span class="token string">"JVM_StartThread"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  JavaThread <span class="token operator">*</span>native_thread <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>  <span class="token keyword">bool</span> throw_illegal_thread_state <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>  <span class="token punctuation">{</span>    MutexLocker <span class="token function">mu</span><span class="token punctuation">(</span>Threads_lock<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>java_lang_Thread<span class="token double-colon punctuation">::</span><span class="token function">thread</span><span class="token punctuation">(</span><span class="token class-name">JNIHandles</span><span class="token double-colon punctuation">::</span><span class="token function">resolve_non_null</span><span class="token punctuation">(</span>jthread<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token constant">NULL</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>      throw_illegal_thread_state <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>      jlong size <span class="token operator">=</span>             java_lang_Thread<span class="token double-colon punctuation">::</span><span class="token function">stackSize</span><span class="token punctuation">(</span><span class="token class-name">JNIHandles</span><span class="token double-colon punctuation">::</span><span class="token function">resolve_non_null</span><span class="token punctuation">(</span>jthread<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token function">NOT_LP64</span><span class="token punctuation">(</span><span class="token keyword">if</span> <span class="token punctuation">(</span>size <span class="token operator">&gt;</span> SIZE_MAX<span class="token punctuation">)</span> size <span class="token operator">=</span> SIZE_MAX<span class="token punctuation">;</span><span class="token punctuation">)</span>      size_t sz <span class="token operator">=</span> size <span class="token operator">&gt;</span> <span class="token number">0</span> <span class="token operator">?</span> <span class="token punctuation">(</span>size_t<span class="token punctuation">)</span> size <span class="token operator">:</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token comment">//主要看这里</span>      native_thread <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token function">JavaThread</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>thread_entry<span class="token punctuation">,</span> sz<span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token keyword">if</span> <span class="token punctuation">(</span>native_thread<span class="token operator">-&gt;</span><span class="token function">osthread</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token constant">NULL</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                native_thread<span class="token operator">-&gt;</span><span class="token function">prepare</span><span class="token punctuation">(</span>jthread<span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token punctuation">}</span>    <span class="token punctuation">}</span>  <span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><br>这里JVM_ENTRY是一个宏，用来定义JVM_StartThread 函数，可以看到函数内创建了真正的平台相关的本地线程，其线程函数是<strong>thread_entry</strong>，如下：<br><pre class="line-numbers language-Java" data-language="Java"><code class="language-Java">// hotSpot-10版本  jvm.cppstatic void thread_entry(JavaThread* thread, TRAPS) {    HandleMark hm(THREAD);    Handle obj(THREAD, thread-&gt;threadObj());    JavaValue result(T_VOID);    JavaCalls::call_virtual(&amp;result,obj,    KlassHandle(THREAD,SystemDictionary::Thread_klass()),    vmSymbolHandles::run_method_name(),    //看这里    vmSymbolHandles::void_method_signature(),THREAD); }class vmSymbolHandles: AllStatic {   ...    template(run_method_name,"run")  //这里!!! 这里决定了调用的方法名称是 “run”!   ...}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><br>自此调用流程就清晰了：<br><img src="https://raw.githubusercontent.com/cmeng-CM/image-hosting/master/img/java/多线程/Thread-JVM运行机制.png" alt="Thread-JVM运行机制.png"> <p></p><h4 id="4-4-3、执行-run方法-——成功结果set"><a href="#4-4-3、执行-run方法-——成功结果set" class="headerlink" title="4.4.3、执行(run方法)——成功结果set()"></a>4.4.3、执行(run方法)——成功结果set()</h4><p>老规矩，首先看源码：<br></p><pre class="line-numbers language-Java" data-language="Java"><code class="language-Java">// FutureTask.javaprotected void set(V v) {    if (STATE.compareAndSet(this, NEW, COMPLETING)) {        outcome = v;        STATE.setRelease(this, NORMAL); // final state        finishCompletion();    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><br>该方法的调用只有通过 <strong>FutureTask.run()</strong> 方法才可以被调用，而 run 方法本身能执行到此处也是不会存在多线程的情况，因为能进行的前置要求存在 <strong>CAS操作修改状态</strong> 的步骤，由此分析其代码逻辑及含义：<p></p><ol><li>状态校验<br>其校验操作位<strong>CAS修改NEW状态为COMPLETING</strong>，所以只有状态为 <strong>NEW</strong> 的任务才可以进入其操作逻辑。这么做的意义在于执行<strong>run</strong> 方法逻辑时可能存在<strong>cancel</strong> 方法被调用，所以需要CAS操作来保证任务的状态为 NEW 才可以进入结果集设置的操作。</li><li>设置结果集<br>根据执行结果即 <strong>set的入参：V</strong> 设置返回结果集。</li><li>修改状态<br>将任务状态设置为 <strong>NORMAL</strong>，表示任务正常结束。此处对应的状态变化为：<strong>NEW -&gt; COMPLETING -&gt; NORMAL。</strong> </li><li>唤醒阻塞进程<br>调用任务执行完成方法，此时会唤醒阻塞的线程，调用done()方法和清空等待线程链表等。具体阻塞的进程的来源，上面聊队列的时候分析过具体的原因和情况。</li></ol><h4 id="4-4-4、执行-run方法-——异常结果setException"><a href="#4-4-4、执行-run方法-——异常结果setException" class="headerlink" title="4.4.4、执行(run方法)——异常结果setException()"></a>4.4.4、执行(run方法)——异常结果setException()</h4><p>先上源码：<br></p><pre class="line-numbers language-Java" data-language="Java"><code class="language-Java">// FutureTask.javaprotected void setException(Throwable t) {    if (STATE.compareAndSet(this, NEW, COMPLETING)) {        outcome = t;        STATE.setRelease(this, EXCEPTIONAL); // final state        finishCompletion();    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><br>可以看到 <strong>setException</strong> 内的逻辑与 <strong>set</strong> 基本一致，区别在于返回结果此处是将异常设置进去，终态设置为 <strong>EXCEPTIONAL</strong> ，其它无区别。此处状态转换为： <strong>NEW -&gt; COMPLETING -&gt; EXCEPTIONAL。</strong><p></p><h4 id="4-4-5、执行-run方法-——finishCompletion"><a href="#4-4-5、执行-run方法-——finishCompletion" class="headerlink" title="4.4.5、执行(run方法)——finishCompletion()"></a>4.4.5、执行(run方法)——finishCompletion()</h4><p>先上源码：<br></p><pre class="line-numbers language-Java" data-language="Java"><code class="language-Java">// FutureTask.javaprivate void finishCompletion() {    // assert state &gt; COMPLETING;    // 根据 get 方法阻塞的队列，进行唤醒、移除等操作，若是get方法未被调用，则不进入循环    for (WaitNode q; (q = waiters) != null;) {        if (WAITERS.weakCompareAndSet(this, q, null)) {            for (;;) {                Thread t = q.thread;                if (t != null) {                    q.thread = null;                    // 唤醒线程                    LockSupport.unpark(t);                }                WaitNode next = q.next;                if (next == null)                    break;                q.next = null; // unlink to help gc                q = next;            }            break;        }    }    // 无论有无阻塞队列，都调用done()，FutureTask内done()无任务实现内容。    done();    // 任务已执行完毕，已将结果存储至outcome中，因此将callable属性置为空    callable = null;        // to reduce footprint}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><br>此处主要是针对 <strong>waiters</strong> 内被阻塞的线程队列，针对阻塞的线程进行唤醒、移除等操作。由于FutureTask中的队列本质上是一个Treiber栈，因此操作的顺序是 <strong>后进先出</strong> 即后面先来的线程先被先操作。  <p></p><h4 id="4-4-6、执行-run方法-——执行完成共有操作handlePossibleCancellationInterrupt"><a href="#4-4-6、执行-run方法-——执行完成共有操作handlePossibleCancellationInterrupt" class="headerlink" title="4.4.6、执行(run方法)——执行完成共有操作handlePossibleCancellationInterrupt()"></a>4.4.6、执行(run方法)——执行完成共有操作handlePossibleCancellationInterrupt()</h4><p>先上源码：<br></p><pre class="line-numbers language-Java" data-language="Java"><code class="language-Java">private void handlePossibleCancellationInterrupt(int s) {    if (s == INTERRUPTING)        while (state == INTERRUPTING)            Thread.yield(); // wait out pending interrupt    }<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><br>可见该方法是一个自旋操作，如果当前的state状态是 <strong>INTERRUPTING</strong>，我们在原地自旋，直到 <strong>state</strong> 状态转换成终止态。意义在于：检查是否有遗漏的中断，如果有，等待中断状态完成。具体 <strong>handlePossibleCancellationInterrupt</strong> 为什么在任务执行完毕后调用，等聊到 <strong>cancel()</strong> 方法再详细分析。<p></p><h3 id="4-5、源码分析——获取执行结果"><a href="#4-5、源码分析——获取执行结果" class="headerlink" title="4.5、源码分析——获取执行结果"></a>4.5、源码分析——获取执行结果</h3><h4 id="4-5-1、获取执行结果——get"><a href="#4-5-1、获取执行结果——get" class="headerlink" title="4.5.1、获取执行结果——get()"></a>4.5.1、获取执行结果——get()</h4><p>先上源码：<br></p><pre class="line-numbers language-Java" data-language="Java"><code class="language-Java">public V get() throws InterruptedException, ExecutionException {        int s = state;        if (s &lt;= COMPLETING)            s = awaitDone(false, 0L);        return report(s);    }/**    * @throws CancellationException {@inheritDoc}    */public V get(long timeout, TimeUnit unit)    throws InterruptedException, ExecutionException, TimeoutException {    if (unit == null)        throw new NullPointerException();    int s = state;    if (s &lt;= COMPLETING &amp;&amp;        (s = awaitDone(true, unit.toNanos(timeout))) &lt;= COMPLETING)        throw new TimeoutException();    return report(s);}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><br>由源码可知，获取执行结果有两个方法：<p></p><ul><li><strong>get()</strong>：获取执行结果，如果未执行完毕，则阻塞等待。</li><li><strong>get(long timeout, TimeUnit unit)</strong>：获取执行结果，并设置超时时间，如果未超时则阻塞等待，如果已超时则 <strong>移除当前阻塞线程</strong> 并 <strong>直接返回当前执行状态</strong><br>除了后者存在超时时间设置外，其他执行逻辑并无区别，主要阻塞获取执行结果的方法都是 <strong>awaitDone</strong> 下面详细分析下此方法。</li></ul><h4 id="4-5-2、获取执行结果——awaitDone"><a href="#4-5-2、获取执行结果——awaitDone" class="headerlink" title="4.5.2、获取执行结果——awaitDone()"></a>4.5.2、获取执行结果——awaitDone()</h4><p>先上源码：<br></p><pre class="line-numbers language-Java" data-language="Java"><code class="language-Java">private int awaitDone(boolean timed, long nanos)        throws InterruptedException {        //超时相关设置    long startTime = 0L;    // 线程链表头节点    WaitNode q = null;    //是否已入阻塞队列    boolean queued = false;    for (;;) {        // 【1-4】状态校验，如果已执行完毕，且当前队列节点不为空则将队列当前线程置为空后返回状态。如果当前队列节点为空则直接返回状态        int s = state;        if (s &gt; COMPLETING) {            if (q != null)                q.thread = null;            return s;        }        // 状态为COMPLETING则说明正在设置结果集，当前线程让出CPU时间片段，等待设置结果集完毕        else if (s == COMPLETING)            Thread.yield();        // 【3-1】当前执行线程被中断，则移除队列节点，抛出中断异常        else if (Thread.interrupted()) {            removeWaiter(q);            throw new InterruptedException();        }        // 【1-1】当前线程还未进入阻塞队列，则创建包含当前线程信息的队列节点。        else if (q == null) {            if (timed &amp;&amp; nanos &lt;= 0L)                return s;            q = new WaitNode();        }        // 【1-2】如果当前队列节点未入阻塞队列，则加入队列头部        else if (!queued)            queued = WAITERS.weakCompareAndSet(this, q.next = waiters, q);                // 【2-1】若有超时设置，那么处理超时获取任务结果的逻辑        else if (timed) {            final long parkNanos;            if (startTime == 0L) { // first time                startTime = System.nanoTime();                if (startTime == 0L)                    startTime = 1L;                parkNanos = nanos;            } else {                long elapsed = System.nanoTime() - startTime;                if (elapsed &gt;= nanos) {                    removeWaiter(q);                    return state;                }                parkNanos = nanos - elapsed;            }            // nanoTime may be slow; recheck before parking            if (state &lt; COMPLETING)                LockSupport.parkNanos(this, parkNanos);        }        // 【1-3】阻塞当前线程        else            LockSupport.park(this);    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><br>获取结果集的自旋循环处理逻辑，存在多个分支处理，每个分支的校验条件和操作逻辑均已在注释中描述，那么下面就看下每次循环都会执行哪些分支，同时进一步了解为什么每个分支的逻辑如此设计。<p></p><p><strong>情况 1：1、任务状态为NEW；2、无超时时间设置时，3、不存在中断操做时。循环内的情况</strong>：</p><ol><li>第一次循环：<br>此时 <strong>q=null</strong>，进入队列节点创建操作，即：【1-1】，操作完此次循环结束。此时队列节点已创建，但尚未放入阻塞队列内。</li><li>第二次循环：<br>此时  <strong>queued=false</strong>，进入将当前节点放入阻塞队列操作，即【1-2】，操作完此次循环结束。</li><li>第三次循环<br>当前队列节点已创建且已放入阻塞队列，此时进入阻塞阶段，即【1-3】，操作完成循环结束。</li><li>第四次循环<br>此时任务已执行完毕，阻塞线程被激活，进入结果集获取操作，即【1-4】，<strong>awaitDone</strong> 方法执行完毕，返回异步任务结果集。</li></ol><p><strong>情况 2：1、任务状态为NEW；2、存在超时时间设置时，3、不存在中断操做时。循环内的情况</strong>：<br>则在【1-3】和【1-4】中间加入【2-1】超时判断操作。其它同 <strong>情况1</strong>。</p><p><strong>情况 3：1、任务状态为NEW；2、无超时时间设置时，3、存在中断操做时。循环内情况：</strong><br>直接进入中断操作，移除当前队列节点，抛出异常即【3-1】。任务执行和任务取消都调用 <strong>finishCompletion()</strong> 方法，那么此处调用的意义在哪？此处调用意义：执行 <strong>awaitDone</strong> 时存在一种情况，即刚进行队列节点创建但还未将队列节点放入阻塞队列即【第一次循环】时。此时进行任务中断则队列节点无法在 <strong>finishCompletion()</strong> 中移除，所以需要在此处进行置空操作，方便GC回收。</p><p><strong>情况 4：1、任务状态为不为NEW。循环内情况：</strong><br>直接返回当前任务状态，存在当前队列节点则移除当前队列节点即【1-4】。原因类似 <strong>情况2</strong>，只不过中断操作变为任务完成。</p><h4 id="4-5-3、获取执行结果——report"><a href="#4-5-3、获取执行结果——report" class="headerlink" title="4.5.3、获取执行结果——report()"></a>4.5.3、获取执行结果——report()</h4><p>先上源码：<br></p><pre class="line-numbers language-Java" data-language="Java"><code class="language-Java">private V report(int s) throws ExecutionException {    Object x = outcome;    if (s == NORMAL)        return (V)x;    if (s &gt;= CANCELLED)        throw new CancellationException();    throw new ExecutionException((Throwable)x);}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><br>根据状态获取结果集就很简单了，一共三个分支：<p></p><ol><li>状态为 <strong>NORMAL</strong>：即正常执行完成，返回 <strong>Callable.call()</strong> 方法执行结果即可。</li><li>状态 <strong>s &gt;= CANCELLED</strong>，说明存在取消情况，则抛出中断异常。</li><li>其它状态为执行过程存在异常，则将异常类返回即可。</li></ol><h3 id="4-6、源码分析——取消任务"><a href="#4-6、源码分析——取消任务" class="headerlink" title="4.6、源码分析——取消任务"></a>4.6、源码分析——取消任务</h3><p>线上源码：<br></p><pre class="line-numbers language-Java" data-language="Java"><code class="language-Java">public boolean cancel(boolean mayInterruptIfRunning) {    // 任务状态为NEW且根据mayInterruptIfRunning参数修改状态为INTERRUPTING或CANCELLED，二者任一    // 失败或同时失败均返回 False    if (!(state == NEW &amp;&amp; STATE.compareAndSet            (this, NEW, mayInterruptIfRunning ? INTERRUPTING : CANCELLED)))        return false;    try {            // 如果mayInterruptIfRunning=true，则获取当前任务执行线程，进行中断操作        if (mayInterruptIfRunning) {            try {                Thread t = runner;                if (t != null)                    t.interrupt();            } finally { // final state                // 最后任务状态赋值为INTERRUPTED                STATE.setRelease(this, INTERRUPTED);            }        }    } finally {        // 针对阻塞进程进行唤醒、移除等操作        finishCompletion();    }    return true;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><br>由源码可知：<p></p><ol><li>状态校验：<ul><li>状态不为NEW，直接返回false</li><li>状态为NEW，根据参数 <strong>mayInterruptIfRunning</strong> 不同值，进行不同的状态修改，此处修改为CAS操作，修改失败则返回false。成功则继续执行取消操作。</li></ul></li><li><p>根据 mayInterruptIfRunning 不同值进行操作：</p><ul><li>为flase：跳过 <strong>try</strong> 代码块，直接执行 <strong>finally</strong> 操作。此时状态变化为：<strong>NEW -&gt; CANCELLED。</strong></li><li>为true：则 <strong>runner==null</strong>，因为可能存在此时任务已经执行完成，将 runner 置为空了。如果不为空，则发送线程中断信号，发送中中断信号并不代表一定会真正的中断线程。此时状态变化为：<strong>NEW -&gt; INTERRUPTING -&gt; INTERRUPTED</strong>。</li></ul></li><li><p>唤醒阻塞线程<br>无论 <strong>mayInterruptIfRunning</strong> 参数为何值，最终都会唤醒阻塞的线程，即调用 <strong>finishCompletion</strong> 方法，因为此时任务已经是终态了。 <strong>cancel()</strong> 方法返回true。<br>如果<strong>cancel()</strong> 返回true了，那么线程无论最终是否执行，<strong>get()</strong> 方法都会抛出<strong>CancellationException</strong>异常，因为 <strong>report(int s)</strong> 内会校验 <strong>s &gt;= CANCELLED</strong>，具体可看上一节的 <strong>report()</strong>源码。</p></li></ol><h3 id=""><a href="#" class="headerlink" title=" "></a> </h3><h3 id="4-7、源码分析——移除任务"><a href="#4-7、源码分析——移除任务" class="headerlink" title="4.7、源码分析——移除任务"></a>4.7、源码分析——移除任务</h3><pre class="line-numbers language-Java" data-language="Java"><code class="language-Java">private void removeWaiter(WaitNode node) {    if (node != null) {        node.thread = null;        retry:        for (;;) {          // restart on removeWaiter race            for (WaitNode pred = null, q = waiters, s; q != null; q = s) {                s = q.next;                if (q.thread != null)                    pred = q;                else if (pred != null) {                    pred.next = s;                    if (pred.thread == null) // check for race                        continue retry;                }                else if (!WAITERS.compareAndSet(this, q, s))                    continue retry;            }            break;        }    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>移除指定节点，该方法仅在 <strong>awaitDone</strong> 方法内 <strong>等待执行结果超时</strong> 和 <strong>遇到线程中断</strong> 时调用。</p><h2 id="五、总结"><a href="#五、总结" class="headerlink" title="五、总结"></a>五、总结</h2><p>至此 <strong>FutureTask</strong> 体系相关的逻辑已经分析完毕。直接使用就只关心三块内容即可：</p><ol><li>Callable实现想要做的业务逻辑，</li><li>构建FutureTask类。</li><li>使用 Thread或ExecutorService来执行，并在执行后阻塞获取执行结果。</li></ol><p><strong>Callable</strong>也可直接执行，但只能通过 <strong>ExecutorService.submit</strong> 方法来执行，但内部实际上还是转换为FutureTask来执行，FutureTask则既可以 <strong>ExecutorService.submit</strong> 来执行，也可以直接使用 <strong>Thread</strong> 来直接执行，因为它既实现 <strong>Runnable</strong> 又实现了 <strong>Future</strong> 。</p><p><strong>FutureTask</strong> 内部则关系主要是 <strong>runner,waiters和state</strong> 这三个属性的定义概念和执行逻辑理清晰差不多也就把<strong>FutureTask</strong> 理解透彻了。</p><p>至此 <strong>future体系</strong> 算是分析完毕了。</p><p>参考：<br><a href="https://juejin.cn/post/6844903774985650183">https://juejin.cn/post/6844903774985650183</a><br><a href="https://segmentfault.com/a/1190000015739343">https://segmentfault.com/a/1190000015739343</a></p>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
          <category> 多线程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JVM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>回溯</title>
      <link href="/2020/08/17/algorithm/back-tracking/"/>
      <url>/2020/08/17/algorithm/back-tracking/</url>
      
        <content type="html"><![CDATA[<h2 id="回溯"><a href="#回溯" class="headerlink" title="回溯"></a>回溯</h2><h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a><strong>概述</strong></h3><p><strong>回溯法</strong>（英语：backtracking）是暴力搜索法中的一种。<br>对于某些计算问题而言，回溯法是一种可以找出所有（或一部分）解的一般性算法，尤其适用于约束满足问题（在解决约束满足问题时，我们逐步构造更多的候选解，并且在确定某一部分候选解不可能补全成正确解之后放弃继续搜索这个部分候选解本身及其可以拓展出的子候选解，转而测试其他的部分候选解）。  </p><p>回溯算法又称 <font color="#0099ff">试探法</font>，采用试错的思想。在分步解决问题的过程中，当它通过尝试发现，现有的分步答案不能得到有效的正确的解答的时候，它将取消上一步甚至是上几步的计算，再通过其它的可能的分步解答再次尝试寻找问题的答案。回溯法通常用最简单的递归方法来实现，在反复重复上述的步骤后可能出现两种情况：</p><ul><li>找到一个可能存在的正确的答案</li><li>在尝试了所有可能的分步方法后宣告该问题没有答案  </li></ul><p>在最坏的情况下，回溯法会导致一次复杂度为指数时间的计算。</p><p><strong>例如:</strong><br>在统计1~N中整数的所有子集问题时，就可以使用 <font color="#0099ff">回溯法</font> 进行处理。从1开始每个数字都有两种可能，存在子集或不存在子集，每种可能都会有一种结果，那么问题的结果就是所有可能的子集的集合。</p><h3 id="实例"><a href="#实例" class="headerlink" title="实例"></a><strong>实例</strong></h3><p><strong>1. 实例1</strong><br><a href="https://leetcode-cn.com/problems/subsets/"></a></p>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 回溯 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>二分查找法</title>
      <link href="/2020/08/17/algorithm/binary-search/"/>
      <url>/2020/08/17/algorithm/binary-search/</url>
      
        <content type="html"><![CDATA[<h2 id="二分查找法"><a href="#二分查找法" class="headerlink" title="二分查找法"></a>二分查找法</h2><h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a><strong>概述</strong></h3><p>二分搜索是一种在有序数组中查找某一特定元素的搜索算法。  </p><ul><li>搜索过程从数组的中间元素开始，如果中间元素正好是要查找的元素，则搜索过程结束；</li><li>如果某一特定元素大于或者小于中间元素，则在数组大于或小于中间元素的那一半中查找，而且跟开始一样从中间元素开始比较。</li><li>如果在某一步骤数组为空，则代表找不到。这种搜索算法每一次比较都使搜索范围缩小一半。</li></ul><h3 id="实例"><a href="#实例" class="headerlink" title="实例"></a><strong>实例</strong></h3><p><strong>1. 实例1</strong><br>给定一个 n 个元素有序的（升序）整型数组 nums 和一个目标值 target ，写一个函数搜索 nums 中的 target，如果目标值存在返回下标，否则返回 -1。  </p><p>示例1  </p><blockquote><p>输入: nums = [-1,0,3,5,9,12], target = 9<br>输出: 4<br>解释: 9 出现在 nums 中并且下标为 4  </p></blockquote><p>示例2  </p><blockquote><p>输入: nums = [-1,0,3,5,9,12], target = 2<br>输出: -1<br>解释: 2 不存在 nums 中因此返回 -1  </p></blockquote><p><strong>代码</strong><br></p><pre class="line-numbers language-Java" data-language="Java"><code class="language-Java">public int search(int[] nums, int target) {    int start = 0;    int end = nums.length-1;    while(start &lt;= end){        //取中间元素下标        int mid = start + (end - start)/2;        //比较大小，进行区间区分或直接返回结果        if(target == nums[mid])            return mid;        if(target &gt; nums[mid]){            start = mid + 1;        }else{            end = mid - 1;        }    }    return -1;    }<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p></p><p><strong>2. 实例2</strong><br>给定一个排序数组和一个目标值，在数组中找到目标值，并返回其索引。如果目标值不存在于数组中，返回它将会被按顺序插入的位置。</p><p>示例 1:  </p><blockquote><p>输入: nums = [1,3,5,6], target = 5<br>输出: 2  </p></blockquote><p>示例 2:  </p><blockquote><p>输入: nums = [1,3,5,6], target = 2<br>输出: 1</p></blockquote><p><strong>代码</strong><br></p><pre class="line-numbers language-Java" data-language="Java"><code class="language-Java">public int searchInsert(int[] nums, int target) {    int start = 0;    int end = nums.length - 1;    while (start &lt;= end){        int mid = start + (end - start) / 2 ;        if(target == nums[mid])            return mid;        if(target &gt; nums[mid])            start = mid + 1;        else            end = mid -1;    }    return start;    }<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p></p><p><strong>3. 实例3</strong><br><a href="https://leetcode-cn.com/problems/search-in-rotated-sorted-array/">leetcode-33. 搜索旋转排序数组</a>  </p><p>整数数组 nums 按升序排列，数组中的值 互不相同 。<br>在传递给函数之前，nums 在预先未知的某个下标 k（0 &lt;= k &lt; nums.length）上进行了 旋转，使数组变为 [nums[k], nums[k+1], …, nums[n-1], nums[0], nums[1], …, nums[k-1]]（下标 从 0 开始 计数）。例如， [0,1,2,4,5,6,7] 在下标 3 处经旋转后可能变为 [4,5,6,7,0,1,2] 。<br>给你 旋转后 的数组 nums 和一个整数 target ，如果 nums 中存在这个目标值 target ，则返回它的下标，否则返回 -1 。</p><p>示例 1：</p><blockquote><p>输入：nums = [4,5,6,7,0,1,2], target = 0<br>输出：4</p></blockquote><p>示例 2：</p><blockquote><p>输入：nums = [4,5,6,7,0,1,2], target = 3<br>输出：-1</p></blockquote><p><strong>解1：</strong> 根据其旋转坐标，可将数组分为两个升序数组。分别对二者进行二分法查找即可。</p><p><strong>代码</strong><br></p><pre class="line-numbers language-Java" data-language="Java"><code class="language-Java">public int search(int[] nums, int target) {    int size = nums.length;    int rotatedIndex=0;    //查询第一组升序的最大值下标    for(int i =0;i&lt;size-1;i++){        if(nums[i]&gt;nums[i+1]){            rotatedIndex = i;            break;        }    }    int ans1 = binarySearch(nums,target,0,rotatedIndex);    int ans2 = binarySearch(nums,target,rotatedIndex+1,size-1);    if(ans1!=-1){        return ans1;    }else if(ans2!=-1){        return ans2;    }else{        return -1;    }}public Integer binarySearch(int[] nums,int target,int left,int reight){    while(left&lt;=reight){        int mid = left + (reight - left) / 2;        if(nums[mid]==target){            return mid;        }else if(target&gt;nums[mid]){            left = mid + 1;        }else {            reight = mid - 1;        }    }    return -1;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><br><strong>解2：</strong> 直接进行二分法查找。数组旋转后一定分为各自两段有序数组，可进行如下步骤：<p></p><ol><li>进行二分操作,可分为两部分，一定有有一部分为有序数组</li><li>如果target在有序数组的部分，则以有序数组为基础继续进行二分法查找。</li><li>如果target不在有序数组部分，继续进行【1】操作</li></ol><pre class="line-numbers language-Java" data-language="Java"><code class="language-Java">public int search(int[] nums, int target) {    int n = nums.length;    if (n == 0) {        return -1;    }    if (n == 1) {        return nums[0] == target ? 0 : -1;    }    int l = 0, r = n - 1;    while (l &lt;= r) {        int mid = (l + r) / 2;        if (nums[mid] == target) {            return mid;        }        if (nums[0] &lt;= nums[mid]) {            if (nums[0] &lt;= target &amp;&amp; target &lt; nums[mid]) {                r = mid - 1;            } else {                l = mid + 1;            }        } else {            if (nums[mid] &lt; target &amp;&amp; target &lt;= nums[n - 1]) {                l = mid + 1;            } else {                r = mid - 1;            }        }    }    return -1;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 二分查找法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>双指针</title>
      <link href="/2020/08/17/algorithm/dual-pointers/"/>
      <url>/2020/08/17/algorithm/dual-pointers/</url>
      
        <content type="html"><![CDATA[<h2 id="双指针"><a href="#双指针" class="headerlink" title="双指针"></a>双指针</h2><h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a><strong>概述</strong></h3><p>双指针是一种简单而又灵活的技巧和思想，单独使用可以轻松解决一些特定问题，和其他算法结合也能发挥多样的用处。<br>双指针顾名思义，就是同时使用两个指针，在数组、序列、链表结构上指向的是位置，在树、图结构中指向的是节点，通过或同向移动，或相向移动来维护、统计信息。  </p><h3 id="实例"><a href="#实例" class="headerlink" title="实例"></a><strong>实例</strong></h3><p><strong>1. 实例1</strong><br><a href="https://leetcode-cn.com/problems/two-sum-ii-input-array-is-sorted/">leetcode-167. 两数之和 II - 输入有序数组</a><br>给你一个下标从 1 开始的整数数组 numbers ，该数组已按 非递减顺序排列  ，请你从数组中找出满足相加之和等于目标数 target 的两个数。如果设这两个数分别是 numbers[index1] 和 numbers[index2] ，则 1 &lt;= index1 &lt; index2 &lt;= numbers.length 。</p><p>以长度为 2 的整数数组 [index1, index2] 的形式返回这两个整数的下标 index1 和 index2。</p><p>你可以假设每个输入 只对应唯一的答案 ，而且你 不可以 重复使用相同的元素。</p><p>你所设计的解决方案必须只使用常量级的额外空间。</p><p>示例1  </p><blockquote><p>输入：numbers = [2,7,11,15], target = 9<br>输出：[1,2]<br>解释：2 与 7 之和等于目标数 9 。因此 index1 = 1, index2 = 2 。返回 [1, 2] 。</p></blockquote><p>给出数组为升序排序，所以双指针一头一尾，根据二者之和与目标值的大小比较来判断指针移动方向。</p><p><strong>代码</strong><br></p><pre class="line-numbers language-Java" data-language="Java"><code class="language-Java">public int[] twoSum(int[] numbers, int target) {    int[] ans = new int[2];    int n= numbers.length;    for(int i =0,j=n-1;i&lt;j;){        int sum = numbers[i]+numbers[j];        if(sum==target){            ans[0] = i+1;            ans[1] = j+1;            return ans;        }        if(sum&gt;target){            --j;        }else if (sum&lt;target){            ++i;        }    }    return ans;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p></p><p><strong>2. 实例2</strong><br><a href="https://leetcode-cn.com/problems/remove-nth-node-from-end-of-list/">leetcode-19. 删除链表的倒数第 N 个结点</a><br>给你一个链表，删除链表的倒数第 n 个结点，并且返回链表的头结点。  </p><p>示例 1:<br><img src="/image/algorithm/双指针1.jpg" alt="">  </p><blockquote><p>输入：head = [1,2,3,4,5], n = 2<br>输出：[1,2,3,5]</p></blockquote><p>双指针形式，当快慢两个指针之差为n时，二者保持同时移动，当快到达最后节点，慢指针正好符合删除的节点要求。</p><p><strong>代码</strong><br></p><pre class="line-numbers language-Java" data-language="Java"><code class="language-Java">public ListNode removeNthFromEnd(ListNode head, int n) {    ListNode zero = new ListNode(0, head);    ListNode slow = zero;    ListNode fast= head;    for(int i=0;i&lt;n;i++){        fast = fast.next;    }    while(fast!=null){        slow = slow.next;        fast =fast.next;    }    slow.next = slow.next.next;    return zero.next;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p></p>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 双指针 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>算法-时间复杂度</title>
      <link href="/2020/08/17/algorithm/shi-jian-fu-za-du/"/>
      <url>/2020/08/17/algorithm/shi-jian-fu-za-du/</url>
      
        <content type="html"><![CDATA[<h2 id="算法-时间复杂度"><a href="#算法-时间复杂度" class="headerlink" title="算法-时间复杂度"></a>算法-时间复杂度</h2><h3 id="1、数据结构-算法"><a href="#1、数据结构-算法" class="headerlink" title="1、数据结构-算法"></a>1、数据结构-算法</h3><p>数据结构和算法是相辅相成的，<strong>数据结构是为算法服务的，算法要作用在特定的数据结构之上</strong>。所以二者的学习不能互相孤立。</p><h3 id="2、算法复杂度分析"><a href="#2、算法复杂度分析" class="headerlink" title="2、算法复杂度分析"></a>2、算法复杂度分析</h3><ol><li>时间复杂度： 指算法需要消耗的时间资源。计算机算法是问题规模n 的函数f(n)，算法的时间复杂度也因此记做。<br>T(n)=Ο(f(n))</li><li>空间复杂度：算法需要消耗的空间资源。其计算和表示方法与时间复杂度类似，一般都用复杂度的渐近性来表示。同时间复杂度相比，空间复杂度的分析要简单得多。</li></ol><h4 id="2-1、事后统计法"><a href="#2-1、事后统计法" class="headerlink" title="2.1、事后统计法"></a>2.1、事后统计法</h4><p>事后统计法：通过统计、分析等，计算出算法的实际执行时间和实际内存占用，从而得到算法的时间复杂度。</p><ul><li>测试结果非常依赖测试环境。（服务器资源配置）</li><li>测试结果受限于数据规模</li></ul><h4 id="2-2、大O复杂度表示法"><a href="#2-2、大O复杂度表示法" class="headerlink" title="2.2、大O复杂度表示法"></a>2.2、大O复杂度表示法</h4><p>时间复杂度通俗来讲，就是代码运行的时间。大O表示法就是在不运算代码的情况下来分析一段代码的时间复杂度。<br>看下面的例子：<br></p><pre class="line-numbers language-Java" data-language="Java"><code class="language-Java">public void calculate(int n){  int sum = 0;  int i = 0;  for (;i&lt;n;++i){    sum = sum + i;  }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><br>从CPU的角度来看，代码的每一行都执行着类似的操作：<strong>读操作-运算-写操作</strong>。这里我们假设每行代码的执行时间一样，为unit_time，那么2，3行执行了1个unit_time，3，4行n个unit_time，总的执行时间就是（2n+2）<em>unit_time。<br>按照这个思路再来看下面一段代码：<br><pre class="line-numbers language-Java" data-language="Java"><code class="language-Java">public void cal(int n){  int sum = 0;  int i = 0;  int j = 0;  for (;i&lt;n;i++){    j = 1;    for (;j&lt;=n;j++){      sum += sum + i * j;    }  }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><br>依旧假设单位时间为unit_time，2、3、4行执行时间分别为1unti_time，5、6加起来就是2n。7、8加起来就是2n²unit_time;总的时间就为(2n²+2n+3)unit_time.<br>这两段代码分析我们可得到一个重要的规律，那就是<em>*代码的执行时间T(n)和每段代码的执次数成正比</em></em>，所以就得到了以下公式：<p></p><blockquote><font color="orange">T(n)=O(f(n))</font></blockquote><p>其中T(n)代表了代码的执行时间，n代表数据规模，f(n)代表每行代码执行的次数总和。因为是公式，所以用f(n)表达。公式中的O则表示代码执行时间T(n)和表达式f(n)成正比。   </p><p>两个例子中的T(n)=O(2n+2)和T(n)=O(2n²+2n+3)就是大O时间复杂度表示法，它并不代表具体的执行时间，而是代表<strong>代码的执行时间随着数据规模增加的变化趋势</strong>，所以也叫渐进时间复杂度（asymptotic time complexity），简称时间复杂度。  </p><p>当n很大时，表达式中的低阶、常量、系数等部分并不左右增长趋势，所以大O表示法可记为：T(n)=O(n)、T(n)=O(n²)。</p><h4 id="2-3-常见复杂度分析方法"><a href="#2-3-常见复杂度分析方法" class="headerlink" title="2.3 常见复杂度分析方法"></a>2.3 常见复杂度分析方法</h4><ol><li>单段代码看高频：如循环<pre class="line-numbers language-Java" data-language="Java"><code class="language-Java">public void calculate(int n){  int sum = 0;  int i = 0;  for (;i&lt;n;++i){    sum = sum + i;  }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li>多段代码取最高：如一段代码中存在单重循环和多重循环，则取多重循环。<pre class="line-numbers language-Java" data-language="Java"><code class="language-Java">public void cal(int n){  int temp = 0;  int a = 0;  for (;a&lt;n;++a){    temp = temp + i;  }  int sum = 0;  int i = 0;  int j = 0;  for (;i&lt;n;i++){    j = 1;    for (;j&lt;=n;j++){      sum += sum + i * j;    }  }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li>嵌套循环取乘积：比如多重循环，递归等。<pre class="line-numbers language-Java" data-language="Java"><code class="language-Java">public void cal(int n){  int sum = 0;  int i = 0;  int j = 0;  for (;i&lt;n;i++){    j = 1;    for (;j&lt;=n;j++){      sum += sum + i * j;    }  }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li>多数据规模取和：O(n+m)。<pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">cal</span><span class="token punctuation">(</span><span class="token keyword">int</span> n<span class="token punctuation">,</span><span class="token keyword">int</span> m<span class="token punctuation">)</span><span class="token punctuation">{</span>  <span class="token keyword">int</span> temp <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>  <span class="token keyword">int</span> a <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>  <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token punctuation">;</span>a<span class="token operator">&lt;</span>n<span class="token punctuation">;</span><span class="token operator">++</span>a<span class="token punctuation">)</span><span class="token punctuation">{</span>    temp <span class="token operator">=</span> temp <span class="token operator">+</span> i<span class="token punctuation">;</span>  <span class="token punctuation">}</span>  <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span>m<span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    sum <span class="token operator">+=</span> sum <span class="token operator">+</span> i <span class="token operator">*</span> j<span class="token punctuation">;</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ol><h4 id="2-4-常见的时间复杂度"><a href="#2-4-常见的时间复杂度" class="headerlink" title="2.4 常见的时间复杂度"></a>2.4 常见的时间复杂度</h4><p><img src="/image/algorithm/常见时间复杂度.jpg" alt="常见时间复杂度"></p><ol><li>多项式阶，随着数据规模的增长，算法的执行时间和空间占用，按照多项式的比例增长。  </li></ol><ul><li>O(1)（常数阶）<br>常数阶的概念并不是只执行一行代码，一般情况下算法中不存在循环、递归等语句，即使有成千上万行代码，复杂度也是O(1)</li><li>O(logn)（对数阶）<pre class="line-numbers language-Java" data-language="Java"><code class="language-Java">int i =1;while(i&lt;n){  i = i * 2;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>当2^x&gt;=n时，循环结束，所以这段代码的执行次数就是x= $log_2n$;大O法记作：$O(log_2n)$。那么再看下面这段代码：<pre class="line-numbers language-Java" data-language="Java"><code class="language-Java">int i =1;while(i&lt;n){  i = i * 3;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>按照上面的逻辑，这段的复杂度为$O(log_3n)$。二者之间是可以转换的$log_3n=log_32 * log_2n$；基于大O法的理论：在采用大O计数法时可以忽略系数等。则此类复杂度可统一记为O(logn)。   </li><li>O(n)（线性阶）</li><li>O(nlogn)（线性对数阶）<br>基于O(logn)，那么O(nlogn)就容易理解了，就相当于上面的嵌套取乘积规则一样，就是O(logn)执行的n遍。</li><li>O(n^2)（平方阶）、O(n^3)（立方阶）….、O(n^k)(K次方阶)</li></ul><ol><li>非多项式阶：随着数据规模的增长，算法的执行时间和空间占用暴增，这类算法性能极差。</li></ol><ul><li>O(2^n)（指数阶）</li><li>O(n!)（阶乘阶）</li></ul><h3 id="3-小结"><a href="#3-小结" class="headerlink" title="3 小结"></a>3 小结</h3><p>虽然上面说的事后统计法有一定的缺点，但时间复杂度的分析与其并不是对立冲突的。时间复杂度是一个理论上的模型，可以比较直观的给我们一个算法的效率上的感性认知，只能提供粗略的分析。它是与宿主平台无关的，并不是说O(n)的效率一定就优于O(n²)。针对不同的宿主平台环境，不同的数据集，不同的数据规模，在实际应用上性能可能会各有不同，所以实际应用中进行一定的性能基准测试是有必要的。<br>综上所述，时间复杂度分析和性能测试是相辅相成的。但一个低阶的时间复杂度确实有极大的可能优于高阶的时间复杂度，所以在编程中时刻关心复杂度的趋势走向是很有必要的，而且能很大幅度的提升输出质量。因此在编程中具有这种复杂度分析的思维还是十分有必要的。</p>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>浅析最好、最坏、平均、均摊时间复杂度</title>
      <link href="/2020/08/17/algorithm/qian-xi-zui-hao-zui-pi-ping-jun-jun-tan-shi-jian-fu-za-du/"/>
      <url>/2020/08/17/algorithm/qian-xi-zui-hao-zui-pi-ping-jun-jun-tan-shi-jian-fu-za-du/</url>
      
        <content type="html"><![CDATA[<p>对大O复杂度分析有一定基础的情况，可以进一步了解 <strong>最好情况时间复杂度</strong>（best case time complexity）、 <strong>最坏情况时间复杂度</strong>（worst case time complexity）、 <strong>平均情况时间复杂度</strong>（average case time complexity）、 <strong>均摊时间复杂度</strong>（amortized time complexity）。如果这几个概念你都能掌握，那对你来说，复杂度分析这部分内容就没什么大问题了。</p><h2 id="1、最好、最坏时间复杂度"><a href="#1、最好、最坏时间复杂度" class="headerlink" title="1、最好、最坏时间复杂度"></a>1、最好、最坏时间复杂度</h2><p>先分析下下面的例子：<br></p><pre class="line-numbers language-Java" data-language="Java"><code class="language-Java">void find (int[] array,int x){  int pos = -1;  for (i=0;i&lt;array.length;i++){    if(array[i] == x) {      pos = i;    }  }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><br>按照大O分析法，这段代码的复杂度就为O(n)；n代表数组的长度。但其实我们在查找数组中某个元素时，不一定非要把整个数组都遍历一遍，可以进行简单优化，如：<br><pre class="line-numbers language-Java" data-language="Java"><code class="language-Java">void find (int[] array,int x){  int pos = -1;  for (i=0;i&lt;array.length;i++){    if(array[i] == x) {      pos = i;      break;    }  }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><br>优化后的代码的时间复杂度还是O(n)吗？其实看一下也不尽然。这样就可以引进三个新的概念：最好时间复杂度、最坏时间复杂度和平均时间复杂度。<br>可以比较直观的分析得到两种情况：<p></p><ul><li>当x位于数组的最前面的下标，极端一些就在下标0的位置，那么时间复杂度就为O(1)，这就是最好时间复杂度。</li><li>另一种情况则是所查询的x不存在与数组之中，那么就要遍历整个数组，这样时间复杂度就为O(n)。这种极度糟糕的情况对应的就是最坏时间复杂度。</li></ul><h2 id="2、平均时间复杂度"><a href="#2、平均时间复杂度" class="headerlink" title="2、平均时间复杂度"></a>2、平均时间复杂度</h2><p>依旧拿上面例子为主，发生最好和最坏的情况的概率还是很小的。为了更好的表示平均情况下的时间复杂度，就需要引入一个新的概念：平均情况时间复杂度，简称平均时间复杂度。</p><p>我们知道要找的x在数组和不在数组的准确概率计算是极其复杂的，我们概括性的假设二者的概率均为1/2。另外查找的x出现在0~(n-1)这n个位置的概率为1/n。那么考虑在数组或不在数组的概率，根据概率乘积法则，x出现在0~(n-1)这n个位置的概率为1/2n，由此可以推到出以下公式：<br><img src="/image/algorithm/平均时间复杂度.jpg" alt="推到公式">  </p><p>这个值就是概率论中的加权平均值，也叫作期望值，所以平均时间复杂度的全称应该叫加权平均时间复杂度或者期望时间复杂度。用大 O 表示法来表示，去掉系数和常量，这段代码的加权平均时间复杂度仍然是 O(n)。  </p><p>平均时间复杂度看起来很复杂，又是引入概率又是需要推导。不过平常情况下只需要一种复杂度就可以满足需求。除非是在同一个代码块因不同情况出现，时间复杂度有量级上的差距，才需要用这三种时间复杂度进行分析。  </p><h2 id="3、均摊时间复杂度"><a href="#3、均摊时间复杂度" class="headerlink" title="3、均摊时间复杂度"></a>3、均摊时间复杂度</h2><p>均摊复杂度听起来和平均时间复杂度十分相似，而且也经常容易混淆。那具体均摊复杂度是什么呢？我们还是通过具体例子来了解一下，以及它的分析方法：摊还分析/平摊分析.<br></p><pre class="line-numbers language-Java" data-language="Java"><code class="language-Java">int[] array = new int[n];int count = 0;void insert(int element){  int sum;  if(count==array.length){    for(int i=0;i&lt;array.length;i++){      sum = sum + array[i];    }    array[0] = sum;    count = 1;  }  array[count] = element;  count++;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><br>上面是一个很简单的数组插入数据的代码块，当数组满了时，将数组所有内容求和放入下标为0的位置，再继续插入数据。按照大O分析法，我们进行最好、最坏和平均时间复杂度分析。<p></p><p>通过分析代码，我们可知。只有在数组满时才会进行数组遍历并求和，此时的时间复杂度为O(n)，其余时间的复杂度均为O(1)。所以最坏时间复杂度为O(n)，最好时间复杂度为O(1)。<br>那么接下来进行平均时间复杂度分析。假设插入的数组位于0~(n-1)间位置的概率是一样的均为1/n，由此推导出平均时间复杂度为O(1)，以下为推导过程：<br><img src="/image/algorithm/平均时间复杂度-1.jpg" alt="推到公式">    </p><p>到此最好、最坏、平均时间复杂度进阶推导出来，其实这个例子的时间复杂度大可不必如此麻烦，还引入概率。我们仔细分析一下find()和insert()两个方法的区别。</p><ul><li>O(n)的出现是小概率事件，O(1)反而出现的概率很大。</li><li>O(n)和O(1)出现是极其有规律的。当出现一次O(n)后，后面就会跟着n-1个O(1)。循环往复。  </li></ul><p>这种情况其实就没必要引入概率来进行平均时间复杂度的计算。针对这种特殊的场景，引入一种更简单的分析方法：摊还分析法，由此引出新的时间复杂度：摊还时间复杂度。具体分析如下：在了解O(n)和O(1)出现的规律后，可以把耗时多的O(n)的时间均摊到接下来的n-1次操作上，这样下来，摊还时间复杂度就为O(1)。</p><p>摊还时间复杂度可以针对特殊的场景进行简单化的分析，如：针对特殊的数据结构，在一段连续操作的代码块中，其中大多数操作耗时很短，只有极少数的操作耗时较长，就可以针对性的适用摊还分析进行时间复杂度分析。个人认为摊还时间复杂度可以算作一种特殊的评价时间复杂度</p>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>分布式CAP</title>
      <link href="/2020/08/17/microservice/cap/"/>
      <url>/2020/08/17/microservice/cap/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>以下引用至维基百科：  </p><blockquote><p>在理论计算机科学中，CAP定理（CAP theorem），又被称作布鲁尔定理（Brewer’s theorem），它指出对于一个分布式计算系统来说，不可能同时满足以下三点：</p><ul><li>一致性（Consistency）：等同于所有节点访问同一份最新的数据副本</li><li>可用性（Availability）：每次请求都能获取到非错的响应——但是不保证获取的数据为最新数据</li><li>分区容错性（Partition tolerance）：以实际效果而言，分区相当于对通信的时限要求。系统如果不能在<br>限内达成数据一致性，就意味着发生了分区的情况，必须就当前操作在C和A之间做出选择。</li></ul><p>根据定理，分布式系统只能满足三项中的两项而不可能满足全部三项。理解CAP理论的最简单方式：<br><strong>想象两个节点分处分区两侧。允许至少一个节点更新状态会导致数据不一致，即丧失了C性质。如果为了保证数据一致性，将分区一侧的节点设置为不可用，那么又丧失了A性质。除非两个节点可以互相通信，才能既保证C又保证A，这又会导致丧失P性质。</strong></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> CAP </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CAP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Zookeeper之Watcher机制</title>
      <link href="/2020/08/17/zookeeper/zk-watcher/"/>
      <url>/2020/08/17/zookeeper/zk-watcher/</url>
      
        <content type="html"><![CDATA[<font size="7">Zookeeper之Watcher</font><p>watcher机制是zookeeper的三大特性之一，它是很多应用场景的前提，比如：集群配置、管理，发布、订阅，资源抢占协调等等。</p><h2 id="watcher原理"><a href="#watcher原理" class="headerlink" title="watcher原理"></a>watcher原理</h2><p>原理框架图：<br><img src="/image/zookeeper/zookeeper-watcher原理框架.jpeg" alt="zookeeper原理框架">   </p><h2 id="注册和通知"><a href="#注册和通知" class="headerlink" title="注册和通知"></a>注册和通知</h2><p>zookeeper的watcher机制主要由client、server和watcherManager组成，包含注册和通知两个阶段。  </p><h3 id="注册表"><a href="#注册表" class="headerlink" title="注册表"></a>注册表</h3><h4 id="客户端注册表"><a href="#客户端注册表" class="headerlink" title="客户端注册表"></a>客户端注册表</h4><p>在 client 端注册表为 ZkWatchManager，ZkWatchManager的存储机制为三种</p><ul><li>dataWatches：针对节点的数据监听。</li><li>existWatches：客户端独有的存储方式，因为节点是否存在需要客户端自己判断。</li><li>childWatches：子节点监听。<br>源码：</li></ul><pre class="line-numbers language-Java" data-language="Java"><code class="language-Java">//客户端  其中Set&lt;Watcher&gt;实际复制对象类型为HashSet&lt;Watcher&gt;private static class ZKWatchManager implements ClientWatchManager {    private final Map&lt;String, Set&lt;Watcher&gt;&gt; dataWatches =        new HashMap&lt;String, Set&lt;Watcher&gt;&gt;();    private final Map&lt;String, Set&lt;Watcher&gt;&gt; existWatches =        new HashMap&lt;String, Set&lt;Watcher&gt;&gt;();    private final Map&lt;String, Set&lt;Watcher&gt;&gt; childWatches =        new HashMap&lt;String, Set&lt;Watcher&gt;&gt;();    //创建Zoookeeper链接时传入的watcher会赋值到：defaultWatcher    private volatile Watcher defaultWatcher;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>三种存储机制中，Set<watcher>的实现都是HashSet<watcher>，由此可得出：</watcher></watcher></p><ul><li>同一路径下的同一watcher实例，无论注册多少次都只会记录一次，即触发后只通知一次。</li><li>同一路径注册多个不同的watcher，会通知多次。即每个注册watcher都会被通知。</li></ul><h4 id="服务端注册表"><a href="#服务端注册表" class="headerlink" title="服务端注册表"></a>服务端注册表</h4><p>在 server 端注册表为 WatcherWatchManager，WatcherWatchManager的存储机制分为两种：</p><ul><li>dataWatches：针对节点的数据监听。</li><li>childWatches：子节点监听。  </li></ul><p>与 client 比少的 existWatches 也很容易理解，因为节点是否存在需要客户端去判断。<br>两种机制均由 WatchManager 类来实现，WatchManager中包含两个重要的数据结构，分别是：</p><ul><li>watchTable：从数据节点(即路径)的粒度来维护  </li><li>watch2Paths：从watcher的粒度来维护。  </li></ul><p>注意这里的watcher含义表示远程连接，所以watchTable表示一个目录下可能有多个消费者的监听连接，而watch2Paths表示一个消费者可能会对多个目录建立监听，显然多目录的监听会复用一个连接。</p><p>源码：<br></p><pre class="line-numbers language-Java" data-language="Java"><code class="language-Java">//服务端public class DataTree {    private static final Logger LOG = LoggerFactory.getLogger(DataTree.class);    /**     * This hashtable provides a fast lookup to the datanodes. The tree is the     * source of truth and is where all the locking occurs     */    private final ConcurrentHashMap&lt;String, DataNode&gt; nodes =        new ConcurrentHashMap&lt;String, DataNode&gt;();    private final WatchManager dataWatches = new WatchManager();    private final WatchManager childWatches = new WatchManager();    ....  }//dataWatches和childWatches是同一类的不同实例。即：public class WatchManager {    private static final Logger LOG = LoggerFactory.getLogger(WatchManager.class);    private final HashMap&lt;String, HashSet&lt;Watcher&gt;&gt; watchTable =        new HashMap&lt;String, HashSet&lt;Watcher&gt;&gt;();    private final HashMap&lt;Watcher, HashSet&lt;String&gt;&gt; watch2Paths =        new HashMap&lt;Watcher, HashSet&lt;String&gt;&gt;();    public synchronized int size(){        int result = 0;        for(Set&lt;Watcher&gt; watches : watchTable.values()) {            result += watches.size();        }        return result;    }    ......  }<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p></p><h3 id="注册"><a href="#注册" class="headerlink" title="注册"></a>注册</h3><h4 id="注册方式"><a href="#注册方式" class="headerlink" title="注册方式"></a>注册方式</h4><p>创建Zookeeper链接时会传入的watcher，这个watcher即为注册表中的defaultWatcher。<br>其它注册方式：</p><ul><li>getChildren(String path, Watcher watcher)</li><li>getChildren(String path, boolean watch)</li><li>getData(String path, boolean watch, Stat stat)</li><li>getData(String path, Watcher watcher, AsyncCallback.DataCallback cb, Object ctx)</li><li>exists(String path, boolean watch)</li><li>exists(String path, Watcher watcher)   </li></ul><p>其中Boolean watch表示是否使用上下文中默认的watcher，即创建zk实例时设置的watcher. getData 和 exists 请求可以注册服务端注册表-dataWatches，getChilden 可以注册服务端注册表-childWatches。<br>每个客户端都会维护 2 个线程，SendThread 负责处理客户端与服务端的请求通信，比如发送 getDataRequest，而 EventThread 则负责处理服务端的事件通知，即 watcher 的事件。</p><h4 id="注册流程"><a href="#注册流程" class="headerlink" title="注册流程"></a>注册流程</h4><h5 id="客户端注册流程"><a href="#客户端注册流程" class="headerlink" title="客户端注册流程"></a>客户端注册流程</h5><p>zookeeper客户端watcher注册流程:<br><img src="/image/zookeeper/zookeeper客户端watcher注册流程.jpeg" alt="zookeeper客户端watcher注册流程"></p><p>几种客户端注册的流程大致相同,我们以exists为例。源码：</p><pre class="line-numbers language-Java" data-language="Java"><code class="language-Java">public Stat exists(final String path, Watcher watcher)        throws KeeperException, InterruptedException    {        ......        RequestHeader h = new RequestHeader();        h.setType(ZooDefs.OpCode.exists);        ExistsRequest request = new ExistsRequest();        request.setPath(serverPath);        request.setWatch(watcher != null);        SetDataResponse response = new SetDataResponse();        ReplyHeader r = cnxn.submitRequest(h, request, response, wcb);        ......    }<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>总的来说就是针对不同API进行类似的请求标记，watcher封装，然后将请求放入队列等待(SendThread)调度后发送到服务端。</p><h5 id="服务端注册流程"><a href="#服务端注册流程" class="headerlink" title="服务端注册流程"></a>服务端注册流程</h5><p>server端接收到请求后的处理流程：<br><img src="/image/zookeeper/zookeeper注册server端流程.jpeg" alt="zookeeper原理框架">   </p><p><em>FinalRequestProcessor</em>：为服务端统一处理类，客户端所有操作及请求最终都会在此进行相应流程处理<br></p><pre class="line-numbers language-Java" data-language="Java"><code class="language-Java">/** * This Request processor actually applies any transaction associated with a * request and services any queries. It is always at the end of a * RequestProcessor chain (hence the name), so it does not have a nextProcessor * member. * * This RequestProcessor counts on ZooKeeperServer to populate the * outstandingRequests member of ZooKeeperServer. */public class FinalRequestProcessor implements RequestProcessor{}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p></p><p>以exists为例：</p><pre class="line-numbers language-Java" data-language="Java"><code class="language-Java">case OpCode.exists: {    lastOp = "EXIS";    // TODO we need to figure out the security requirement for this!    ExistsRequest existsRequest = new ExistsRequest();    ByteBufferInputStream.byteBuffer2Record(request.request,            existsRequest);    String path = existsRequest.getPath();    if (path.indexOf('\0') != -1) {        throw new KeeperException.BadArgumentsException();    }    Stat stat = zks.getZKDatabase().statNode(path, existsRequest            .getWatch() ? cnxn : null);    rsp = new ExistsResponse(stat);    break;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>由源码可知，这边会通过一些 case 来判断请求类型，watcher最后会经由ZKDatabase的statNode进行操作。根据源码追寻可知：</p><p><em>ZKDatabase</em><br></p><pre class="line-numbers language-Java" data-language="Java"><code class="language-Java">/** * This class maintains the in memory database of zookeeper * server states that includes the sessions, datatree and the * committed logs. It is booted up  after reading the logs * and snapshots from the disk. */public class ZKDatabase{  ....  public Stat statNode(String path, ServerCnxn serverCnxn) throws KeeperException.NoNodeException {      return dataTree.statNode(path, serverCnxn);  }  .....}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><br><pre class="line-numbers language-Java" data-language="Java"><code class="language-Java">public Stat statNode(String path, Watcher watcher)        throws KeeperException.NoNodeException {    Stat stat = new Stat();    DataNode n = nodes.get(path);    if (watcher != null) {        dataWatches.addWatch(path, watcher);    }    if (n == null) {        throw new KeeperException.NoNodeException();    }    synchronized (n) {        n.copyStat(stat);        return stat;    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p></p><p>ZKDatabase是在zookeeper运行时的数据库，server端注册表就存储在此，最后通过dataTree将watcher存储到dataWatches中。  </p><p>server端正常存储后返回客户端，在 ClientCnxn$SendThread 类的 readResponse-&gt;finishPacket 方法中会对watcher进行存储。<br>可以看到这边调用了 watchRegistration 的 register 方法，而它就是根据请求类型来装入对应的 watchManager 中了(dataWatches、existWatches、childWatches)。</p><pre class="line-numbers language-Java" data-language="Java"><code class="language-Java">private void finishPacket(Packet p) {        if (p.watchRegistration != null) {            p.watchRegistration.register(p.replyHeader.getErr());        }        if (p.cb == null) {            synchronized (p) {                p.finished = true;                p.notifyAll();            }        } else {            p.finished = true;            eventThread.queuePacket(p);        }    }<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="通知-watcher触发"><a href="#通知-watcher触发" class="headerlink" title="通知/watcher触发"></a>通知/watcher触发</h3><h4 id="通知状态和事件类型"><a href="#通知状态和事件类型" class="headerlink" title="通知状态和事件类型"></a>通知状态和事件类型</h4><p>server端通知时主要内容为通知状态(org.apache.zookeeper.Watcher.Event.KeeperState)和事件类型(org.apache.zookeeper.Watcher.Event.EventType)，二者均于WatchedEvent对象内进行传输。<br></p><pre class="line-numbers language-Java" data-language="Java"><code class="language-Java">/** *  A WatchedEvent represents a change on the ZooKeeper that a Watcher *  is able to respond to.  The WatchedEvent includes exactly what happened, *  the current state of the ZooKeeper, and the path of the znode that *  was involved in the event. */public class WatchedEvent {  ......  }<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p></p><h5 id="通知状态"><a href="#通知状态" class="headerlink" title="通知状态"></a>通知状态</h5><div class="table-container"><table><thead><tr><th style="text-align:left">连接状态</th><th style="text-align:left">描述  </th></tr></thead><tbody><tr><td style="text-align:left">KeeperState.Disconnected</td><td style="text-align:left">当客户端断开连接（与集群中的任何一台断开连接）时的状态就是Disconnected  </td></tr><tr><td style="text-align:left">KeeperState.SyncConnected</td><td style="text-align:left">当客户端与zookeeper集群中的任意一台建立连接，这时的事件状态就是SyncConnected  </td></tr><tr><td style="text-align:left">KeeperState.AuthFailed</td><td style="text-align:left">客户端进行连接认证失败时，事件状态为AuthFailed</td></tr><tr><td style="text-align:left">KeeperState.ConnectedReadOnly</td><td style="text-align:left">当前客户端连接到的zookeeper服务是只读的，此时事件状态是ConnectedReadOnly，这时的客户端只可以进行读操作，而不能进行写操作</td></tr><tr><td style="text-align:left">KeeperState.SaslAuthenticated</td><td style="text-align:left">用于通知客户端它们是SASL认证的</td></tr><tr><td style="text-align:left">KeeperState.Expired</td><td style="text-align:left">客户端与zookeeper服务端建立连接后每隔一定时间会发送一次心跳检测，当心跳检测没有收到服务端的响应时即认定断开连接，session失效，此时的事件状态就是Expired，如果客户端想访问服务端，需要重新建立连接。  </td></tr></tbody></table></div><p><font color="red">注意：</font>zookeeper上述状态在触发时，除了SyncConnected会存在包含所有事件的情况，其它状态记录的事件类型都是：EventType.None</p><h5 id="事件类型"><a href="#事件类型" class="headerlink" title="事件类型"></a>事件类型</h5><div class="table-container"><table><thead><tr><th style="text-align:left">zookeeper事件</th><th style="text-align:left">描述</th></tr></thead><tbody><tr><td style="text-align:left">EventType.NodeCreated</td><td style="text-align:left">当节点被创建时，该事件被触发</td></tr><tr><td style="text-align:left">EventType.NodeChildrenChanged</td><td style="text-align:left">当节点的直接子节点被创建、被删除、子节点数据发生变更时，该事件被触发</td></tr><tr><td style="text-align:left">EventType.NodeDataChanged</td><td style="text-align:left">当节点的数据变化或版本变化时，该事件被触发</td></tr><tr><td style="text-align:left">EventType.NodeDeleted</td><td style="text-align:left">当节点被删除时，该事件被触发</td></tr><tr><td style="text-align:left">EventType.None</td><td style="text-align:left">当zookeeper客户端的连接状态发生变更时（上面连接状态表格中所列），描述的事件类型为EventType.None</td></tr></tbody></table></div><h5 id="API方法与触发事件关联关系"><a href="#API方法与触发事件关联关系" class="headerlink" title="API方法与触发事件关联关系"></a>API方法与触发事件关联关系</h5><p>我们以test节点为例</p><div class="table-container"><table><thead><tr><th style="text-align:left">注册方式</th><th style="text-align:left">NodeCreated</th><th style="text-align:left">NodeChildrenChanged</th><th style="text-align:left">NodeDataChanged</th><th style="text-align:left">NodeDeleted</th></tr></thead><tbody><tr><td style="text-align:left">zk.getChildren(“/test”,watcher)</td><td style="text-align:left"></td><td style="text-align:left">可监控</td><td style="text-align:left"></td><td style="text-align:left">可监控</td></tr><tr><td style="text-align:left">zk.exists(“/test”,watcher)</td><td style="text-align:left">可监控</td><td style="text-align:left"></td><td style="text-align:left">可监控</td><td style="text-align:left">可监控</td></tr><tr><td style="text-align:left">zk.getData(“/test”,watcher)</td><td style="text-align:left"></td><td style="text-align:left"></td><td style="text-align:left">可监控</td><td style="text-align:left">可监控</td></tr></tbody></table></div><p>客户端只能收到服务器发过来的相关事件通知，并不能获取到对应数据节点变化前后的数据。</p><h4 id="触发"><a href="#触发" class="headerlink" title="触发"></a>触发</h4><p>我们以setDate方法为例。server端所有的处理均在FinalRequestProcessor里，当请求处理完成后会进行watcher事件的触发。我们以setDate为例追踪下触发的流程。</p><p>在FinalRequestProcessor中有这么一段代码：<br></p><pre class="line-numbers language-Java" data-language="Java"><code class="language-Java">if (request.hdr != null) {   TxnHeader hdr = request.hdr;   Record txn = request.txn;   rc = zks.processTxn(hdr, txn);}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><br>追踪下去就会找到 DataTree 类处理 setData 请求的具体逻辑。<br><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token class-name">Stat</span> <span class="token function">setData</span><span class="token punctuation">(</span><span class="token class-name">String</span> path<span class="token punctuation">,</span> <span class="token keyword">byte</span> data<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token keyword">int</span> version<span class="token punctuation">,</span> <span class="token keyword">long</span> zxid<span class="token punctuation">,</span>            <span class="token keyword">long</span> time<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">KeeperException<span class="token punctuation">.</span>NoNodeException</span> <span class="token punctuation">{</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>    dataWatches<span class="token punctuation">.</span><span class="token function">triggerWatch</span><span class="token punctuation">(</span>path<span class="token punctuation">,</span> <span class="token class-name">EventType<span class="token punctuation">.</span>NodeDataChanged</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> s<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">public</span> <span class="token class-name">Set</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Watcher</span><span class="token punctuation">&gt;</span></span> <span class="token function">triggerWatch</span><span class="token punctuation">(</span><span class="token class-name">String</span> path<span class="token punctuation">,</span> <span class="token class-name">EventType</span> type<span class="token punctuation">,</span> <span class="token class-name">Set</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Watcher</span><span class="token punctuation">&gt;</span></span> supress<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token class-name">WatchedEvent</span> e <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">WatchedEvent</span><span class="token punctuation">(</span>type<span class="token punctuation">,</span>            <span class="token class-name">KeeperState<span class="token punctuation">.</span>SyncConnected</span><span class="token punctuation">,</span> path<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token class-name">HashSet</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Watcher</span><span class="token punctuation">&gt;</span></span> watchers<span class="token punctuation">;</span>    <span class="token keyword">synchronized</span> <span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        watchers <span class="token operator">=</span> watchTable<span class="token punctuation">.</span><span class="token function">remove</span><span class="token punctuation">(</span>path<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>watchers <span class="token operator">==</span> <span class="token keyword">null</span> <span class="token operator">||</span> watchers<span class="token punctuation">.</span><span class="token function">isEmpty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token constant">LOG</span><span class="token punctuation">.</span><span class="token function">isTraceEnabled</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token class-name">ZooTrace</span><span class="token punctuation">.</span><span class="token function">logTraceMessage</span><span class="token punctuation">(</span><span class="token constant">LOG</span><span class="token punctuation">,</span>                        <span class="token class-name">ZooTrace</span><span class="token punctuation">.</span><span class="token constant">EVENT_DELIVERY_TRACE_MASK</span><span class="token punctuation">,</span>                        <span class="token string">"No watchers for "</span> <span class="token operator">+</span> path<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>            <span class="token keyword">return</span> <span class="token keyword">null</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token class-name">Watcher</span> w <span class="token operator">:</span> watchers<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token class-name">HashSet</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">&gt;</span></span> paths <span class="token operator">=</span> watch2Paths<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>w<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>paths <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                paths<span class="token punctuation">.</span><span class="token function">remove</span><span class="token punctuation">(</span>path<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token class-name">Watcher</span> w <span class="token operator">:</span> watchers<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>supress <span class="token operator">!=</span> <span class="token keyword">null</span> <span class="token operator">&amp;&amp;</span> supress<span class="token punctuation">.</span><span class="token function">contains</span><span class="token punctuation">(</span>w<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">continue</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        w<span class="token punctuation">.</span><span class="token function">process</span><span class="token punctuation">(</span>e<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> watchers<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p></p><p>可以看到逻辑处理完会调用triggerWatch方法，此方法的作用就是从server端的watchManager中获取watcher并在watchTable 和 watch2Paths 中移除自身，所以 watcher 是单次的。  </p><p>最后将封装好的通知即源码中的 e 对象放入watcher的process方法中，process的作用其实就是去发送通知。以 Watcher的一个实现类NioServerCnxn 为例就是调用了其 sendResponse 方法将通知事件发送到客户端，发送前会将 watchedEvent 转换成 watcherEvent 进行发送。</p><p>客户端最后会将通知交由EventThread进行对应watcher的process方法调用。</p><p>至此，zookeeper 的整个 watcher 交互逻辑就已经结束了。</p>]]></content>
      
      
      <categories>
          
          <category> zookeeper </category>
          
      </categories>
      
      
        <tags>
            
            <tag> zookeeper </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>vscode快捷键</title>
      <link href="/2020/08/17/kuai-jie-jian/vscode/"/>
      <url>/2020/08/17/kuai-jie-jian/vscode/</url>
      
        <content type="html"><![CDATA[<h3 id="全局"><a href="#全局" class="headerlink" title="全局"></a>全局</h3><p>Command + Shift + P / F1 显示命令面板<br>Command + P 快速打开<br>Command + Shift + N 打开新窗口<br>Command + W 关闭窗口</p><h3 id="基本"><a href="#基本" class="headerlink" title="基本"></a>基本</h3><p>Command + X 剪切（未选中文本的情况下，剪切光标所在行）<br>Command + C 复制（未选中文本的情况下，复制光标所在行）<br>Option + Up 向上移动行<br>Option + Down 向下移动行<br>Option + Shift + Up 向上复制行<br>Option + Shift + Down 向下复制行<br>Command + Shift + K 删除行<br>Command + Enter 下一行插入<br>Command + Shift + Enter 上一行插入<br>Command + Shift + \ 跳转到匹配的括号<br>Command + [ 减少缩进<br>Command + ] 增加缩进<br>Home 跳转至行首<br>End 跳转到行尾<br>Command + Up 跳转至文件开头<br>Command + Down 跳转至文件结尾<br>Ctrl + PgUp 按行向上滚动<br>Ctrl + PgDown 按行向下滚动<br>Command + PgUp 按屏向上滚动<br>Command + PgDown 按屏向下滚动<br>Command + Shift + [ 折叠代码块<br>Command + Shift + ] 展开代码块<br>Command + K Command + [ 折叠全部子代码块<br>Command + K Command + ] 展开全部子代码块<br>Command + K Command + 0 折叠全部代码块<br>Command + K Command + J 展开全部代码块<br>Command + K Command + C 添加行注释<br>Command + K Command + U 移除行注释<br>Command + / 添加、移除行注释<br>Option + Shift + A 添加、移除块注释<br>Option + Z 自动换行、取消自动换行</p><h3 id="多光标与选择"><a href="#多光标与选择" class="headerlink" title="多光标与选择"></a>多光标与选择</h3><p>Option + 点击 插入多个光标<br>Command + Option + Up 向上插入光标<br>Command + Option + Down 向下插入光标<br>Command + U 撤销上一个光标操作<br>Option + Shift + I 在所选行的行尾插入光标<br>Command + I 选中当前行<br>Command + Shift + L 选中所有与当前选中内容相同部分<br>Command + F2 选中所有与当前选中单词相同的单词<br>Command + Ctrl + Shift + Left 折叠选中<br>Command + Ctrl + Shift + Right 展开选中<br>Alt + Shift + 拖动鼠标 选中代码块<br>Command + Shift + Option + Up 列选择 向上<br>Command + Shift + Option + Down 列选择 向下<br>Command + Shift + Option + Left 列选择 向左<br>Command + Shift + Option + Right 列选择 向右<br>Command + Shift + Option + PgUp 列选择 向上翻页<br>Command + Shift + Option + PgDown 列选择 向下翻页</p><h3 id="查找替换"><a href="#查找替换" class="headerlink" title="查找替换"></a>查找替换</h3><p>Command + F 查找<br>Command + Option + F 替换<br>Command + G 查找下一个<br>Command + Shift + G 查找上一个<br>Option + Enter 选中所有匹配项<br>Command + D 向下选中相同内容<br>Command + K Command + D 移除前一个向下选中相同内容</p><h3 id="进阶"><a href="#进阶" class="headerlink" title="进阶"></a>进阶</h3><p>Ctrl + Space 打开建议<br>Command + Shift + Space 参数提示<br>Tab Emmet插件缩写补全<br>Option + Shift + F 格式化<br>Command + K Command + F 格式化选中内容<br>F12 跳转到声明位置<br>Option + F12 查看具体声明内容<br>Command + K F12 分屏查看具体声明内容<br>Command + . 快速修复<br>Shift + F12 显示引用<br>F2 重命名符号<br>Command + Shift + . 替换为上一个值<br>Command + Shift + , 替换为下一个值<br>Command + K Command + X 删除行尾多余空格<br>Command + K M 更改文件语言</p><h3 id="导航"><a href="#导航" class="headerlink" title="导航"></a>导航</h3><p>Command + T 显示所有符号<br>Ctrl + G 跳转至某行<br>Command + P 跳转到某个文件<br>Command + Shift + O 跳转到某个符号<br>Command + Shift + M 打开问题面板<br>F8 下一个错误或警告位置<br>Shift + F8 上一个错误或警告位置<br>Ctrl + Shift + Tab 编辑器历史记录<br>Ctrl + - 后退<br>Ctrl + Shift + - 前进<br>Ctrl + Shift + M Tab 切换焦点</p><h3 id="编辑器管理"><a href="#编辑器管理" class="headerlink" title="编辑器管理"></a>编辑器管理</h3><p>Command + W 关闭编辑器<br>Command + K F 关闭文件夹<br>Command + \ 编辑器分屏<br>Command + 1 切换到第一分组<br>Command + 2 切换到第二分组<br>Command + 3 切换到第三分组<br>Command + K Command + Left 切换到上一分组<br>Command + K Command + Right 切换到下一分组<br>Command + K Command + Shift + Left 左移编辑器<br>Command + K Command + Shift + Right 右移编辑器<br>Command + K Left 激活左侧编辑组<br>Command + K Right 激活右侧编辑组</p><h3 id="文件管理"><a href="#文件管理" class="headerlink" title="文件管理"></a>文件管理</h3><p>Command + N 新建文件<br>Command + O 打开文件<br>Command + S 保存文件<br>Command + Shift + S 另存为<br>Command + Option + S 全部保存<br>Command + W 关闭<br>Command + K Command + W 全部关闭<br>Command + Shift + T 重新打开被关闭的编辑器<br>Command + K Enter 保持打开<br>Ctrl + Tab 打开下一个<br>Ctrl + Shift + Tab 打开上一个<br>Command + K P 复制当前文件路径<br>Command + K R 在资源管理器中查看当前文件<br>Command + K O 新窗口打开当前文件</p><h3 id="显示"><a href="#显示" class="headerlink" title="显示"></a>显示</h3><p>Command + Ctrl + F 全屏、退出全屏<br>Command + Option + 1 切换编辑器分屏方式（横、竖）<br>Command + + 放大<br>Command + - 缩小<br>Command + B 显示、隐藏侧边栏<br>Command + Shift + E 显示资源管理器 或 切换焦点<br>Command + Shift + F 显示搜索框<br>Ctrl + Shift + G 显示Git面板<br>Command + Shift + D 显示调试面板<br>Command + Shift + X 显示插件面板<br>Command + Shift + H 全局搜索替换<br>Command + Shift + J 显示、隐藏高级搜索<br>Command + Shift + C 打开新终端<br>Command + Shift + U 显示输出面板<br>Command + Shift + V Markdown预览窗口<br>Command + K V 分屏显示 Markdown预览窗口</p><h3 id="调试"><a href="#调试" class="headerlink" title="调试"></a>调试</h3><p>F9 设置 或 取消断点<br>F5 开始 或 继续<br>F11 进入<br>Shift + F11 跳出<br>F10 跳过<br>Command + K Command + I 显示悬停信息</p><h3 id="集成终端"><a href="#集成终端" class="headerlink" title="集成终端"></a>集成终端</h3><p>Ctrl + 显示终端 Ctrl + Shift + 新建终端<br>Command + Up 向上滚动<br>Command + Down 向下滚动<br>PgUp 向上翻页<br>PgDown 向下翻页<br>Command + Home 滚动到顶部<br>Command + End 滚动到底部</p>]]></content>
      
      
      <categories>
          
          <category> vscode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> vscode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JVM内存模型</title>
      <link href="/2020/08/17/java/jvm/jvm-memory-model/"/>
      <url>/2020/08/17/java/jvm/jvm-memory-model/</url>
      
        <content type="html"><![CDATA[<h1 id="JVM内存"><a href="#JVM内存" class="headerlink" title="JVM内存"></a>JVM内存</h1><h3 id="一-概述"><a href="#一-概述" class="headerlink" title="一 概述"></a>一 概述</h3><p><strong>内存</strong> 是硬盘和CPU的中间仓库及桥梁，承载着操作系统和应用程序的实时运行。JVM内存布局规定了Java在运行过程中内存申请、分配、管理的策略，保证了JVM的高效稳定运行.</p><p>在JVM自动内存管理机制，开发人员不需要去考虑内存的delete/free操作，不容易出现内存溢出和泄露问题。</p><h3 id="二-运行时数据区域-内存布局"><a href="#二-运行时数据区域-内存布局" class="headerlink" title="二 运行时数据区域/内存布局"></a>二 运行时数据区域/内存布局</h3><p>1.8之前和之后略有区别，主要体现在为1.8之前存在方法区(Method Area)，1.8之后去掉方法区，增加元空间(MetaSpace)</p><p><img src="/image/JVM/Java虚拟机运行时数据区_水印.jpg" alt="Java内存布局"></p><h4 id="2-1-虚拟机栈"><a href="#2-1-虚拟机栈" class="headerlink" title="2.1 虚拟机栈"></a>2.1 虚拟机栈</h4><ol><li><p>Java 虚拟机栈（Java Virtual Machine Stacks）也就是我们平时所说的 <strong>栈内存</strong>，或者指的就是虚拟机栈中的 <strong>局部变量表</strong> 部分。<br>虚拟机栈描述的是Java方法的内存模型：即每个方法在执行的同时都会创建一个 <strong>栈帧</strong>，用于存储局部变量表、操作数栈、动态链接、方法出口等信息。所以虚拟机栈是线程私有的，生命周期与线程相同。  </p></li><li><p><strong>栈针（Stack Frame）</strong> ：用于支持虚拟机进行方法调用和方法执行的数据结构。每一个方法从调用至执行完成的过程，都对应着一个栈帧在虚拟机栈里从入栈到出栈的过程。  </p></li><li><p><strong>局部变量表</strong>：存放编译期方法内部的各种基本数据类型（boolean、byte、char、short、int、float、long、double）、对象引用（reference）类型等。<br>局部变量表所需空间是在编译期间完成分配的，当进入方法，该方法需要的栈针分配的空间是固定，在方法运行期间不会改变.   </p><p><strong>操作数栈</strong>：Java虚拟机的解释执行引擎称为“基于栈的执行引擎”，其中所指的“栈”就是操作数栈。当JVM为方法创建栈帧的时候，在栈帧中为方法创建一个操作数栈，保证方法内指令可以完成工作。</p><p><strong>动态链接</strong>： 每个栈帧中包含一个在常量池中对当前方法的引用， 目的是支持方法调用过程的动态连接。</p><p><strong>方法返回地址</strong>： 退出的两种形式，1、正常退出；2、抛出异常。</p></li><li><p>虚拟机栈在JVM中存在两种异常</p><ul><li>StackOverflowError：若线程请求的栈深度大于当前虚拟机所允许的深度，抛出此异常</li><li>OutOfMemoryError：若虚拟机栈可动态扩展，当扩展时无法申请到足够的内存，抛出此异常</li></ul></li></ol><h4 id="2-2-本地方法栈"><a href="#2-2-本地方法栈" class="headerlink" title="2.2 本地方法栈"></a>2.2 本地方法栈</h4><p>本地方法栈Native Method Stack）与虚拟机栈的作用是相似。区别是：<strong>虚拟机栈为虚拟机执行 Java 方法 （也就是字节码）服务，而本地方法栈则为虚拟机使用到的 Native 方法服务。</strong>   </p><p>此外，对于此区域出现的异常，和虚拟机栈是相同的。</p><h4 id="2-3-程序计数器"><a href="#2-3-程序计数器" class="headerlink" title="2.3 程序计数器"></a>2.3 程序计数器</h4><p>程序计数器（Program Counter Register）是当前线程所执行的字节码的行号指示器，它占用一块较小的内存空间。<strong>字节码解释器通过改变该计数器的值来选取下一条需要执行的字节码指令，其中包括分支、循环、跳转、异常处理、线程恢复等基础功能。</strong>  </p><p>Java多线程是处理器的时间片转轮的策略的实现的，任一确定时刻，一个处理器只执行一条线下中的命令，为了切换线程后可恢复到正确的执行位置，程序计数器为线程私有。</p><p><strong>程序计数器是唯一一个在 Java 虚拟机规范中没有规定任何 OutOfMemoryError 情况的区域。</strong></p><h4 id="2-4-堆"><a href="#2-4-堆" class="headerlink" title="2.4 堆"></a>2.4 堆</h4><ol><li><p>堆（Heap）是JVM最重要的也是最大的一块内存，在虚拟机启动时创建。对于堆来说，它可以位于物理上不连续而逻辑上连续的内存空间中。在实际情况下也可以通过调整虚拟机参数的方式对堆进行扩展，即通过 -Xmx 和 -Xms 控制。</p></li><li><p>该区域的主要作用: <strong>为对象实例及数组分配内存</strong>，几乎存储了所有对象实例。同时也是垃圾回收器管理的主要区域，因此也被称作GC 堆（Garbage Collected Heap）。 <br><br><br>Java堆还可以细分为：新生代和老年代。再细致一点的有Eden空间、From Survivor空间、To Survivor空间等。具体如下图：<br><img src="/image/JVM/Heap.jpg" alt="堆Heap详细分布">1.8后去除永生代，用元空间替代。<br><br><br>查看虚拟机默认配置命令：</p><pre class="line-numbers language-xshell" data-language="xshell"><code class="language-xshell">java -XX:+PrintFlagsFinal -version<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li></ol><h4 id="2-5-方法区-Method-Area"><a href="#2-5-方法区-Method-Area" class="headerlink" title="2.5 方法区(Method Area)"></a>2.5 方法区(Method Area)</h4><ol><li><p>方法区（Method Area）用于存储已被虚拟机加载的 类信息、常量、静态变量、即时编译器编译后的代码等数据。虽然 <strong>Java 虚拟机规范把方法区描述为堆的一个逻辑部分，但是它却有一个别名叫做 Non-Heap（非堆）</strong>，目的应该是与 Java 堆区分开来。</p></li><li><p>方法区也被成为永生代，二者关系分析起来比较容易混淆，引用下面个人认为比较好的释义：</p><blockquote><p>《Java 虚拟机规范》只是规定了有方法区这么个概念和它的作用，并没有规定如何去实现它。那么，在不同的 JVM 上方法区的实现肯定是不同的了。<strong>方法区和永久代的关系很像 Java 中接口和类的关系，类实现了接口，而永久代就是 HotSpot 虚拟机对虚拟机规范中方法区的一种实现方式。</strong> 也就是说，永久代是 HotSpot 的概念，方法区是 Java 虚拟机规范中的定义，是一种规范，而永久代是一种实现，一个是标准一个是实现，其他的虚拟机实现并没有永久代这一说法。</p></blockquote></li><li><p>方法区或者称为永生代，<strong>在1.8中被去除</strong>。并用元空间（Metaspace）替换。</p></li></ol><h4 id="2-5-元空间（Metaspace）"><a href="#2-5-元空间（Metaspace）" class="headerlink" title="2.5 元空间（Metaspace）"></a>2.5 元空间（Metaspace）</h4><ol><li>元空间替换方法区的原因：<ul><li>因为PermGen/(Method Area)经常内存溢出。</li><li>促进HotSpot和JRockit VM融合，因为 JRockit 没有永久代。<br>详细原因：<a href="http://openjdk.java.net/jeps/122">JEP 122:Remove the Permanent Generation</a></li></ul></li><li>根据上面的原因方法区被移除，方法区中类元信息、字段、静态属性、方法、常量等移至元空间，<strong>并在1.7时将运行时常量池从方法区中移了出来，在 Java 堆（Heap）中开辟了一块区域存放运行时常量池。</strong></li><li>元空间和方法区本质类似，主要区别在于：<strong>元空间使用本地内存，方法区存在于虚拟机中。</strong> 所以元空间的大小取决于本地内存的容量。  </li></ol><p>元空间对应的JVM调参：</p><div class="table-container"><table><thead><tr><th style="text-align:left">参数</th><th style="text-align:left">作用</th></tr></thead><tbody><tr><td style="text-align:left">-XX:MaxMetaspaceSize</td><td style="text-align:left">分配给Metaspace 的最大值，超过此值就会触发Full GC，此值默认没有限制，但应取决于系统内存的大小。JVM会动态地改变此值。</td></tr><tr><td style="text-align:left">-XX:MinMetaspaceFreeRatio</td><td style="text-align:left">在GC之后，最小的Metaspace剩余空间容量的百分比，减少为分配空间所导致的垃圾收集</td></tr><tr><td style="text-align:left">-XX:MaxMetaspaceFreeRatio</td><td style="text-align:left">在GC之后，最大的Metaspace剩余空间容量的百分比，减少为释放空间所导致的垃圾收集</td></tr><tr><td style="text-align:left">-XX:MetaspaceSize</td><td style="text-align:left">分配给Metaspace（以字节计）的初始大小</td></tr></tbody></table></div><h4 id="2-6-直接内存（Direct-Memory）"><a href="#2-6-直接内存（Direct-Memory）" class="headerlink" title="2.6 直接内存（Direct Memory）"></a>2.6 直接内存（Direct Memory）</h4><p>直接内存并不属于Java内存的一员，但这部分也经常被使用并也会出现OutOfMemoryError 异常。<br>虽然直接内存不受Java堆大小的限制，但还是会受到本机总内存的大小及处理器寻址空间的限制。如果内存区域总和大于物理内存的限制，也会出现OOM。</p><hr><h5 id="参考："><a href="#参考：" class="headerlink" title="参考："></a>参考：</h5><ul><li><a href="https://dyfloveslife.github.io/2019/11/18/java-memory-areas">https://dyfloveslife.github.io/2019/11/18/java-memory-areas</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
          <category> JVM </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JVM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SpringBoot 启动 —— 源码解析</title>
      <link href="/2020/08/17/microservice/spriingboot-run/"/>
      <url>/2020/08/17/microservice/spriingboot-run/</url>
      
        <content type="html"><![CDATA[<font size="7">SpringBoot 启动 —— 源码解析</font><h2 id="一、概述"><a href="#一、概述" class="headerlink" title="一、概述"></a>一、概述</h2><p>本文从main方法的SpringApplication.run(SpringbootTestLockApplication.class, args)开始追踪源码的实现，通过分析源码的调用情况分析整个springboot启动过程的原理和相关的设计理念。<br><strong>SPringboot版本：2.4.4</strong></p><h2 id="二、创建SpringApplication实例"><a href="#二、创建SpringApplication实例" class="headerlink" title="二、创建SpringApplication实例"></a>二、创建SpringApplication实例</h2><h3 id="2-1、启动类"><a href="#2-1、启动类" class="headerlink" title="2.1、启动类"></a>2.1、启动类</h3><p>程序入口是启动类的main方法。通过运行SpringApplication.run()来实际启动服务。</p><pre class="line-numbers language-Java" data-language="Java"><code class="language-Java">启动类main：public static void main(String[] args) {        ConfigurableApplicationContext run = SpringApplication.run(SpringbootTestLockApplication.class, args);    }<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h3 id="2-2、SpringApplication实例"><a href="#2-2、SpringApplication实例" class="headerlink" title="2.2、SpringApplication实例"></a>2.2、SpringApplication实例</h3><h4 id="2-2-1、启动步骤"><a href="#2-2-1、启动步骤" class="headerlink" title="2.2.1、启动步骤"></a>2.2.1、启动步骤</h4><p>通过源码可以看到，启动分为两步：1、实例化SpringApplication，2、再执行实例的run()方法.<br></p><pre class="line-numbers language-Java" data-language="Java"><code class="language-Java">//run方法两层调用public static ConfigurableApplicationContext run(Class&lt;?&gt; primarySource, String... args) {  return run(new Class&lt;?&gt;[] { primarySource }, args);}public static ConfigurableApplicationContext run(Class&lt;?&gt;[] primarySources, String[] args) {  return new SpringApplication(primarySources).run(args);}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p></p><h4 id="2-2-2、SpringApplication构造函数"><a href="#2-2-2、SpringApplication构造函数" class="headerlink" title="2.2.2、SpringApplication构造函数"></a>2.2.2、SpringApplication构造函数</h4><p>SpringApplication的构造方法主要是为了初始化SpringApplication的一些基础属性，例如主启动类、web应用类型、启动载入器、初始化器列表、监听器列表等。<br></p><pre class="line-numbers language-Java" data-language="Java"><code class="language-Java">//构造函数两层调用public SpringApplication(Class&lt;?&gt;... primarySources) {  this(null, primarySources);}@SuppressWarnings({ "unchecked", "rawtypes" })public SpringApplication(ResourceLoader resourceLoader, Class&lt;?&gt;... primarySources) {  //根据调用逻辑可知resourceLoader为Null。  this.resourceLoader = resourceLoader;  Assert.notNull(primarySources, "PrimarySources must not be null");  //将Class数组参数赋值到SpringApplication.primarySources属性  this.primarySources = new LinkedHashSet&lt;&gt;(Arrays.asList(primarySources));  //获取固定应用类型：WebApplicationType.SERVLET（The application should run as a servlet-based web application and should start an embedded servlet web server.）    this.webApplicationType = WebApplicationType.deduceFromClasspath();  //获取spring.factories中Bootstrapper对应的实例  this.bootstrappers = new ArrayList&lt;&gt;(getSpringFactoriesInstances(Bootstrapper.class));  //设置 spring.factories中ApplicationContextInitializer对应的实例  setInitializers((Collection) getSpringFactoriesInstances(ApplicationContextInitializer.class));  //设置 spring.factories中ApplicationListener对应的实例  setListeners((Collection) getSpringFactoriesInstances(ApplicationListener.class));  //获取当前启动类class  this.mainApplicationClass = deduceMainApplicationClass();}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p></p><h5 id="1、getSpringFactoriesInstances"><a href="#1、getSpringFactoriesInstances" class="headerlink" title="1、getSpringFactoriesInstances"></a>1、getSpringFactoriesInstances</h5><p>获取所以META-INF/spring.factories下的接口及其实现类的对应关系。即在初始化启动载入器、初始化器、监听器时，均是调用getSpringFactoriesInstances方法，通过传入不同的Class类型获取到不同的实例。<br></p><pre class="line-numbers language-Java" data-language="Java"><code class="language-Java">private &lt;T&gt; Collection&lt;T&gt; getSpringFactoriesInstances(Class&lt;T&gt; type) {return getSpringFactoriesInstances(type, new Class&lt;?&gt;[] {});}private &lt;T&gt; Collection&lt;T&gt; getSpringFactoriesInstances(Class&lt;T&gt; type, Class&lt;?&gt;[] parameterTypes, Object... args) {    //获取ClassLoader——sun.misc.Launcher$AppClassLoaderClassLoader classLoader = getClassLoader();    //获取指定type的接口实现类列表    Set&lt;String&gt; names = new LinkedHashSet&lt;&gt;(SpringFactoriesLoader.loadFactoryNames(type, classLoader));    //初始化type对应的接口实现类    List&lt;T&gt; instances = createSpringFactoriesInstances(type, parameterTypes, classLoader, args, names);AnnotationAwareOrderComparator.sort(instances);return instances;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p></p><ul><li>getClassLoader：获取SpringApplication.resourceLoader，当resourceLoader为Null时获取当前线程的ClassLoader。由构造函数可知，此处获取的是当前线程的ClassLoader。</li></ul><h5 id="2、loadFactoryNames"><a href="#2、loadFactoryNames" class="headerlink" title="2、loadFactoryNames()"></a>2、loadFactoryNames()</h5><p>通过解析getSpringFactoriesInstances可以看到，通过SpringFactoriesLoader.loadFactoryNames()方法获取指定名称的所有类名称列表。即通过扫描资源文件META-INF/spring.factories来获取相关的键值对匹配关系并进行代码化解析。</p><pre class="line-numbers language-Java" data-language="Java"><code class="language-Java">public static final String FACTORIES_RESOURCE_LOCATION = "META-INF/spring.factories";public static List&lt;String&gt; loadFactoryNames(Class&lt;?&gt; factoryType, @Nullable ClassLoader classLoader) {ClassLoader classLoaderToUse = classLoader;if (classLoaderToUse == null) {classLoaderToUse = SpringFactoriesLoader.class.getClassLoader();}String factoryTypeName = factoryType.getName();return loadSpringFactories(classLoaderToUse).getOrDefault(factoryTypeName, Collections.emptyList());}private static Map&lt;String, List&lt;String&gt;&gt; loadSpringFactories(ClassLoader classLoader) {  //如果缓存存在，则获取缓存中的数据  Map&lt;String, List&lt;String&gt;&gt; result = cache.get(classLoader);if (result != null) {return result;}result = new HashMap&lt;&gt;();try {    //缓存不存在，则通过解析 FACTORIES_RESOURCE_LOCATION 资源文件，解析里面不同接口类型及对应的类名称。并将数据存储入缓存中。Enumeration&lt;URL&gt; urls = classLoader.getResources(FACTORIES_RESOURCE_LOCATION);while (urls.hasMoreElements()) {URL url = urls.nextElement();UrlResource resource = new UrlResource(url);Properties properties = PropertiesLoaderUtils.loadProperties(resource);for (Map.Entry&lt;?, ?&gt; entry : properties.entrySet()) {String factoryTypeName = ((String) entry.getKey()).trim();String[] factoryImplementationNames =StringUtils.commaDelimitedListToStringArray((String) entry.getValue());for (String factoryImplementationName : factoryImplementationNames) {result.computeIfAbsent(factoryTypeName, key -&gt; new ArrayList&lt;&gt;()).add(factoryImplementationName.trim());}}}// Replace all lists with unmodifiable lists containing unique elementsresult.replaceAll((factoryType, implementations) -&gt; implementations.stream().distinct().collect(Collectors.collectingAndThen(Collectors.toList(), Collections::unmodifiableList)));cache.put(classLoader, result);}catch (IOException ex) {throw new IllegalArgumentException("Unable to load factories from location [" +FACTORIES_RESOURCE_LOCATION + "]", ex);}return result;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h5 id="3、setListeners"><a href="#3、setListeners" class="headerlink" title="3、setListeners()"></a>3、setListeners()</h5><p>初始化所有监听器，并将监听器数组赋值到SpringApplication.listeners属性中，纯净的springboot初始化的监听器分别如下：<br>org.springframework.boot.ClearCachesApplicationListener<br>org.springframework.boot.builder.ParentContextCloserApplicationListener<br>org.springframework.boot.context.FileEncodingApplicationListener<br>org.springframework.boot.context.config.AnsiOutputApplicationListener<br>org.springframework.boot.context.config.DelegatingApplicationListener<br>org.springframework.boot.context.logging.LoggingApplicationListener<br>org.springframework.boot.env.EnvironmentPostProcessorApplicationListener<br>org.springframework.boot.liquibase.LiquibaseServiceLocatorApplicationListener<br>org.springframework.boot.autoconfigure.BackgroundPreinitializer</p><p>自此SpringApplication初始化完成。主要是初始化了一些基础属性和定义了服务类型。</p><h2 id="三、运行SpringApplication-run-方法"><a href="#三、运行SpringApplication-run-方法" class="headerlink" title="三、运行SpringApplication.run()方法"></a>三、运行SpringApplication.run()方法</h2><p>创建成功后调用该实例的run方法：运行spring应用程序，创建并刷新一个APplicationContext对象。<br>ApplicationContext：中央接口，为应用程序提供配置。在应用程序运行时这是只读的，但如果实现支持，则可以重新加载。  </p><pre class="line-numbers language-Java" data-language="Java"><code class="language-Java">/** * Run the Spring application, creating and refreshing a new * {@link ApplicationContext}. * @param args the application arguments (usually passed from a Java main method) * @return a running {@link ApplicationContext} */public ConfigurableApplicationContext run(String... args) {  //创建秒表  StopWatch stopWatch = new StopWatch();  //秒表启动  stopWatch.start();  //创建启动上下文  DefaultBootstrapContext bootstrapContext = createBootstrapContext();ConfigurableApplicationContext context = null;  // 设置系统参数：java.awt.headless（在系统可能缺少显示设备、键盘或鼠标这些外设的情况下可以使用该模式，例如Linux服务器）  configureHeadlessProperty();  //初始化监听器列表  SpringApplicationRunListeners listeners = getRunListeners(args);  //启动监听器  listeners.starting(bootstrapContext, this.mainApplicationClass);try {    //创建程序参数对象，args：命令行执行时，命令行参数对象。    ApplicationArguments applicationArguments = new DefaultApplicationArguments(args);    //准备环境    ConfigurableEnvironment environment = prepareEnvironment(listeners, bootstrapContext, applicationArguments);    //设置忽略的bean信息    configureIgnoreBeanInfo(environment);    //打印banner，即启动时控制台的图案    Banner printedBanner = printBanner(environment);    //根据webApplicationType来创建容器/spring上下文对象  下面统一称呼为容器    context = createApplicationContext();    //设置应用程序启动指标对象，使应用程序上下文在启动期间能够记录一些指标context.setApplicationStartup(this.applicationStartup);    //准备容器，容器的前置处理prepareContext(bootstrapContext, context, environment, listeners, applicationArguments, printedBanner);    //刷新容器    refreshContext(context);    //刷新容器的后续处理    afterRefresh(context, applicationArguments);    //秒表停止    stopWatch.stop();    //输出记录，记录启动类class信息，时间信息    if (this.logStartupInfo) {      new StartupInfoLogger(this.mainApplicationClass).logStarted(getApplicationLog(), stopWatch);    }    // 发布监听应用上下文启动完成（发出启动结束事件）    listeners.started(context);    //运行runner    callRunners(context, applicationArguments);  }  catch (Throwable ex) {    handleRunFailure(context, ex, listeners);    throw new IllegalStateException(ex);  }  try {    //监听容器运行中    listeners.running(context);  }  catch (Throwable ex) {    handleRunFailure(context, ex, null);    throw new IllegalStateException(ex);  }  return context;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>下面就是对整个run方法进行逐行理解分析。</p><h3 id="3-1、秒表"><a href="#3-1、秒表" class="headerlink" title="3.1、秒表"></a>3.1、秒表</h3><p>创建一个秒表并在正式运行逻辑之前启动。纳秒级精确度。<br></p><pre class="line-numbers language-Java" data-language="Java"><code class="language-Java">StopWatch stopWatch = new StopWatch();stopWatch.start();<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p></p><h3 id="3-2、创建启动上下文——Bootstrap"><a href="#3-2、创建启动上下文——Bootstrap" class="headerlink" title="3.2、创建启动上下文——Bootstrap"></a>3.2、创建启动上下文——Bootstrap</h3><p>Spring Cloud官方文档有一部分相关Bootstrap的描述：<br><a href="https://cloud.spring.io/spring-cloud-commons/multi/multi__spring_cloud_context_application_context_services.html">Spring Cloud 官方文档</a>    </p><p>大致译文为：<br>Spring Cloud应用程序通过创建<strong>bootstrap</strong>上下文进行操作，该上下文是主应用程序的父上下文。它负责从外部源加载配置属性，并负责解密本地外部配置文件中的属性。这两个上下文共享一个<strong>Environment</strong>，这是任何Spring应用程序的外部属性的来源。默认情况下，引导程序属性（不是bootstrap.properties引导程序阶段加载的属性）具有较高的优先级，因此它们不能被本地配置覆盖。  </p><p>如果从SpringApplication或构建应用程序上下文SpringApplicationBuilder，那么Bootstrap上下文将作为父级添加到该上下文。  </p><pre class="line-numbers language-Java" data-language="Java"><code class="language-Java">private DefaultBootstrapContext createBootstrapContext() {DefaultBootstrapContext bootstrapContext = new DefaultBootstrapContext();this.bootstrappers.forEach((initializer) -&gt; initializer.intitialize(bootstrapContext));return bootstrapContext;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>进入源码，可知创建启动上下文时，会进行初始化，主要对bootstrapContext内的实例进行注册。注册成功后返回bootstrapContext对象。<br><strong>注</strong>：通过loadFactoryNames()方法可知当不应用Cloud体系时，bootstrapContext为空list。  </p><h3 id="3-3、获取SpringApplicationRunListeners实例——getRunListeners"><a href="#3-3、获取SpringApplicationRunListeners实例——getRunListeners" class="headerlink" title="3.3、获取SpringApplicationRunListeners实例——getRunListeners()"></a>3.3、获取SpringApplicationRunListeners实例——getRunListeners()</h3><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">private</span> <span class="token class-name">SpringApplicationRunListeners</span> <span class="token function">getRunListeners</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token class-name">Class</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token operator">?</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">[</span><span class="token punctuation">]</span> types <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Class</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token operator">?</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token punctuation">{</span> <span class="token class-name">SpringApplication</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">,</span> <span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token keyword">class</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>  <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">SpringApplicationRunListeners</span><span class="token punctuation">(</span>logger<span class="token punctuation">,</span>      <span class="token function">getSpringFactoriesInstances</span><span class="token punctuation">(</span><span class="token class-name">SpringApplicationRunListener</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">,</span> types<span class="token punctuation">,</span> <span class="token keyword">this</span><span class="token punctuation">,</span> args<span class="token punctuation">)</span><span class="token punctuation">,</span>      <span class="token keyword">this</span><span class="token punctuation">.</span>applicationStartup<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ol><li><p>这段代码就比较熟悉了，还是getSpringFactoriesInstances()这个方法获取所有SpringApplicationRunListener接口的实现类的实例化对象。并初始SpringApplicationRunListeners对象。  </p></li><li><p>SpringApplicationRunListener：spring所有事件的触发都是通过该接口的唯一实现类EventPublishingRunListener来实现的，EventPublishingRunListener也是该接口的官方唯一实现类。<br>EventPublishingRunListener构造函数：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token class-name">EventPublishingRunListener</span><span class="token punctuation">(</span><span class="token class-name">SpringApplication</span> application<span class="token punctuation">,</span> <span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token keyword">this</span><span class="token punctuation">.</span>application <span class="token operator">=</span> application<span class="token punctuation">;</span><span class="token keyword">this</span><span class="token punctuation">.</span>args <span class="token operator">=</span> args<span class="token punctuation">;</span><span class="token keyword">this</span><span class="token punctuation">.</span>initialMulticaster <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">SimpleApplicationEventMulticaster</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token class-name">ApplicationListener</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token operator">?</span><span class="token punctuation">&gt;</span></span> listener <span class="token operator">:</span> application<span class="token punctuation">.</span><span class="token function">getListeners</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token keyword">this</span><span class="token punctuation">.</span>initialMulticaster<span class="token punctuation">.</span><span class="token function">addApplicationListener</span><span class="token punctuation">(</span>listener<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>EventPublishingRunListener的属性共有三个：</p><ul><li>application：当前运行的SpringApplication实例</li><li>args：启动命令行参数</li><li>initialMulticaster：事件广播器<br>根据构造函数可知，会将application关联的所有ApplicationListener实例关联到initialMulticaster中，以方便initialMulticaster将事件传递给所有的监听器。</li></ul></li><li><p>事件触发过程：</p><ul><li>当对应的时间处理方法被调用时，EventPublishingRunListener会将application和args封装到对应的SpringApplicationEvent子类实例中；</li><li>initialMulticaster会根据事件类型和触发源对事件进行分类，并与对应的ApplicationListener建立关联关系，之后将事件传递给对应的ApplicationListener；</li><li>ApplicationListener实例收到事件后，会根据时间类型不同，执行不同的处理逻辑。</li></ul></li></ol><p>至此可知，getRunListeners()方法是为了获取一个装有EventPublishingRunListener对象实例的数组对象-SpringApplicationRunListeners。用于后续事件触发通知功能。</p><h3 id="3-4、启动监听器——listeners-starting"><a href="#3-4、启动监听器——listeners-starting" class="headerlink" title="3.4、启动监听器——listeners.starting()"></a>3.4、启动监听器——listeners.starting()</h3><p>初始化所有监听器后，进行启动。启动时传入启动上下文和启动类的class对象<br></p><pre class="line-numbers language-Java" data-language="Java"><code class="language-Java">void starting(ConfigurableBootstrapContext bootstrapContext, Class&lt;?&gt; mainApplicationClass) {doWithListeners("spring.boot.application.starting", (listener) -&gt; listener.starting(bootstrapContext),(step) -&gt; {if (mainApplicationClass != null) {step.tag("mainApplicationClass", mainApplicationClass.getName());}});}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p></p><p>启动监听器主要是starting()方案，此处调用则使用SpringApplicationRunListener接口的实现类EventPublishingRunListener对应的starting()方法进行监听器启动。<br>此处实现类的创建的可参看 spring-boot 包的 spring.factories 文件：<a href="https://github.com/spring-projects/spring-boot/blob/master/spring-boot-project/spring-boot/src/main/resources/META-INF/spring.factories">官方spring.factories</a>  </p><p>EventPublishingRunListener具体实现启动的代码逻辑<br></p><pre class="line-numbers language-Java" data-language="Java"><code class="language-Java">@Overridepublic void starting(ConfigurableBootstrapContext bootstrapContext) {this.initialMulticaster.multicastEvent(new ApplicationStartingEvent(bootstrapContext, this.application, this.args));}@Overridepublic void multicastEvent(final ApplicationEvent event, @Nullable ResolvableType eventType) {  ResolvableType type = (eventType != null ? eventType : resolveDefaultEventType(event));  Executor executor = getTaskExecutor();  for (ApplicationListener&lt;?&gt; listener : getApplicationListeners(event, type)) {    if (executor != null) {      executor.execute(() -&gt; invokeListener(listener, event));    }    else {      invokeListener(listener, event);    }  }}protected void invokeListener(ApplicationListener&lt;?&gt; listener, ApplicationEvent event) {  ErrorHandler errorHandler = getErrorHandler();  if (errorHandler != null) {    try {      doInvokeListener(listener, event);    }    catch (Throwable err) {      errorHandler.handleError(err);    }  }  else {    doInvokeListener(listener, event);  }}private void doInvokeListener(ApplicationListener listener, ApplicationEvent event) {  try {    listener.onApplicationEvent(event);  }  ......}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><br>starting()启动的时候实际上是又创建了一个ApplicationStartingEvent对象，其实就是监听应用启动事件。其中 initialMulticaster是一个SimpleApplicationEventMuticaster对象的实例化。<br>具体：<p></p><ul><li>获取initialMulticaster的线程池，但该实例初始化时并未创建线程池对象，所以此处为null</li><li>通过getApplicationListeners方法获取匹配事件的监听器。</li><li>对符合要求的监听器执行invokeListener方法.</li><li>对符合条件的监听器执行onApplicationEvent方法进行相关初始化操作。</li></ul><p>此处纯净的springboot项目共有四个监听器。</p><ul><li>LoggingApplicationListener初始化了loggingSystem</li><li>BackgroundPreinitializer：未执行任何操作</li><li>DelegatingApplicationListener：未执行任何操作</li><li>LiquibaseServiceLocatorApplicationListener：未执行任何操作.</li></ul><h3 id="3-5、环境准备-prepareEnvironment"><a href="#3-5、环境准备-prepareEnvironment" class="headerlink" title="3.5、环境准备-prepareEnvironment()"></a>3.5、环境准备-prepareEnvironment()</h3><p>设置好监听器后进行环境准备。主要是初始化应用参数和启动环境准备，源码对应如下：<br></p><pre class="line-numbers language-Java" data-language="Java"><code class="language-Java">//创建程序参数对象，args：命令行执行时，命令行参数对象。ApplicationArguments applicationArguments = new DefaultApplicationArguments(args);ConfigurableEnvironment environment = prepareEnvironment(listeners, bootstrapContext, applicationArguments);//设置忽略的bean信息configureIgnoreBeanInfo(environment);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p></p><h4 id="3-5-1、初始化应用参数"><a href="#3-5-1、初始化应用参数" class="headerlink" title="3.5.1、初始化应用参数"></a>3.5.1、初始化应用参数</h4><p>对启动时的参数进行解析，例如：java -jar —spring.profiles.active=test等。最终将解析的键值对存储到CommandLineArgs对象中。</p><h4 id="3-5-2、准备环境"><a href="#3-5-2、准备环境" class="headerlink" title="3.5.2、准备环境"></a>3.5.2、准备环境</h4><pre class="line-numbers language-Java" data-language="Java"><code class="language-Java">private ConfigurableEnvironment prepareEnvironment(SpringApplicationRunListeners listeners,DefaultBootstrapContext bootstrapContext, ApplicationArguments applicationArguments) {// 获取或创建一个environment实例ConfigurableEnvironment environment = getOrCreateEnvironment();   //配置环境：转换器、命令行参数等configureEnvironment(environment, applicationArguments.getSourceArgs());   //固定ConfigurationPropertySourcesPropertySource到environmentConfigurationPropertySources.attach(environment);   //启动监听器listeners.environmentPrepared(bootstrapContext, environment);   //判断是否存在defaultProperties的属性源，存在则移动最后一位DefaultPropertiesPropertySource.moveToEnd(environment);   configureAdditionalProfiles(environment);   //将环境绑定到SpringApplication类上bindToSpringApplication(environment);   //判断是否存在定制的环境if (!this.isCustomEnvironment) {environment = new EnvironmentConverter(getClassLoader()).convertEnvironmentIfNecessary(environment,deduceEnvironmentClass());}ConfigurationPropertySources.attach(environment);return environment;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h5 id="1、getOrCreateEnvironment"><a href="#1、getOrCreateEnvironment" class="headerlink" title="1、getOrCreateEnvironment()"></a>1、getOrCreateEnvironment()</h5><pre class="line-numbers language-Java" data-language="Java"><code class="language-Java">private ConfigurableEnvironment getOrCreateEnvironment() {if (this.environment != null) {return this.environment;}switch (this.webApplicationType) {case SERVLET:return new StandardServletEnvironment();case REACTIVE:return new StandardReactiveWebEnvironment();default:return new StandardEnvironment();}}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>如果不存在environment则根据webApplicationType类型进行初始环境实例创建，通过上面的源码解析可知，此处类型为SERVLET，所以会创建StandardServletEnvironment实例。<br>StandardReactiveWebEnvironment构造：</p><ul><li>调用了父类AbstractEnvironment的构造函数，进行相关属性的初始化。<ol><li>propertySources属性初始化MutablePropertySources实例。</li><li>propertyResolver属性初始化PropertySourcesPropertyResolver实例，它的父类AbstractPropertyResolver中定义了”${}”占位符，用于后续解析配置文件时使用。</li></ol></li><li>通过customizePropertySources()方法对propertySources增加了以下四个元素：servletConfigInitParams、servletContextInitParams、systemProperties、systemEnvironment。</li></ul><h5 id="2、configureEnvironment-environment-applicationArguments-getSourceArgs"><a href="#2、configureEnvironment-environment-applicationArguments-getSourceArgs" class="headerlink" title="2、configureEnvironment(environment, applicationArguments.getSourceArgs());"></a>2、configureEnvironment(environment, applicationArguments.getSourceArgs());</h5><pre class="line-numbers language-Java" data-language="Java"><code class="language-Java">protected void configureEnvironment(ConfigurableEnvironment environment, String[] args) {  if (this.addConversionService) {    ConversionService conversionService = ApplicationConversionService.getSharedInstance();    environment.setConversionService((ConfigurableConversionService) conversionService);  }  configurePropertySources(environment, args);  configureProfiles(environment, args);}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>环境配置分三步，配置转换器、配置属性资源(命令行参数)、配置文件(命令行参数)。</p><ul><li>配置转换器：<ol><li>addConversionService属性初始值为true，通过静态方法getSharedInstance()获取一个单例的转换器。构造函数包含一些默认的Formatter和GenericConverter。</li><li>获取后配置到environment的propertyResolver属性中。</li></ol></li><li>配置属性资源文件:configurePropertySources()<pre class="line-numbers language-Java" data-language="Java"><code class="language-Java"> private boolean addCommandLineProperties = true; public static final String COMMAND_LINE_PROPERTY_SOURCE_NAME = "commandLineArgs"; protected void configurePropertySources(ConfigurableEnvironment environment, String[] args) {MutablePropertySources sources = environment.getPropertySources();if (!CollectionUtils.isEmpty(this.defaultProperties)) {DefaultPropertiesPropertySource.addOrMerge(this.defaultProperties, sources);}   //若条件成立则将命令行参数设置进环境属性资源if (this.addCommandLineProperties &amp;&amp; args.length &gt; 0) {String name = CommandLinePropertySource.COMMAND_LINE_PROPERTY_SOURCE_NAME;if (sources.contains(name)) {PropertySource&lt;?&gt; source = sources.get(name);CompositePropertySource composite = new CompositePropertySource(name);composite.addPropertySource(new SimpleCommandLinePropertySource("springApplicationCommandLineArgs", args));composite.addPropertySource(source);sources.replace(name, composite);}else {sources.addFirst(new SimpleCommandLinePropertySource(args));}}}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>初始化defaultProperties属性为null，args则根据是否在命令输入进行相关处理。</li><li>配置文件(命令行参数):configureProfiles()<pre class="line-numbers language-Java" data-language="Java"><code class="language-Java"> protected void configureProfiles(ConfigurableEnvironment environment, String[] args) {}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>未具体实现，应该是用于后续扩展使用。</li></ul><h5 id="3、ConfigurationPropertySources-attach-environment"><a href="#3、ConfigurationPropertySources-attach-environment" class="headerlink" title="3、ConfigurationPropertySources.attach(environment)"></a>3、ConfigurationPropertySources.attach(environment)</h5><pre class="line-numbers language-Java" data-language="Java"><code class="language-Java">private static final String ATTACHED_PROPERTY_SOURCE_NAME = "configurationProperties";public static void attach(Environment environment) {  Assert.isInstanceOf(ConfigurableEnvironment.class, environment);  MutablePropertySources sources = ((ConfigurableEnvironment) environment).getPropertySources();  PropertySource&lt;?&gt; attached = sources.get(ATTACHED_PROPERTY_SOURCE_NAME);  if (attached != null &amp;&amp; attached.getSource() != sources) {    sources.remove(ATTACHED_PROPERTY_SOURCE_NAME);    attached = null;  }  if (attached == null) {    sources.addFirst(new ConfigurationPropertySourcesPropertySource(ATTACHED_PROPERTY_SOURCE_NAME,        new SpringConfigurationPropertySources(sources)));  }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>该步骤的目的是将ConfigurationPropertySource支持固定到environment中，以便于PropertySourcesPropertyResolver使用配置属性名称进行解析。</p><h5 id="4、listeners-environmentPrepared-bootstrapContext-environment"><a href="#4、listeners-environmentPrepared-bootstrapContext-environment" class="headerlink" title="4、listeners.environmentPrepared(bootstrapContext, environment)"></a>4、listeners.environmentPrepared(bootstrapContext, environment)</h5><pre class="line-numbers language-Java" data-language="Java"><code class="language-Java">void environmentPrepared(ConfigurableBootstrapContext bootstrapContext, ConfigurableEnvironment environment) {doWithListeners("spring.boot.application.environment-prepared",(listener) -&gt; listener.environmentPrepared(bootstrapContext, environment));}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>向监听器发送环境准备事件。此处的代码就比较熟悉了，和启动监听事件[starting()]方法逻辑基本一致。此处主要用来解析配置文件的监听器为：EnvironmentPostProcessorApplicationListener。<br><img src="/image/springboot/springboot-yml读取过程.png" alt="springboot配置读取调用层次关系">  </p><h5 id="5、DefaultPropertiesPropertySource-moveToEnd-environment"><a href="#5、DefaultPropertiesPropertySource-moveToEnd-environment" class="headerlink" title="5、DefaultPropertiesPropertySource.moveToEnd(environment)"></a>5、DefaultPropertiesPropertySource.moveToEnd(environment)</h5><p>判断是否存在defaultProperties的属性源，存在则移动最后一位</p><h5 id="6、configureAdditionalProfiles-environment"><a href="#6、configureAdditionalProfiles-environment" class="headerlink" title="6、configureAdditionalProfiles(environment);"></a>6、configureAdditionalProfiles(environment);</h5><pre class="line-numbers language-Java" data-language="Java"><code class="language-Java">private void configureAdditionalProfiles(ConfigurableEnvironment environment) {if (!CollectionUtils.isEmpty(this.additionalProfiles)) {Set&lt;String&gt; profiles = new LinkedHashSet&lt;&gt;(Arrays.asList(environment.getActiveProfiles()));if (!profiles.containsAll(this.additionalProfiles)) {profiles.addAll(this.additionalProfiles);environment.setActiveProfiles(StringUtils.toStringArray(profiles));}}}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>此处获取additionalProfiles属性是通过SpringApplicationBuilder实例设置的，一般不是使用SpringApplicationBuilder对象的应用此处没有额外的配置进入。</p><h5 id="7、bindToSpringApplication-environment"><a href="#7、bindToSpringApplication-environment" class="headerlink" title="7、bindToSpringApplication(environment)"></a>7、bindToSpringApplication(environment)</h5><p>将环境绑定到SpringApplication类上</p><h5 id="8、if-this-isCustomEnvironment"><a href="#8、if-this-isCustomEnvironment" class="headerlink" title="8、if (!this.isCustomEnvironment)"></a>8、if (!this.isCustomEnvironment)</h5><p>判断是否存在定制的环境，一般springboot方式启动的服务该<strong>isCustomEnvironment</strong>均为false，只有当通过SpringApplicationBuilder以war包的形式启动才会对该参数进行true赋值。</p><h5 id="9、ConfigurationPropertySources-attach-environment"><a href="#9、ConfigurationPropertySources-attach-environment" class="headerlink" title="9、ConfigurationPropertySources.attach(environment)"></a>9、ConfigurationPropertySources.attach(environment)</h5><p>通过lister的一系列操作后再次将ConfigurationPropertySource支持固定到environment中。</p><p>自此Springboot启动流程中环境准备、配置等操作已完成。</p><h4 id="3-6、准备容器，容器的前置处理——prepareContext-bootstrapContext-context-environment-listeners-applicationArguments-printedBanner"><a href="#3-6、准备容器，容器的前置处理——prepareContext-bootstrapContext-context-environment-listeners-applicationArguments-printedBanner" class="headerlink" title="3.6、准备容器，容器的前置处理——prepareContext(bootstrapContext, context, environment, listeners, applicationArguments, printedBanner);"></a>3.6、准备容器，容器的前置处理——prepareContext(bootstrapContext, context, environment, listeners, applicationArguments, printedBanner);</h4><p>参数属性对应的实际class类型：</p><ul><li>contex:AnnotationConfigServletWebServerApplicationContext</li><li>listeners: SpringApplicationRunListeners</li></ul><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">prepareContext</span><span class="token punctuation">(</span><span class="token class-name">DefaultBootstrapContext</span> bootstrapContext<span class="token punctuation">,</span> <span class="token class-name">ConfigurableApplicationContext</span> context<span class="token punctuation">,</span><span class="token class-name">ConfigurableEnvironment</span> environment<span class="token punctuation">,</span> <span class="token class-name">SpringApplicationRunListeners</span> listeners<span class="token punctuation">,</span><span class="token class-name">ApplicationArguments</span> applicationArguments<span class="token punctuation">,</span> <span class="token class-name">Banner</span> printedBanner<span class="token punctuation">)</span> <span class="token punctuation">{</span>   <span class="token comment">//将给定的环境委托给底层的AnnotatedBeanDefinitionReader和ClassPathBeanDefinitionScanner。</span>   context<span class="token punctuation">.</span><span class="token function">setEnvironment</span><span class="token punctuation">(</span>environment<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">postProcessApplicationContext</span><span class="token punctuation">(</span>context<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">applyInitializers</span><span class="token punctuation">(</span>context<span class="token punctuation">)</span><span class="token punctuation">;</span>listeners<span class="token punctuation">.</span><span class="token function">contextPrepared</span><span class="token punctuation">(</span>context<span class="token punctuation">)</span><span class="token punctuation">;</span>bootstrapContext<span class="token punctuation">.</span><span class="token function">close</span><span class="token punctuation">(</span>context<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>logStartupInfo<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token function">logStartupInfo</span><span class="token punctuation">(</span>context<span class="token punctuation">.</span><span class="token function">getParent</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">logStartupProfileInfo</span><span class="token punctuation">(</span>context<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment">// Add boot specific singleton beans</span><span class="token class-name">ConfigurableListableBeanFactory</span> beanFactory <span class="token operator">=</span> context<span class="token punctuation">.</span><span class="token function">getBeanFactory</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>beanFactory<span class="token punctuation">.</span><span class="token function">registerSingleton</span><span class="token punctuation">(</span><span class="token string">"springApplicationArguments"</span><span class="token punctuation">,</span> applicationArguments<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">if</span> <span class="token punctuation">(</span>printedBanner <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>beanFactory<span class="token punctuation">.</span><span class="token function">registerSingleton</span><span class="token punctuation">(</span><span class="token string">"springBootBanner"</span><span class="token punctuation">,</span> printedBanner<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">if</span> <span class="token punctuation">(</span>beanFactory <span class="token keyword">instanceof</span> <span class="token class-name">DefaultListableBeanFactory</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token class-name">DefaultListableBeanFactory</span><span class="token punctuation">)</span> beanFactory<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">setAllowBeanDefinitionOverriding</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>allowBeanDefinitionOverriding<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>lazyInitialization<span class="token punctuation">)</span> <span class="token punctuation">{</span>context<span class="token punctuation">.</span><span class="token function">addBeanFactoryPostProcessor</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">LazyInitializationBeanFactoryPostProcessor</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment">// Load the sources</span><span class="token class-name">Set</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Object</span><span class="token punctuation">&gt;</span></span> sources <span class="token operator">=</span> <span class="token function">getAllSources</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token class-name">Assert</span><span class="token punctuation">.</span><span class="token function">notEmpty</span><span class="token punctuation">(</span>sources<span class="token punctuation">,</span> <span class="token string">"Sources must not be empty"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">load</span><span class="token punctuation">(</span>context<span class="token punctuation">,</span> sources<span class="token punctuation">.</span><span class="token function">toArray</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Object</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>listeners<span class="token punctuation">.</span><span class="token function">contextLoaded</span><span class="token punctuation">(</span>context<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>未完待续！</p>]]></content>
      
      
      <categories>
          
          <category> springboot </category>
          
      </categories>
      
      
        <tags>
            
            <tag> springboot </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>rust基础信息</title>
      <link href="/2020/08/17/rust/basic-information/"/>
      <url>/2020/08/17/rust/basic-information/</url>
      
        <content type="html"><![CDATA[<h3 id="一、rust基础信息"><a href="#一、rust基础信息" class="headerlink" title="一、rust基础信息"></a>一、rust基础信息</h3><ol><li><strong>在 Linux 或 macOS 上安装 rustup</strong><pre class="line-numbers language-rust" data-language="rust"><code class="language-rust">curl <span class="token operator">-</span><span class="token operator">-</span>proto '<span class="token operator">=</span>https' <span class="token operator">-</span><span class="token operator">-</span>tlsv1<span class="token number">.2</span> https<span class="token punctuation">:</span><span class="token operator">/</span><span class="token operator">/</span>sh<span class="token punctuation">.</span>rustup<span class="token punctuation">.</span>rs <span class="token operator">-</span>sSf <span class="token operator">|</span> sh<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>此命令下载一个脚本并开始安装 rustup 工具，这会安装最新稳定版 Rust。过程中可能会提示你输入密码。如果安装成功，将会出现如下内容：<pre class="line-numbers language-none"><code class="language-none">Rust is installed now. Great!```    2. **rust版本**```rustrustc --version<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ol><h3 id="二、cargo基础信息"><a href="#二、cargo基础信息" class="headerlink" title="二、cargo基础信息"></a>二、cargo基础信息</h3><ol><li><p><strong>cargo版本</strong></p><pre class="line-numbers language-rust" data-language="rust"><code class="language-rust">cargo <span class="token operator">-</span><span class="token operator">-</span>version<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li><p><strong>使用 Cargo 创建项目</strong></p><pre class="line-numbers language-rust" data-language="rust"><code class="language-rust">cargo new hello_cargocd hello_cargo<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></li><li><p><strong>编译运行</strong></p><ul><li>编译<pre class="line-numbers language-rust" data-language="rust"><code class="language-rust">cargo build    <span class="token class-name">Compiling</span> world_hello v0<span class="token number">.1</span><span class="token punctuation">.</span><span class="token number">0</span> <span class="token punctuation">(</span><span class="token operator">/</span><span class="token class-name">Users</span><span class="token operator">/</span>workerspace<span class="token operator">/</span>rust<span class="token operator">/</span>world_hello<span class="token punctuation">)</span>    <span class="token class-name">Finished</span> dev <span class="token punctuation">[</span>unoptimized <span class="token operator">+</span> debuginfo<span class="token punctuation">]</span> <span class="token function">target</span><span class="token punctuation">(</span>s<span class="token punctuation">)</span> <span class="token keyword">in</span> <span class="token number">1</span><span class="token punctuation">.</span>72s<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre></li><li>编译运行<pre class="line-numbers language-rust" data-language="rust"><code class="language-rust">cargo run    <span class="token class-name">Finished</span> dev <span class="token punctuation">[</span>unoptimized <span class="token operator">+</span> debuginfo<span class="token punctuation">]</span> <span class="token function">target</span><span class="token punctuation">(</span>s<span class="token punctuation">)</span> <span class="token keyword">in</span> <span class="token number">0</span><span class="token punctuation">.</span>00s    <span class="token class-name">Running</span> `target<span class="token operator">/</span>debug<span class="token operator">/</span>world_hello`    <span class="token class-name">Hello</span><span class="token punctuation">,</span> <span class="token macro property">world!</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre></li><li>检查，check，该命令会快速很多，因为它不会生成相关的可执行文件<pre class="line-numbers language-rust" data-language="rust"><code class="language-rust">cargo check    <span class="token class-name">Checking</span> world_hello v0<span class="token number">.1</span><span class="token punctuation">.</span><span class="token number">0</span> <span class="token punctuation">(</span><span class="token operator">/</span><span class="token class-name">Users</span><span class="token operator">/</span>workerspace<span class="token operator">/</span>rust<span class="token operator">/</span>world_hello<span class="token punctuation">)</span>    <span class="token class-name">Finished</span> dev <span class="token punctuation">[</span>unoptimized <span class="token operator">+</span> debuginfo<span class="token punctuation">]</span> <span class="token function">target</span><span class="token punctuation">(</span>s<span class="token punctuation">)</span> <span class="token keyword">in</span> <span class="token number">0</span><span class="token punctuation">.</span>14s<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre></li></ul></li><li><strong>发布（release）构建</strong><br>当项目最终准备好发布时，可以使用 cargo build —release 来优化编译项目。这会在 target/release 而不是 target/debug 下生成可执行文件。这些优化可以让 Rust 代码运行的更快，不过启用这些优化也需要消耗更长的编译时间。这也就是为什么会有两种不同的配置：一种是为了开发，你需要经常快速重新构建；另一种是为用户构建最终程序，它们不会经常重新构建，并且希望程序运行得越快越好。如果你在测试代码的运行时间，请确保运行 cargo build —release 并使用 target/release 下的可执行文件进行测试。</li></ol><h3 id="三、基础概念"><a href="#三、基础概念" class="headerlink" title="三、基础概念"></a>三、基础概念</h3><h4 id="3-1、变量与可变性"><a href="#3-1、变量与可变性" class="headerlink" title="3.1、变量与可变性"></a>3.1、变量与可变性</h4><pre class="line-numbers language-rust" data-language="rust"><code class="language-rust"><span class="token keyword">fn</span> <span class="token function-definition function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token comment">// 定义不可变变量</span>    <span class="token keyword">let</span> x <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>  <span class="token comment">//不可变量</span>    x <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>  <span class="token comment">//会报错：cannot assign twice to immutable variable</span>    <span class="token comment">//定义可变变量</span>    <span class="token keyword">let</span> <span class="token keyword">mut</span> y <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span>    y <span class="token operator">=</span> <span class="token number">3</span><span class="token punctuation">;</span>  <span class="token comment">//允许</span>    <span class="token comment">//常量</span>    <span class="token keyword">const</span> <span class="token constant">THREE_HOURS_IN_SECONDS</span><span class="token punctuation">:</span> <span class="token keyword">u32</span> <span class="token operator">=</span> <span class="token number">60</span> <span class="token operator">*</span> <span class="token number">60</span> <span class="token operator">*</span> <span class="token number">3</span><span class="token punctuation">;</span>    <span class="token comment">// 定义一个不会被使用（unused variable）的变量，并且忽略警告（warning）</span>    <span class="token keyword">let</span> _x <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="3-2、数据类型"><a href="#3-2、数据类型" class="headerlink" title="3.2、数据类型"></a>3.2、数据类型</h4><ol><li><p><strong>标量类型</strong><br>整型、浮点型、布尔类型和字符类型。    </p><p> 长度 | 有符号 | 无符号<br> :-|:-|:-|<br> 8-bit    |i8         |u8<br> 16-bit    |i16     |u16<br> 32-bit    |i32     |u32<br> 64-bit    |i64     |u64<br> 128-bit    |i128     |u128<br> arch    |isize     |usize</p></li><li><p><strong>元组类型</strong><br>元组是一个将多个其他类型的值组合进一个复合类型的主要方式。元组长度固定：一旦声明，其长度不会增大或缩小。</p><pre class="line-numbers language-rust" data-language="rust"><code class="language-rust"><span class="token keyword">let</span> x<span class="token punctuation">:</span> <span class="token punctuation">(</span><span class="token keyword">i32</span><span class="token punctuation">,</span> <span class="token keyword">f64</span><span class="token punctuation">,</span> <span class="token keyword">u8</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token number">500</span><span class="token punctuation">,</span> <span class="token number">6.4</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//定义</span><span class="token keyword">let</span> five_hundred <span class="token operator">=</span> x<span class="token number">.0</span><span class="token punctuation">;</span> <span class="token comment">//取值</span><span class="token keyword">let</span> tup <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token number">500</span><span class="token punctuation">,</span> <span class="token number">6.4</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">//绑定</span><span class="token keyword">let</span> <span class="token punctuation">(</span>x<span class="token punctuation">,</span> y<span class="token punctuation">,</span> z<span class="token punctuation">)</span> <span class="token operator">=</span> tup<span class="token punctuation">;</span>        <span class="token comment">//解构</span><span class="token macro property">println!</span><span class="token punctuation">(</span><span class="token string">"The value of y is: {}"</span><span class="token punctuation">,</span> y<span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment">//取值应用</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p><strong>数组类型</strong><br>包含多个相同类型数值的方式就是数组，且长度固定。</p><pre class="line-numbers language-rust" data-language="rust"><code class="language-rust"><span class="token comment">//定义</span><span class="token keyword">let</span> a <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token keyword">let</span> a<span class="token punctuation">:</span> <span class="token punctuation">[</span><span class="token keyword">i32</span><span class="token punctuation">;</span> <span class="token number">5</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token keyword">let</span> a <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">;</span> <span class="token number">5</span><span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token comment">//等价于 let a = [3,3,3,3,3];</span><span class="token keyword">let</span> first <span class="token operator">=</span> a<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">;</span>   <span class="token comment">//取值，下标以0为起始。</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ol><h4 id="3-3、函数定义"><a href="#3-3、函数定义" class="headerlink" title="3.3、函数定义"></a>3.3、函数定义</h4><ol><li><p>基础规则  </p><ul><li>关键字：fn</li><li>参数必须指定类型</li><li>函数名命名规则：snake case</li><li>函数具备返回值时，不对返回值指定命名，但要指定类型<br>示例：<pre class="line-numbers language-rust" data-language="rust"><code class="language-rust"><span class="token comment">//无参、无返回</span><span class="token keyword">fn</span> <span class="token function-definition function">another_function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token macro property">println!</span><span class="token punctuation">(</span><span class="token string">"Another function."</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment">//有参、无返回</span><span class="token keyword">fn</span> <span class="token function-definition function">another_function</span><span class="token punctuation">(</span>x<span class="token punctuation">:</span> <span class="token keyword">i32</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token macro property">println!</span><span class="token punctuation">(</span><span class="token string">"The value of x is: {}"</span><span class="token punctuation">,</span> x<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment">//无参、有返回</span><span class="token keyword">fn</span> <span class="token function-definition function">five</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">-&gt;</span> <span class="token keyword">i32</span> <span class="token punctuation">{</span>    <span class="token number">5</span><span class="token punctuation">}</span><span class="token comment">//有参、有返回</span><span class="token keyword">fn</span> <span class="token function-definition function">five</span><span class="token punctuation">(</span>x<span class="token punctuation">:</span> <span class="token keyword">i32</span><span class="token punctuation">)</span> <span class="token punctuation">-&gt;</span> <span class="token keyword">i32</span> <span class="token punctuation">{</span>    x<span class="token operator">+</span><span class="token number">5</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ul></li><li><p>语句和表达式的区别<br>函数体由一系列的语句和一个可选的结尾表达式构成。    </p></li></ol><ul><li><strong>语句（Statements）</strong>：是执行一些操作但不返回值的指令。</li><li><strong>表达式（Expressions）</strong>：计算并产生一个值。</li><li>区别:<ul><li>语句由 <strong>;</strong> 结尾，表达式无 <strong>;</strong> 结尾</li><li>语句代表执行某些逻辑，但不返回值，表达式则即有逻辑也返回具体值。</li><li>函数可以使用 return 关键字和指定值，从函数中提前返回；但大部分函数隐式的返回最后的表达式。</li></ul></li></ul><p>Rust 中的特殊返回类型：</p><ul><li>无返回值()，例如单元类型 <strong>()</strong>，是一个零长度的元组。它没啥作用，但是可以用来表达一个函数没有返回值：<ul><li>函数没有返回值，那么返回一个 ()</li><li>通过 ; 结尾的表达式返回一个 ()</li></ul></li><li>永不返回的发散函数 <strong>!</strong> ：当用 ! 作函数返回类型的时候，表示该函数永不返回( diverge function )</li></ul><p>示例：<br></p><pre class="line-numbers language-rust" data-language="rust"><code class="language-rust"><span class="token comment">//返回为：5</span><span class="token keyword">fn</span> <span class="token function-definition function">plus_one</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">-&gt;</span> <span class="token keyword">i32</span> <span class="token punctuation">{</span>    <span class="token number">5</span><span class="token punctuation">}</span><span class="token comment">//返回：（x+1）</span><span class="token keyword">fn</span> <span class="token function-definition function">plus_one</span><span class="token punctuation">(</span>x<span class="token punctuation">:</span> <span class="token keyword">i32</span><span class="token punctuation">)</span> <span class="token punctuation">-&gt;</span> <span class="token keyword">i32</span> <span class="token punctuation">{</span>    x <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">}</span><span class="token comment">//无返回，会报错</span><span class="token keyword">fn</span> <span class="token function-definition function">plus_one</span><span class="token punctuation">(</span>x<span class="token punctuation">:</span> <span class="token keyword">i32</span><span class="token punctuation">)</span> <span class="token punctuation">-&gt;</span> <span class="token keyword">i32</span> <span class="token punctuation">{</span>    x <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">let</span> y <span class="token operator">=</span> <span class="token punctuation">{</span>    <span class="token keyword">let</span> x <span class="token operator">=</span> <span class="token number">3</span><span class="token punctuation">;</span>    x <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token comment">//其中下面代码块代表数值：4，因（x+1）无分号</span><span class="token punctuation">{</span>    <span class="token keyword">let</span> x <span class="token operator">=</span> <span class="token number">3</span><span class="token punctuation">;</span>    x <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">}</span><span class="token comment">// （）</span><span class="token keyword">fn</span> <span class="token function-definition function">report</span><span class="token operator">&lt;</span><span class="token class-name">T</span><span class="token punctuation">:</span> <span class="token class-name">Debug</span><span class="token operator">&gt;</span><span class="token punctuation">(</span>item<span class="token punctuation">:</span> <span class="token class-name">T</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token macro property">println!</span><span class="token punctuation">(</span><span class="token string">"{:?}"</span><span class="token punctuation">,</span> item<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">fn</span> <span class="token function-definition function">clear</span><span class="token punctuation">(</span>text<span class="token punctuation">:</span> <span class="token operator">&amp;</span><span class="token keyword">mut</span> <span class="token class-name">String</span><span class="token punctuation">)</span> <span class="token punctuation">-&gt;</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token operator">*</span>text <span class="token operator">=</span> <span class="token class-name">String</span><span class="token punctuation">::</span><span class="token function">from</span><span class="token punctuation">(</span><span class="token string">""</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment">// ！</span><span class="token keyword">fn</span> <span class="token function-definition function">dead_end</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">-&gt;</span> <span class="token operator">!</span> <span class="token punctuation">{</span>  <span class="token macro property">panic!</span><span class="token punctuation">(</span><span class="token string">"你已经到了穷途末路，崩溃吧！"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">fn</span> <span class="token function-definition function">forever</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">-&gt;</span> <span class="token operator">!</span> <span class="token punctuation">{</span>  <span class="token keyword">loop</span> <span class="token punctuation">{</span>    <span class="token comment">//...</span>  <span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p></p><h4 id="3-4、控制流"><a href="#3-4、控制流" class="headerlink" title="3.4、控制流"></a>3.4、控制流</h4><ul><li>if</li><li>loop</li><li>while</li><li>for<pre class="line-numbers language-rust" data-language="rust"><code class="language-rust"><span class="token keyword">fn</span> <span class="token function-definition function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment">//if</span>    <span class="token keyword">let</span> number <span class="token operator">=</span> <span class="token number">3</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> number <span class="token operator">&gt;</span> <span class="token number">5</span> <span class="token punctuation">{</span>        <span class="token macro property">println!</span><span class="token punctuation">(</span><span class="token string">"number greater than 5"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> number <span class="token operator">&gt;</span> <span class="token number">3</span> <span class="token punctuation">{</span>        <span class="token macro property">println!</span><span class="token punctuation">(</span><span class="token string">"number greater than 3"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token keyword">else</span> <span class="token punctuation">{</span>        <span class="token macro property">println!</span><span class="token punctuation">(</span><span class="token string">"number less than or equal to 3"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">let</span> condition <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>    <span class="token keyword">let</span> number <span class="token operator">=</span> <span class="token keyword">if</span> condition <span class="token punctuation">{</span> <span class="token number">5</span> <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span> <span class="token number">6</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>    <span class="token comment">//loop</span>    <span class="token keyword">loop</span> <span class="token punctuation">{</span>        <span class="token macro property">println!</span><span class="token punctuation">(</span><span class="token string">"again!"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">let</span> <span class="token keyword">mut</span> remaining <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span>    <span class="token keyword">loop</span> <span class="token punctuation">{</span>        <span class="token macro property">println!</span><span class="token punctuation">(</span><span class="token string">"remaining = {}"</span><span class="token punctuation">,</span> remaining<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> remaining <span class="token operator">==</span> <span class="token number">9</span> <span class="token punctuation">{</span>            <span class="token keyword">break</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">if</span> count <span class="token operator">==</span> <span class="token number">2</span> <span class="token punctuation">{</span>            <span class="token keyword">break</span> <span class="token lifetime-annotation symbol">'counting_up</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        remaining <span class="token operator">-=</span> <span class="token number">1</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">let</span> <span class="token keyword">mut</span> counter <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">let</span> result <span class="token operator">=</span> <span class="token keyword">loop</span> <span class="token punctuation">{</span>        counter <span class="token operator">+=</span> <span class="token number">1</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> counter <span class="token operator">==</span> <span class="token number">10</span> <span class="token punctuation">{</span>            <span class="token keyword">break</span> counter <span class="token operator">*</span> <span class="token number">2</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">;</span>    <span class="token comment">//while</span>    <span class="token keyword">while</span> index <span class="token operator">&lt;</span> <span class="token number">5</span> <span class="token punctuation">{</span>        <span class="token macro property">println!</span><span class="token punctuation">(</span><span class="token string">"the value is: {}"</span><span class="token punctuation">,</span> a<span class="token punctuation">[</span>index<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        index <span class="token operator">+=</span> <span class="token number">1</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment">//for</span>    <span class="token keyword">let</span> a <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">10</span><span class="token punctuation">,</span> <span class="token number">20</span><span class="token punctuation">,</span> <span class="token number">30</span><span class="token punctuation">,</span> <span class="token number">40</span><span class="token punctuation">,</span> <span class="token number">50</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token keyword">for</span> element <span class="token keyword">in</span> a <span class="token punctuation">{</span>        <span class="token macro property">println!</span><span class="token punctuation">(</span><span class="token string">"the value is: {}"</span><span class="token punctuation">,</span> element<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ul><h3 id="四、所有权"><a href="#四、所有权" class="headerlink" title="四、所有权"></a>四、所有权</h3><p>所有权（系统）是 Rust 最为与众不同的特性，对语言的其他部分有着深刻含义。它让 Rust 无需垃圾回收（garbage collector）即可保障内存安全，因此理解 Rust 中所有权如何工作是十分重要的。本章，我们将讲到所有权以及相关功能：借用（borrowing）、slice 以及 Rust 如何在内存中布局数据。</p><h4 id="4-1、基础规则"><a href="#4-1、基础规则" class="headerlink" title="4.1、基础规则"></a>4.1、基础规则</h4><ol><li><strong>赋值相关操作</strong></li></ol><ul><li>Rust 中的每一个值都有一个被称为其 所有者（owner）的变量。  </li><li>值在任一时刻有且只有一个所有者。</li><li>当所有者（变量）离开作用域，这个值将被丢弃。<br>示例：<pre class="line-numbers language-rust" data-language="rust"><code class="language-rust"><span class="token keyword">fn</span> <span class="token function-definition function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">let</span> x <span class="token operator">=</span> <span class="token number">5</span><span class="token punctuation">;</span> <span class="token comment">//x有效</span>    y <span class="token operator">=</span> x<span class="token punctuation">;</span>  <span class="token comment">//x y均有效</span>    <span class="token keyword">let</span> s1 <span class="token operator">=</span> <span class="token class-name">String</span><span class="token punctuation">::</span><span class="token function">from</span><span class="token punctuation">(</span><span class="token string">"hello"</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//s1有效</span>    <span class="token keyword">let</span> s2 <span class="token operator">=</span> s1<span class="token punctuation">;</span>            <span class="token comment">//s1无效，s2有效，此种赋值称为移动（move）</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ul><ol><li><strong>克隆</strong><br>如果我们 确实 需要深度复制 String 中堆上的数据，而不仅仅是栈上的数据，可以使用一个叫做 clone 的通用函数。<pre class="line-numbers language-rust" data-language="rust"><code class="language-rust"><span class="token keyword">fn</span> <span class="token function-definition function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">let</span> s1 <span class="token operator">=</span> <span class="token class-name">String</span><span class="token punctuation">::</span><span class="token function">from</span><span class="token punctuation">(</span><span class="token string">"hello"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">let</span> s2 <span class="token operator">=</span> s1<span class="token punctuation">.</span><span class="token function">clone</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token macro property">println!</span><span class="token punctuation">(</span><span class="token string">"s1 = {}, s2 = {}"</span><span class="token punctuation">,</span> s1<span class="token punctuation">,</span> s2<span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment">//s1,s2都有效</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ol><p>但针对存储在栈上的数据，因其大小都是固定的，所有拷贝是速度最快，所有才会有x赋值给y后，x依旧有效 。Rust 有一个叫做 <strong>Copy trait</strong> 的特殊注解，可以用在类似整型这样的存储在栈上的类型上（。如果一个类型实现了 <strong>Copy trait</strong>，那么一个旧的变量在将其赋值给其他变量后仍然可用。Rust 不允许自身或其任何部分实现了 <strong>Drop trait</strong> 的类型使用 <strong>Copy trait</strong>。</p><p>一般情况下任何一组简单标量值的组合都可以实现 Copy，任何不需要分配内存或某种形式资源的类型都可以实现 Copy。如下是一些 Copy 的类型：     </p><ul><li>所有整数类型，比如 u32。</li><li>布尔类型，bool，它的值是 true 和 false。</li><li>所有浮点数类型，比如 f64。</li><li>字符类型，char。</li><li>元组，当且仅当其包含的类型也都实现 Copy 的时候。比如，(i32, i32) 实现了 Copy，但 (i32, String) 就没有。</li></ul><ol><li><em>**所有权与函数</em><pre class="line-numbers language-rust" data-language="rust"><code class="language-rust"><span class="token keyword">fn</span> <span class="token function-definition function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">let</span> s1 <span class="token operator">=</span> <span class="token function">gives_ownership</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>         <span class="token comment">// gives_ownership 将返回值</span>                                        <span class="token comment">// 转移给 s1</span>    <span class="token keyword">let</span> s2 <span class="token operator">=</span> <span class="token class-name">String</span><span class="token punctuation">::</span><span class="token function">from</span><span class="token punctuation">(</span><span class="token string">"hello"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token comment">// s2 进入作用域</span>    <span class="token keyword">let</span> s3 <span class="token operator">=</span> <span class="token function">takes_and_gives_back</span><span class="token punctuation">(</span>s2<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// s2 被移动到</span>                                        <span class="token comment">// takes_and_gives_back 中,</span>                                        <span class="token comment">// 它也将返回值移给 s3</span><span class="token punctuation">}</span> <span class="token comment">// 这里, s3 移出作用域并被丢弃。s2 也移出作用域，但已被移走，</span>  <span class="token comment">// 所以什么也不会发生。s1 离开作用域并被丢弃</span><span class="token keyword">fn</span> <span class="token function-definition function">gives_ownership</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">-&gt;</span> <span class="token class-name">String</span> <span class="token punctuation">{</span>             <span class="token comment">// gives_ownership 会将</span>                                             <span class="token comment">// 返回值移动给</span>                                             <span class="token comment">// 调用它的函数</span>    <span class="token keyword">let</span> some_string <span class="token operator">=</span> <span class="token class-name">String</span><span class="token punctuation">::</span><span class="token function">from</span><span class="token punctuation">(</span><span class="token string">"yours"</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// some_string 进入作用域.</span>    some_string                              <span class="token comment">// 返回 some_string </span>                                             <span class="token comment">// 并移出给调用的函数</span>                                             <span class="token comment">// </span><span class="token punctuation">}</span><span class="token comment">// takes_and_gives_back 将传入字符串并返回该值</span><span class="token keyword">fn</span> <span class="token function-definition function">takes_and_gives_back</span><span class="token punctuation">(</span>a_string<span class="token punctuation">:</span> <span class="token class-name">String</span><span class="token punctuation">)</span> <span class="token punctuation">-&gt;</span> <span class="token class-name">String</span> <span class="token punctuation">{</span> <span class="token comment">// a_string 进入作用域</span>                                                      <span class="token comment">// </span>    a_string  <span class="token comment">// 返回 a_string 并移出给调用的函数</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ol><h4 id="4-2、引用与借用"><a href="#4-2、引用与借用" class="headerlink" title="4.2、引用与借用"></a>4.2、引用与借用</h4><ol><li><strong>不可变引用</strong><br>当参数被传递给函数后，我们依旧需要使用它，如果单纯的使用函数返回的模式，就很形式主义了，所以我们需要一种方式，来保证将参数传递给函数我们依旧可以对其进行操作，这就是<strong>引用</strong>。<strong>引用</strong>（reference）像一个指针，因为它是一个地址，我们可以由此访问储存于该地址的属于其他变量的数据。与指针不同，引用确保指向某个特定类型的有效值。   </li></ol><p><strong>规则：</strong></p><ul><li>引用后变量并不具备该参数的所有权，所以当引用停止使用时，它所指向的值也不会被丢弃。</li><li>我们将创建一个引用的行为称为 借用（borrowing）。正如现实生活中，如果一个人拥有某样东西，你可以从他那里借来。当你使用完毕，必须还回去。我们并不拥有它。</li><li>对引用变量进行修改会报错，（默认）不允许修改引用的值。</li></ul><pre class="line-numbers language-rust" data-language="rust"><code class="language-rust"><span class="token keyword">fn</span> <span class="token function-definition function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">let</span> s1 <span class="token operator">=</span> <span class="token class-name">String</span><span class="token punctuation">::</span><span class="token function">from</span><span class="token punctuation">(</span><span class="token string">"hello"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">let</span> len <span class="token operator">=</span> <span class="token function">calculate_length</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>s1<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token macro property">println!</span><span class="token punctuation">(</span><span class="token string">"The length of '{}' is {}."</span><span class="token punctuation">,</span> s1<span class="token punctuation">,</span> len<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">fn</span> <span class="token function-definition function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">let</span> s1 <span class="token operator">=</span> <span class="token class-name">String</span><span class="token punctuation">::</span><span class="token function">from</span><span class="token punctuation">(</span><span class="token string">"hello"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">let</span> len <span class="token operator">=</span> <span class="token function">calculate_length</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>s1<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token macro property">println!</span><span class="token punctuation">(</span><span class="token string">"The length of '{}' is {}."</span><span class="token punctuation">,</span> s1<span class="token punctuation">,</span> len<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">fn</span> <span class="token function-definition function">calculate_length</span><span class="token punctuation">(</span>s<span class="token punctuation">:</span> <span class="token operator">&amp;</span><span class="token class-name">String</span><span class="token punctuation">)</span> <span class="token punctuation">-&gt;</span> <span class="token keyword">usize</span> <span class="token punctuation">{</span> <span class="token comment">// s is a reference to a String</span>    s<span class="token punctuation">.</span><span class="token function">len</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">}</span> <span class="token comment">// 这里，s 离开了作用域。但因为它并不拥有引用值的所有权，</span>  <span class="token comment">// 所以什么也不会发生</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ol><li>可变引用<br>针对不可变引用增加 <font color="red" size="5"><b>mut</b></font> 关键词即可变为可变引用。<pre class="line-numbers language-rust" data-language="rust"><code class="language-rust"><span class="token keyword">fn</span> <span class="token function-definition function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">let</span> <span class="token keyword">mut</span> s <span class="token operator">=</span> <span class="token class-name">String</span><span class="token punctuation">::</span><span class="token function">from</span><span class="token punctuation">(</span><span class="token string">"hello"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">change</span><span class="token punctuation">(</span><span class="token operator">&amp;</span><span class="token keyword">mut</span> s<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">fn</span> <span class="token function-definition function">change</span><span class="token punctuation">(</span>some_string<span class="token punctuation">:</span> <span class="token operator">&amp;</span><span class="token keyword">mut</span> <span class="token class-name">String</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    some_string<span class="token punctuation">.</span><span class="token function">push_str</span><span class="token punctuation">(</span><span class="token string">", world"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><strong>可变引用和不可变引用的使用规则：</strong></li></ol><ul><li>在任意给定时间，要么 只能有一个可变引用，要么 只能有多个不可变引用。</li><li>引用必须总是有效的。</li></ul><pre class="line-numbers language-rust" data-language="rust"><code class="language-rust"><span class="token keyword">fn</span> <span class="token function-definition function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">let</span> <span class="token keyword">mut</span> s <span class="token operator">=</span> <span class="token class-name">String</span><span class="token punctuation">::</span><span class="token function">from</span><span class="token punctuation">(</span><span class="token string">"hello"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">{</span>        <span class="token keyword">let</span> r1 <span class="token operator">=</span> <span class="token operator">&amp;</span><span class="token keyword">mut</span> s<span class="token punctuation">;</span>    <span class="token punctuation">}</span> <span class="token comment">// r1 在这里离开了作用域，所以我们完全可以创建一个新的引用</span>    <span class="token keyword">let</span> r2 <span class="token operator">=</span> <span class="token operator">&amp;</span><span class="token keyword">mut</span> s<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">fn</span> <span class="token function-definition function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">let</span> <span class="token keyword">mut</span> s <span class="token operator">=</span> <span class="token class-name">String</span><span class="token punctuation">::</span><span class="token function">from</span><span class="token punctuation">(</span><span class="token string">"hello"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">let</span> r1 <span class="token operator">=</span> <span class="token operator">&amp;</span>s<span class="token punctuation">;</span> <span class="token comment">// 没问题</span>    <span class="token keyword">let</span> r2 <span class="token operator">=</span> <span class="token operator">&amp;</span>s<span class="token punctuation">;</span> <span class="token comment">// 没问题</span>    <span class="token keyword">let</span> r3 <span class="token operator">=</span> <span class="token operator">&amp;</span><span class="token keyword">mut</span> s<span class="token punctuation">;</span> <span class="token comment">// 大问题</span>    <span class="token macro property">println!</span><span class="token punctuation">(</span><span class="token string">"{}, {}, and {}"</span><span class="token punctuation">,</span> r1<span class="token punctuation">,</span> r2<span class="token punctuation">,</span> r3<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="4-3、Slice-类型"><a href="#4-3、Slice-类型" class="headerlink" title="4.3、Slice 类型"></a>4.3、Slice 类型</h4><p><strong>slice:</strong> 允许你引用集合中一段连续的元素序列，而不用引用整个集合。slice 是一类引用，所以它没有所有权。<br></p><pre class="line-numbers language-rust" data-language="rust"><code class="language-rust"><span class="token keyword">fn</span> <span class="token function-definition function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment">//字符串类型</span>    <span class="token keyword">let</span> s <span class="token operator">=</span> <span class="token class-name">String</span><span class="token punctuation">::</span><span class="token function">from</span><span class="token punctuation">(</span><span class="token string">"hello world"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">let</span> hello <span class="token operator">=</span> <span class="token operator">&amp;</span>s<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">..</span><span class="token number">5</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token keyword">let</span> world <span class="token operator">=</span> <span class="token operator">&amp;</span>s<span class="token punctuation">[</span><span class="token number">6</span><span class="token punctuation">..</span><span class="token number">11</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token comment">//数组</span>    <span class="token keyword">let</span> a <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token keyword">let</span> slice <span class="token operator">=</span> <span class="token operator">&amp;</span>a<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">..</span><span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p></p><h3 id="五、结构体"><a href="#五、结构体" class="headerlink" title="五、结构体"></a>五、结构体</h3><h4 id="5-1、实例化"><a href="#5-1、实例化" class="headerlink" title="5.1、实例化"></a>5.1、实例化</h4><ol><li>概念<br>结构体类型面向对象语言中的类的概念，一样含有自身的属性字段等信息。<pre class="line-numbers language-rust" data-language="rust"><code class="language-rust"><span class="token keyword">struct</span> <span class="token type-definition class-name">User</span> <span class="token punctuation">{</span>    active<span class="token punctuation">:</span> <span class="token keyword">bool</span><span class="token punctuation">,</span>    username<span class="token punctuation">:</span> <span class="token class-name">String</span><span class="token punctuation">,</span>    email<span class="token punctuation">:</span> <span class="token class-name">String</span><span class="token punctuation">,</span>    sign_in_count<span class="token punctuation">:</span> <span class="token keyword">u64</span><span class="token punctuation">,</span><span class="token punctuation">}</span><span class="token comment">//创建</span><span class="token keyword">fn</span> <span class="token function-definition function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">let</span> user1 <span class="token operator">=</span> <span class="token class-name">User</span> <span class="token punctuation">{</span>        email<span class="token punctuation">:</span> <span class="token class-name">String</span><span class="token punctuation">::</span><span class="token function">from</span><span class="token punctuation">(</span><span class="token string">"someone@example.com"</span><span class="token punctuation">)</span><span class="token punctuation">,</span>        username<span class="token punctuation">:</span> <span class="token class-name">String</span><span class="token punctuation">::</span><span class="token function">from</span><span class="token punctuation">(</span><span class="token string">"someusername123"</span><span class="token punctuation">)</span><span class="token punctuation">,</span>        active<span class="token punctuation">:</span> <span class="token boolean">true</span><span class="token punctuation">,</span>        sign_in_count<span class="token punctuation">:</span> <span class="token number">1</span><span class="token punctuation">,</span>    <span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">fn</span> <span class="token function-definition function">build_user</span><span class="token punctuation">(</span>email<span class="token punctuation">:</span> <span class="token class-name">String</span><span class="token punctuation">,</span> username<span class="token punctuation">:</span> <span class="token class-name">String</span><span class="token punctuation">)</span> <span class="token punctuation">-&gt;</span> <span class="token class-name">User</span> <span class="token punctuation">{</span>    <span class="token class-name">User</span> <span class="token punctuation">{</span>        email<span class="token punctuation">:</span> email<span class="token punctuation">,</span>        username<span class="token punctuation">:</span> username<span class="token punctuation">,</span>        active<span class="token punctuation">:</span> <span class="token boolean">true</span><span class="token punctuation">,</span>        sign_in_count<span class="token punctuation">:</span> <span class="token number">1</span><span class="token punctuation">,</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">fn</span> <span class="token function-definition function">build_user</span><span class="token punctuation">(</span>email<span class="token punctuation">:</span> <span class="token class-name">String</span><span class="token punctuation">,</span> username<span class="token punctuation">:</span> <span class="token class-name">String</span><span class="token punctuation">)</span> <span class="token punctuation">-&gt;</span> <span class="token class-name">User</span> <span class="token punctuation">{</span>    <span class="token class-name">User</span> <span class="token punctuation">{</span>        email<span class="token punctuation">,</span>        username<span class="token punctuation">,</span>        active<span class="token punctuation">:</span> <span class="token boolean">true</span><span class="token punctuation">,</span>        sign_in_count<span class="token punctuation">:</span> <span class="token number">1</span><span class="token punctuation">,</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">fn</span> <span class="token function-definition function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment">// --snip--</span>    <span class="token keyword">let</span> user2 <span class="token operator">=</span> <span class="token class-name">User</span> <span class="token punctuation">{</span>        active<span class="token punctuation">:</span> user1<span class="token punctuation">.</span>active<span class="token punctuation">,</span>        username<span class="token punctuation">:</span> user1<span class="token punctuation">.</span>username<span class="token punctuation">,</span>        email<span class="token punctuation">:</span> <span class="token class-name">String</span><span class="token punctuation">::</span><span class="token function">from</span><span class="token punctuation">(</span><span class="token string">"another@example.com"</span><span class="token punctuation">)</span><span class="token punctuation">,</span>        sign_in_count<span class="token punctuation">:</span> user1<span class="token punctuation">.</span>sign_in_count<span class="token punctuation">,</span>    <span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li>所有权<br>我们使用了自身拥有所有权的 String 类型而不是 &amp;str 字符串 slice 类型。这是一个有意而为之的选择，因为我们想要这个结构体拥有它所有的数据，为此只要整个结构体是有效的话其数据也是有效的。<br>可以使结构体存储被其他对象拥有的数据的引用，不过这么做的话需要用上 生命周期（lifetimes）。</li></ol><pre class="line-numbers language-rust" data-language="rust"><code class="language-rust"><span class="token attribute attr-name">#[derive(Debug)]</span><span class="token keyword">struct</span> <span class="token type-definition class-name">Rectangle</span> <span class="token punctuation">{</span>    width<span class="token punctuation">:</span> <span class="token keyword">u32</span><span class="token punctuation">,</span>    height<span class="token punctuation">:</span> <span class="token keyword">u32</span><span class="token punctuation">,</span><span class="token punctuation">}</span><span class="token keyword">fn</span> <span class="token function-definition function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">let</span> scale <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span>    <span class="token keyword">let</span> rect1 <span class="token operator">=</span> <span class="token class-name">Rectangle</span> <span class="token punctuation">{</span>        width<span class="token punctuation">:</span> <span class="token macro property">dbg!</span><span class="token punctuation">(</span><span class="token number">30</span> <span class="token operator">*</span> scale<span class="token punctuation">)</span><span class="token punctuation">,</span>        height<span class="token punctuation">:</span> <span class="token number">50</span><span class="token punctuation">,</span>    <span class="token punctuation">}</span><span class="token punctuation">;</span>    <span class="token macro property">dbg!</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>rect1<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">/* 输出：&amp;rect1 = Rectangle {                                width: 60,                                height: 50,                            } */</span>    <span class="token macro property">println!</span><span class="token punctuation">(</span><span class="token string">"rect1 is {:?}"</span><span class="token punctuation">,</span> rect1<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//输出：rect1 is Rectangle { width: 30, height: 50 }</span>    <span class="token comment">//{:#?}：也可用此表达书进行输出格式化</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>#[derive(Debug)]：</strong>配和 <strong>{:?}</strong> 方便输出调试<br><strong>dbg!：</strong> 放在表达式 30 * scale 周围，因为 dbg! 返回表达式的值的所有权。</p><h4 id="5-2、方法语法"><a href="#5-2、方法语法" class="headerlink" title="5.2、方法语法"></a>5.2、方法语法</h4><ul><li>方法（method）：与函数类似，它们使用 fn 关键字和名称声明，可以拥有参数和返回值，同时包含在某处调用该方法时会执行的代码。不过方法与函数是不同的，因为它们在结构体的上下文中被定义（，并且它们第一个参数总是 self，它代表调用该方法的结构体实例。</li><li>impl：是 implementation 的缩写），这个 impl 块中的所有内容都将与<strong>所实现的结构体</strong>类型相关联。</li><li>每个结构体都允许拥有多个 impl 块。</li><li>关联函数：所有在 impl 块中定义的函数被称为 <strong>关联函数（associated functions）</strong>，因为它们与 <strong>impl</strong> 后面命名的类型相关。我们可以定义不以 self 为第一参数的关联函数（因此不是方法），因为它们并不作用于一个结构体的实例。如：代码示例中的《square》.</li><li>非结构体方法类关联函数使用 <strong>结构体名</strong> 和 <strong>::</strong> 语法来调用这个关联函数<pre class="line-numbers language-rust" data-language="rust"><code class="language-rust"><span class="token attribute attr-name">#[derive(Debug)]</span><span class="token keyword">struct</span> <span class="token type-definition class-name">Rectangle</span> <span class="token punctuation">{</span>    width<span class="token punctuation">:</span> <span class="token keyword">u32</span><span class="token punctuation">,</span>    height<span class="token punctuation">:</span> <span class="token keyword">u32</span><span class="token punctuation">,</span><span class="token punctuation">}</span><span class="token keyword">impl</span> <span class="token class-name">Rectangle</span> <span class="token punctuation">{</span>    <span class="token keyword">fn</span> <span class="token function-definition function">area</span><span class="token punctuation">(</span><span class="token operator">&amp;</span><span class="token keyword">self</span><span class="token punctuation">)</span> <span class="token punctuation">-&gt;</span> <span class="token keyword">u32</span> <span class="token punctuation">{</span>        <span class="token keyword">self</span><span class="token punctuation">.</span>width <span class="token operator">*</span> <span class="token keyword">self</span><span class="token punctuation">.</span>height    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">impl</span> <span class="token class-name">Rectangle</span> <span class="token punctuation">{</span>    <span class="token keyword">fn</span> <span class="token function-definition function">can_hold</span><span class="token punctuation">(</span><span class="token operator">&amp;</span><span class="token keyword">self</span><span class="token punctuation">,</span> other<span class="token punctuation">:</span> <span class="token operator">&amp;</span><span class="token class-name">Rectangle</span><span class="token punctuation">)</span> <span class="token punctuation">-&gt;</span> <span class="token keyword">bool</span> <span class="token punctuation">{</span>        <span class="token keyword">self</span><span class="token punctuation">.</span>width <span class="token operator">&gt;</span> other<span class="token punctuation">.</span>width <span class="token operator">&amp;&amp;</span> <span class="token keyword">self</span><span class="token punctuation">.</span>height <span class="token operator">&gt;</span> other<span class="token punctuation">.</span>height    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">impl</span> <span class="token class-name">Rectangle</span> <span class="token punctuation">{</span>    <span class="token keyword">fn</span> <span class="token function-definition function">square</span><span class="token punctuation">(</span>size<span class="token punctuation">:</span> <span class="token keyword">u32</span><span class="token punctuation">)</span> <span class="token punctuation">-&gt;</span> <span class="token class-name">Rectangle</span> <span class="token punctuation">{</span>        <span class="token class-name">Rectangle</span> <span class="token punctuation">{</span>            width<span class="token punctuation">:</span> size<span class="token punctuation">,</span>            height<span class="token punctuation">:</span> size<span class="token punctuation">,</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">fn</span> <span class="token function-definition function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">let</span> rect1 <span class="token operator">=</span> <span class="token class-name">Rectangle</span> <span class="token punctuation">{</span>        width<span class="token punctuation">:</span> <span class="token number">30</span><span class="token punctuation">,</span>        height<span class="token punctuation">:</span> <span class="token number">50</span><span class="token punctuation">,</span>    <span class="token punctuation">}</span><span class="token punctuation">;</span>    <span class="token keyword">let</span> rect2 <span class="token operator">=</span> <span class="token class-name">Rectangle</span> <span class="token punctuation">{</span>        width<span class="token punctuation">:</span> <span class="token number">10</span><span class="token punctuation">,</span>        height<span class="token punctuation">:</span> <span class="token number">40</span><span class="token punctuation">,</span>    <span class="token punctuation">}</span><span class="token punctuation">;</span>    <span class="token keyword">let</span> rect3 <span class="token operator">=</span> <span class="token class-name">Rectangle</span> <span class="token punctuation">{</span>        width<span class="token punctuation">:</span> <span class="token number">60</span><span class="token punctuation">,</span>        height<span class="token punctuation">:</span> <span class="token number">45</span><span class="token punctuation">,</span>    <span class="token punctuation">}</span><span class="token punctuation">;</span>    <span class="token macro property">println!</span><span class="token punctuation">(</span><span class="token string">"Can rect1 hold rect2? {}"</span><span class="token punctuation">,</span> rect1<span class="token punctuation">.</span><span class="token function">can_hold</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>rect2<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token macro property">println!</span><span class="token punctuation">(</span><span class="token string">"Can rect1 hold rect3? {}"</span><span class="token punctuation">,</span> rect1<span class="token punctuation">.</span><span class="token function">can_hold</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>rect3<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ul><h3 id="六、枚举和模式匹配"><a href="#六、枚举和模式匹配" class="headerlink" title="六、枚举和模式匹配"></a>六、枚举和模式匹配</h3><h4 id="6-1、枚举"><a href="#6-1、枚举" class="headerlink" title="6.1、枚举"></a>6.1、枚举</h4><ol><li><strong>枚举</strong>：枚举是一个不同于结构体的定义自定义数据类型的方式。<pre class="line-numbers language-rust" data-language="rust"><code class="language-rust"><span class="token comment">// 简单型枚举</span><span class="token keyword">enum</span> <span class="token type-definition class-name">IpAddrKind</span> <span class="token punctuation">{</span>    <span class="token constant">V4</span><span class="token punctuation">,</span>    <span class="token constant">V6</span><span class="token punctuation">,</span><span class="token punctuation">}</span><span class="token keyword">fn</span> <span class="token function-definition function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">let</span> four <span class="token operator">=</span> <span class="token class-name">IpAddrKind</span><span class="token punctuation">::</span><span class="token constant">V4</span><span class="token punctuation">;</span>    <span class="token keyword">let</span> six <span class="token operator">=</span> <span class="token class-name">IpAddrKind</span><span class="token punctuation">::</span><span class="token constant">V6</span><span class="token punctuation">;</span>    <span class="token function">route</span><span class="token punctuation">(</span><span class="token class-name">IpAddrKind</span><span class="token punctuation">::</span><span class="token constant">V4</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">route</span><span class="token punctuation">(</span><span class="token class-name">IpAddrKind</span><span class="token punctuation">::</span><span class="token constant">V6</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">fn</span> <span class="token function-definition function">route</span><span class="token punctuation">(</span>ip_kind<span class="token punctuation">:</span> <span class="token class-name">IpAddrKind</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token comment">// 标量类型为内容的枚举</span><span class="token keyword">fn</span> <span class="token function-definition function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">enum</span> <span class="token type-definition class-name">IpAddr</span> <span class="token punctuation">{</span>        <span class="token constant">V4</span><span class="token punctuation">(</span><span class="token keyword">u8</span><span class="token punctuation">,</span> <span class="token keyword">u8</span><span class="token punctuation">,</span> <span class="token keyword">u8</span><span class="token punctuation">,</span> <span class="token keyword">u8</span><span class="token punctuation">)</span><span class="token punctuation">,</span>        <span class="token constant">V6</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">)</span><span class="token punctuation">,</span>    <span class="token punctuation">}</span>    <span class="token keyword">let</span> home <span class="token operator">=</span> <span class="token class-name">IpAddr</span><span class="token punctuation">::</span><span class="token constant">V4</span><span class="token punctuation">(</span><span class="token number">127</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">let</span> loopback <span class="token operator">=</span> <span class="token class-name">IpAddr</span><span class="token punctuation">::</span><span class="token constant">V6</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">::</span><span class="token function">from</span><span class="token punctuation">(</span><span class="token string">"::1"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment">// 结构体为内容的枚举</span><span class="token attribute attr-name">#![allow(unused)]</span><span class="token keyword">fn</span> <span class="token function-definition function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">struct</span> <span class="token type-definition class-name">Ipv4Addr</span> <span class="token punctuation">{</span>        <span class="token comment">// --snip--</span>    <span class="token punctuation">}</span>    <span class="token keyword">struct</span> <span class="token type-definition class-name">Ipv6Addr</span> <span class="token punctuation">{</span>        <span class="token comment">// --snip--</span>    <span class="token punctuation">}</span>    <span class="token keyword">enum</span> <span class="token type-definition class-name">IpAddr</span> <span class="token punctuation">{</span>        <span class="token constant">V4</span><span class="token punctuation">(</span><span class="token class-name">Ipv4Addr</span><span class="token punctuation">)</span><span class="token punctuation">,</span>        <span class="token constant">V6</span><span class="token punctuation">(</span><span class="token class-name">Ipv6Addr</span><span class="token punctuation">)</span><span class="token punctuation">,</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><strong>Option</strong>：Option 是标准库定义的另一个枚举。Option 类型应用广泛因为它编码了一个非常普遍的场景，即一个值要么有值要么没值。在<a href="https://doc.rust-lang.org/std/option/enum.Option.html">标准库</a>中的源码：<pre class="line-numbers language-rust" data-language="rust"><code class="language-rust"><span class="token attribute attr-name">#![allow(unused)]</span><span class="token keyword">fn</span> <span class="token function-definition function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token keyword">enum</span> <span class="token type-definition class-name">Option</span><span class="token operator">&lt;</span><span class="token class-name">T</span><span class="token operator">&gt;</span> <span class="token punctuation">{</span>    <span class="token class-name">None</span><span class="token punctuation">,</span>    <span class="token class-name">Some</span><span class="token punctuation">(</span><span class="token class-name">T</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ol><h4 id="6-2：match-控制流运算符"><a href="#6-2：match-控制流运算符" class="headerlink" title="6.2：match 控制流运算符"></a>6.2：match 控制流运算符</h4><p>Rust 有一个叫做 match 的极为强大的控制流运算符，它允许我们将一个值与一系列的模式相比较，并根据相匹配的模式执行相应代码。类似Java中的<strong>switch-case</strong>。<br></p><pre class="line-numbers language-rust" data-language="rust"><code class="language-rust"><span class="token keyword">enum</span> <span class="token type-definition class-name">Coin</span> <span class="token punctuation">{</span>    <span class="token class-name">Penny</span><span class="token punctuation">,</span>    <span class="token class-name">Nickel</span><span class="token punctuation">,</span>    <span class="token class-name">Dime</span><span class="token punctuation">,</span>    <span class="token class-name">Quarter</span><span class="token punctuation">,</span>    <span class="token class-name">Other</span><span class="token punctuation">,</span><span class="token punctuation">}</span><span class="token keyword">fn</span> <span class="token function-definition function">value_in_cents</span><span class="token punctuation">(</span>coin<span class="token punctuation">:</span> <span class="token class-name">Coin</span><span class="token punctuation">)</span> <span class="token punctuation">-&gt;</span> <span class="token keyword">u8</span> <span class="token punctuation">{</span>    <span class="token keyword">match</span> coin <span class="token punctuation">{</span>        <span class="token class-name">Coin</span><span class="token punctuation">::</span><span class="token class-name">Penny</span> <span class="token operator">=&gt;</span> <span class="token number">1</span><span class="token punctuation">,</span>        <span class="token class-name">Coin</span><span class="token punctuation">::</span><span class="token class-name">Nickel</span> <span class="token operator">=&gt;</span> <span class="token number">5</span><span class="token punctuation">,</span>        <span class="token class-name">Coin</span><span class="token punctuation">::</span><span class="token class-name">Dime</span> <span class="token operator">=&gt;</span> <span class="token number">10</span><span class="token punctuation">,</span>        <span class="token class-name">Coin</span><span class="token punctuation">::</span><span class="token class-name">Quarter</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>            <span class="token comment">// 逻辑处理，此代码块，即{}之内的内容为表达式，而表达式的结果值将作为整个 match 表达式的返回值。</span>            <span class="token macro property">println!</span><span class="token punctuation">(</span><span class="token string">"Coin is Quarter!"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token number">1</span>        <span class="token punctuation">}</span>        <span class="token comment">// other:Other,    //此处为通配符，满足match为有穷尽的匹配规则。</span>        <span class="token comment">// _ =&gt; (),     //  "_"，这是一个特殊的模式，可以匹配任意值而不绑定到该值。</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p></p><h4 id="6-3、if-let-简单控制流"><a href="#6-3、if-let-简单控制流" class="headerlink" title="6.3、if let 简单控制流"></a>6.3、if let 简单控制流</h4><p><strong>if let</strong> 语法让我们以一种不那么冗长的方式结合 <strong>if</strong> 和 <strong>let</strong>，来处理只匹配一个模式的值而忽略其他模式的情况。换句话说，可以认为 <strong>if let</strong> 是 <strong>match</strong> 的一个语法糖，它当值匹配某一模式时执行代码而忽略所有其他值。<br></p><pre class="line-numbers language-rust" data-language="rust"><code class="language-rust"><span class="token attribute attr-name">#[derive(Debug)]</span><span class="token keyword">enum</span> <span class="token type-definition class-name">UsState</span> <span class="token punctuation">{</span>    <span class="token class-name">Alabama</span><span class="token punctuation">,</span>    <span class="token class-name">Alaska</span><span class="token punctuation">,</span>    <span class="token comment">// --snip--</span><span class="token punctuation">}</span><span class="token keyword">enum</span> <span class="token type-definition class-name">Coin</span> <span class="token punctuation">{</span>    <span class="token class-name">Penny</span><span class="token punctuation">,</span>    <span class="token class-name">Nickel</span><span class="token punctuation">,</span>    <span class="token class-name">Dime</span><span class="token punctuation">,</span>    <span class="token class-name">Quarter</span><span class="token punctuation">(</span><span class="token class-name">UsState</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token punctuation">}</span><span class="token keyword">fn</span> <span class="token function-definition function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment">// let mut count = 0;</span>    <span class="token comment">// match coin {</span>    <span class="token comment">//     Coin::Quarter(state) =&gt; println!("State quarter from {:?}!", state),</span>    <span class="token comment">//     _ =&gt; count += 1,</span>    <span class="token comment">// }</span>    <span class="token comment">// if let 模式</span>    <span class="token keyword">let</span> coin <span class="token operator">=</span> <span class="token class-name">Coin</span><span class="token punctuation">::</span><span class="token class-name">Penny</span><span class="token punctuation">;</span>    <span class="token keyword">let</span> <span class="token keyword">mut</span> count <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token keyword">let</span> <span class="token class-name">Coin</span><span class="token punctuation">::</span><span class="token class-name">Quarter</span><span class="token punctuation">(</span>state<span class="token punctuation">)</span> <span class="token operator">=</span> coin <span class="token punctuation">{</span>        <span class="token macro property">println!</span><span class="token punctuation">(</span><span class="token string">"State quarter from {:?}!"</span><span class="token punctuation">,</span> state<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>        count <span class="token operator">+=</span> <span class="token number">1</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p></p><h3 id="七、package-crate-module"><a href="#七、package-crate-module" class="headerlink" title="七、package/crate/module"></a>七、package/crate/module</h3><ol><li><strong>crate</strong><br><strong>crate</strong>：是一个二进制项或者库。crate root 是一个源文件，Rust 编译器以它为起始点，并构成你的 crate 的根模块。</li></ol><p><strong>create类型：</strong><br>rust里有两种crate，lib类型和bin类型，并且默认以文件名为标准按以下规则处理crate：</p><ul><li>src/main.rs：表示该crate是一个bin类型的crate</li><li>src/lib.rs：表示该crate是一个lib类型的crate<br>src/main.rs和src/lib.rs都是crate的根，也就是crate引用、rustc编译的入口。</li></ul><ol><li><strong>包（package）</strong><br><strong>包（package）</strong>：是提供一系列功能的一个或者多个 crate。cargo new 命令会创建一个新项目，也是一个package，里面有一个Cargo.toml文件，用于定义package、所需外部依赖，以及如何编译crate等。</li></ol><p><strong>包的规则：</strong></p><pre><code>* 包中可以包含至多一个库 crate(library crate)。* 包中可以包含任意多个二进制 crate(binary crate),但是必须至少包含一个 crate.     </code></pre><p>此外，一个package中的crate还有如下约束：</p><ul><li>多个bin类型的crate</li><li>0个或1个lib类型的crate<br>其中，1和2并不互斥，也就是说一个项目下可以有1个lib和多个bin类型的crate，即一个package还以编译出多个可执行文件。</li></ul><p>只是如果有多个bin类型的crate，一个src/main.rs就不行了，就得放到 src/bin 下面，每个crate一个文件，换句话说，每个文件都是一个不同的crate。</p><ol><li><p><strong>模块</strong><br><strong>模块</strong>：让我们可以将一个 crate 中的代码进行分组，以提高可读性与重用性。模块还可以控制项的 私有性，即项是可以被外部代码使用的（public），还是作为一个内部实现的内容，不能被外部代码使用（private）。</p><pre class="line-numbers language-rust" data-language="rust"><code class="language-rust"><span class="token keyword">mod</span> <span class="token module-declaration namespace">front_of_house</span> <span class="token punctuation">{</span>    <span class="token keyword">mod</span> <span class="token module-declaration namespace">hosting</span> <span class="token punctuation">{</span>        <span class="token keyword">fn</span> <span class="token function-definition function">add_to_waitlist</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>        <span class="token keyword">fn</span> <span class="token function-definition function">seat_at_table</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token keyword">mod</span> <span class="token module-declaration namespace">serving</span> <span class="token punctuation">{</span>        <span class="token keyword">fn</span> <span class="token function-definition function">take_order</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>        <span class="token keyword">fn</span> <span class="token function-definition function">serve_order</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>        <span class="token keyword">fn</span> <span class="token function-definition function">take_payment</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>我们定义一个模块，是以 mod 关键字为起始，然后指定模块的名字（本例中叫做 front_of_house），并且用花括号包围模块的主体。在模块内，我们还可以定义其他的模块，就像本例中的 hosting 和 serving 模块。模块还可以保存一些定义的其他项，比如结构体、枚举、常量、特性、或者函数。</p></li><li><p><strong>路径及引用</strong><br><strong>use</strong>：在crate和模块了可能定义了函数、结构体等，要想在其他模块或crate使用，需要将其引入到当前scope中，类似java的import的功能，rust里需要使用use。  </p></li></ol><p><strong>路径</strong>：rust中use引用的路径分为两种：</p><ul><li>绝对路径（absolute path）从 crate 根开始，以 crate 名或者字面值 crate 开头。</li><li>相对路径（relative path）从当前模块开始，以 self、super 或当前模块的标识符开头。</li></ul><pre class="line-numbers language-rust" data-language="rust"><code class="language-rust"><span class="token keyword">mod</span> <span class="token module-declaration namespace">front_of_house</span> <span class="token punctuation">{</span>    <span class="token keyword">pub</span> <span class="token keyword">mod</span> <span class="token module-declaration namespace">hosting</span> <span class="token punctuation">{</span>        <span class="token keyword">pub</span> <span class="token keyword">fn</span> <span class="token function-definition function">add_to_waitlist</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">pub</span> <span class="token keyword">fn</span> <span class="token function-definition function">eat_at_restaurant</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment">// 绝对路径</span>    <span class="token keyword">crate</span><span class="token module-declaration namespace"><span class="token punctuation">::</span>front_of_house<span class="token punctuation">::</span>hosting<span class="token punctuation">::</span></span><span class="token function">add_to_waitlist</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// 相对路径</span>    <span class="token namespace">front_of_house<span class="token punctuation">::</span>hosting<span class="token punctuation">::</span></span><span class="token function">add_to_waitlist</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment">// 引用相关操作</span><span class="token keyword">use</span> <span class="token namespace">std<span class="token punctuation">::</span></span>io<span class="token punctuation">;</span><span class="token keyword">use</span> <span class="token namespace">std<span class="token punctuation">::</span>cmp<span class="token punctuation">::</span></span><span class="token class-name">Ordering</span><span class="token punctuation">;</span><span class="token comment">// 以上两行引用等价于：use std::{cmp::Ordering, io};</span><span class="token keyword">use</span> <span class="token namespace">std<span class="token punctuation">::</span></span>io<span class="token punctuation">;</span><span class="token keyword">use</span> <span class="token namespace">std<span class="token punctuation">::</span>io<span class="token punctuation">::</span></span><span class="token class-name">Write</span><span class="token punctuation">;</span><span class="token comment">// 等价于：use std::io::{self, Write};</span><span class="token comment">// 通配符</span><span class="token keyword">use</span> <span class="token namespace">std<span class="token punctuation">::</span>collections<span class="token punctuation">::</span></span><span class="token operator">*</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>pub修饰符</strong><br>结构体和枚举:要想访问其他mod里的结构体，需要将结构体声明为pub，但是这也只能访问到结构体而已，如果要想操作里面的字段，可以有两种方式：</p><ul><li>提供pub的方法修改字段</li><li>将需要操作的字段直接修改为pub类型  </li><li>在父模块中不能使用子模块中的private项目</li><li>子模块可以使用父模块中的所有item</li></ul><p>可能前者更“面向对象”一些。<br>而枚举类型的话只需要在枚举名前面加上pub即可，不需要对其中的variant进行设置。</p><p><strong>re-exporting 再导出</strong><br>当使用use关键字将外部item导入到当前scope之后，这个item在当前scope是private的，如果使用 pub use 的话，还能让使用当前mod的第三者，使用在该mod中引入的item。</p><ol><li><strong>workspace</strong><br>workspace用于管理多个相关的package，不同的package有各自的Cargo.toml，但是整个workspace共享一个Cargo.lock，也只有一个target目录（编译输出）。</li></ol><p>虽然workspace内的项目共享一个Cargo.lock，但是他们之间默认不互相依赖，需要显示添加它们之间的依赖关系。而且在一个项目中添加的依赖，在其他项目中如果想使用，还需要再次声明依赖才行。</p><h3 id="八、错误处理"><a href="#八、错误处理" class="headerlink" title="八、错误处理"></a>八、错误处理</h3><p>Rust 将错误分为两大类：</p><ul><li><strong>可恢复的（recoverable）</strong>：比如文件未找到的错误，我们很可能只想向用户报告问题并重试操作。此种错误使用 <strong>Result<t, e=""></t,></strong> 类型来处理问题。</li><li><strong>不可恢复的（unrecoverable）</strong>：对于一个可恢复的错误，不可恢复的错误总是 bug 出现的征兆，比如试图访问一个超过数组末端的位置，因此我们要立即停止程序。此种错误由 <strong>panic! 宏</strong> 来处理。</li></ul><h4 id="8-1、panic-与不可恢复的错误"><a href="#8-1、panic-与不可恢复的错误" class="headerlink" title="8.1、panic! 与不可恢复的错误"></a>8.1、panic! 与不可恢复的错误</h4><p><strong>panic</strong> ：处理的两种机制：</p><ul><li><strong>展开（unwinding）</strong>：这意味着 Rust 会回溯栈并清理它遇到的每一个函数的数据，不过这个回溯并清理的过程有很多工作。</li><li><strong>终止（abort）</strong>：这会不清理数据就退出程序。<br>切换方式：Cargo.toml 的 [profile] 部分增加 panic = ‘abort’，可以由展开切换为终止。</li></ul><h4 id="8-2、Result-与可恢复的错误"><a href="#8-2、Result-与可恢复的错误" class="headerlink" title="8.2、Result 与可恢复的错误"></a>8.2、Result 与可恢复的错误</h4><ol><li><strong>Result枚举</strong>，它定义有如下两个成员，Ok 和 Err：<pre class="line-numbers language-rust" data-language="rust"><code class="language-rust"><span class="token attribute attr-name">#![allow(unused)]</span><span class="token keyword">fn</span> <span class="token function-definition function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">enum</span> <span class="token type-definition class-name">Result</span><span class="token operator">&lt;</span><span class="token class-name">T</span><span class="token punctuation">,</span> <span class="token class-name">E</span><span class="token operator">&gt;</span> <span class="token punctuation">{</span>        <span class="token class-name">Ok</span><span class="token punctuation">(</span><span class="token class-name">T</span><span class="token punctuation">)</span><span class="token punctuation">,</span>        <span class="token class-name">Err</span><span class="token punctuation">(</span><span class="token class-name">E</span><span class="token punctuation">)</span><span class="token punctuation">,</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token comment">// 应用示例</span><span class="token keyword">use</span> <span class="token namespace">std<span class="token punctuation">::</span>fs<span class="token punctuation">::</span></span><span class="token class-name">File</span><span class="token punctuation">;</span><span class="token keyword">use</span> <span class="token namespace">std<span class="token punctuation">::</span>io<span class="token punctuation">::</span></span><span class="token class-name">ErrorKind</span><span class="token punctuation">;</span><span class="token keyword">fn</span> <span class="token function-definition function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">let</span> f <span class="token operator">=</span> <span class="token class-name">File</span><span class="token punctuation">::</span><span class="token function">open</span><span class="token punctuation">(</span><span class="token string">"hello.txt"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">let</span> f <span class="token operator">=</span> <span class="token keyword">match</span> f <span class="token punctuation">{</span>        <span class="token class-name">Ok</span><span class="token punctuation">(</span>file<span class="token punctuation">)</span> <span class="token operator">=&gt;</span> file<span class="token punctuation">,</span>        <span class="token class-name">Err</span><span class="token punctuation">(</span>error<span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token keyword">match</span> error<span class="token punctuation">.</span><span class="token function">kind</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token class-name">ErrorKind</span><span class="token punctuation">::</span><span class="token class-name">NotFound</span> <span class="token operator">=&gt;</span> <span class="token keyword">match</span> <span class="token class-name">File</span><span class="token punctuation">::</span><span class="token function">create</span><span class="token punctuation">(</span><span class="token string">"hello.txt"</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token class-name">Ok</span><span class="token punctuation">(</span>fc<span class="token punctuation">)</span> <span class="token operator">=&gt;</span> fc<span class="token punctuation">,</span>                <span class="token class-name">Err</span><span class="token punctuation">(</span>e<span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token macro property">panic!</span><span class="token punctuation">(</span><span class="token string">"Problem creating the file: {:?}"</span><span class="token punctuation">,</span> e<span class="token punctuation">)</span><span class="token punctuation">,</span>            <span class="token punctuation">}</span><span class="token punctuation">,</span>            other_error <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>                <span class="token macro property">panic!</span><span class="token punctuation">(</span><span class="token string">"Problem opening the file: {:?}"</span><span class="token punctuation">,</span> other_error<span class="token punctuation">)</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span><span class="token punctuation">,</span>    <span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li>失败时 panic 的简写：<strong>unwrap</strong> 和 <strong>expect</strong><pre class="line-numbers language-rust" data-language="rust"><code class="language-rust"><span class="token keyword">use</span> <span class="token namespace">std<span class="token punctuation">::</span>fs<span class="token punctuation">::</span></span><span class="token class-name">File</span><span class="token punctuation">;</span><span class="token keyword">fn</span> <span class="token function-definition function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">let</span> f <span class="token operator">=</span> <span class="token class-name">File</span><span class="token punctuation">::</span><span class="token function">open</span><span class="token punctuation">(</span><span class="token string">"hello.txt"</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">unwrap</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">let</span> f <span class="token operator">=</span> <span class="token class-name">File</span><span class="token punctuation">::</span><span class="token function">open</span><span class="token punctuation">(</span><span class="token string">"hello.txt"</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">expect</span><span class="token punctuation">(</span><span class="token string">"Failed to open hello.txt"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li>传播错误<br><strong>传播（propagating）错误</strong>：当编写一个其实先会调用一些可能会失败的操作的函数时，除了在这个函数中处理错误外，还可以选择让调用者知道这个错误并决定该如何处理。<pre class="line-numbers language-rust" data-language="rust"><code class="language-rust"><span class="token keyword">use</span> <span class="token namespace">std<span class="token punctuation">::</span>fs<span class="token punctuation">::</span></span><span class="token class-name">File</span><span class="token punctuation">;</span><span class="token keyword">use</span> <span class="token namespace">std<span class="token punctuation">::</span>io<span class="token punctuation">::</span></span><span class="token punctuation">{</span><span class="token keyword">self</span><span class="token punctuation">,</span> <span class="token class-name">Read</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token attribute attr-name">#![allow(unused)]</span><span class="token keyword">fn</span> <span class="token function-definition function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">fn</span> <span class="token function-definition function">read_username_from_file</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">-&gt;</span> <span class="token class-name">Result</span><span class="token operator">&lt;</span><span class="token class-name">String</span><span class="token punctuation">,</span> <span class="token namespace">io<span class="token punctuation">::</span></span><span class="token class-name">Error</span><span class="token operator">&gt;</span> <span class="token punctuation">{</span>        <span class="token keyword">let</span> f <span class="token operator">=</span> <span class="token class-name">File</span><span class="token punctuation">::</span><span class="token function">open</span><span class="token punctuation">(</span><span class="token string">"hello.txt"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">let</span> <span class="token keyword">mut</span> f <span class="token operator">=</span> <span class="token keyword">match</span> f <span class="token punctuation">{</span>            <span class="token class-name">Ok</span><span class="token punctuation">(</span>file<span class="token punctuation">)</span> <span class="token operator">=&gt;</span> file<span class="token punctuation">,</span>            <span class="token class-name">Err</span><span class="token punctuation">(</span>e<span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token keyword">return</span> <span class="token class-name">Err</span><span class="token punctuation">(</span>e<span class="token punctuation">)</span><span class="token punctuation">,</span>        <span class="token punctuation">}</span><span class="token punctuation">;</span>        <span class="token keyword">let</span> <span class="token keyword">mut</span> s <span class="token operator">=</span> <span class="token class-name">String</span><span class="token punctuation">::</span><span class="token function">new</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">match</span> f<span class="token punctuation">.</span><span class="token function">read_to_string</span><span class="token punctuation">(</span><span class="token operator">&amp;</span><span class="token keyword">mut</span> s<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token class-name">Ok</span><span class="token punctuation">(</span>_<span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token class-name">Ok</span><span class="token punctuation">(</span>s<span class="token punctuation">)</span><span class="token punctuation">,</span>            <span class="token class-name">Err</span><span class="token punctuation">(</span>e<span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token class-name">Err</span><span class="token punctuation">(</span>e<span class="token punctuation">)</span><span class="token punctuation">,</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token comment">// 传播错误的简写：? 运算符</span><span class="token keyword">fn</span> <span class="token function-definition function">read_username_from_file</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">-&gt;</span> <span class="token class-name">Result</span><span class="token operator">&lt;</span><span class="token class-name">String</span><span class="token punctuation">,</span> <span class="token namespace">io<span class="token punctuation">::</span></span><span class="token class-name">Error</span><span class="token operator">&gt;</span> <span class="token punctuation">{</span>    <span class="token keyword">let</span> <span class="token keyword">mut</span> f <span class="token operator">=</span> <span class="token class-name">File</span><span class="token punctuation">::</span><span class="token function">open</span><span class="token punctuation">(</span><span class="token string">"hello.txt"</span><span class="token punctuation">)</span><span class="token operator">?</span><span class="token punctuation">;</span>    <span class="token keyword">let</span> <span class="token keyword">mut</span> s <span class="token operator">=</span> <span class="token class-name">String</span><span class="token punctuation">::</span><span class="token function">new</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    f<span class="token punctuation">.</span><span class="token function">read_to_string</span><span class="token punctuation">(</span><span class="token operator">&amp;</span><span class="token keyword">mut</span> s<span class="token punctuation">)</span><span class="token operator">?</span><span class="token punctuation">;</span>    <span class="token class-name">Ok</span><span class="token punctuation">(</span>s<span class="token punctuation">)</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ol><h3 id="九、泛型、trait-与生命周期"><a href="#九、泛型、trait-与生命周期" class="headerlink" title="九、泛型、trait 与生命周期"></a>九、泛型、trait 与生命周期</h3><h4 id="9-1、泛型"><a href="#9-1、泛型" class="headerlink" title="9.1、泛型"></a>9.1、泛型</h4><p>我们可以使用泛型为像函数签名或结构体这样的项创建定义，这样它们就可以用于多种不同的具体数据类型。<br></p><pre class="line-numbers language-rust" data-language="rust"><code class="language-rust"><span class="token keyword">struct</span> <span class="token type-definition class-name">Point</span><span class="token operator">&lt;</span><span class="token constant">X1</span><span class="token punctuation">,</span> <span class="token constant">Y1</span><span class="token operator">&gt;</span> <span class="token punctuation">{</span>    x<span class="token punctuation">:</span> <span class="token constant">X1</span><span class="token punctuation">,</span>    y<span class="token punctuation">:</span> <span class="token constant">Y1</span><span class="token punctuation">,</span><span class="token punctuation">}</span><span class="token keyword">impl</span><span class="token operator">&lt;</span><span class="token constant">X1</span><span class="token punctuation">,</span> <span class="token constant">Y1</span><span class="token operator">&gt;</span> <span class="token class-name">Point</span><span class="token operator">&lt;</span><span class="token constant">X1</span><span class="token punctuation">,</span> <span class="token constant">Y1</span><span class="token operator">&gt;</span> <span class="token punctuation">{</span>    <span class="token keyword">fn</span> <span class="token function-definition function">mixup</span><span class="token operator">&lt;</span><span class="token constant">X2</span><span class="token punctuation">,</span> <span class="token constant">Y2</span><span class="token operator">&gt;</span><span class="token punctuation">(</span><span class="token keyword">self</span><span class="token punctuation">,</span> other<span class="token punctuation">:</span> <span class="token class-name">Point</span><span class="token operator">&lt;</span><span class="token constant">X2</span><span class="token punctuation">,</span> <span class="token constant">Y2</span><span class="token operator">&gt;</span><span class="token punctuation">)</span> <span class="token punctuation">-&gt;</span> <span class="token class-name">Point</span><span class="token operator">&lt;</span><span class="token constant">X1</span><span class="token punctuation">,</span> <span class="token constant">Y2</span><span class="token operator">&gt;</span> <span class="token punctuation">{</span>        <span class="token class-name">Point</span> <span class="token punctuation">{</span>            x<span class="token punctuation">:</span> <span class="token keyword">self</span><span class="token punctuation">.</span>x<span class="token punctuation">,</span>            y<span class="token punctuation">:</span> other<span class="token punctuation">.</span>y<span class="token punctuation">,</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">fn</span> <span class="token function-definition function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">let</span> p1 <span class="token operator">=</span> <span class="token class-name">Point</span> <span class="token punctuation">{</span> x<span class="token punctuation">:</span> <span class="token number">5</span><span class="token punctuation">,</span> y<span class="token punctuation">:</span> <span class="token number">10.4</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>    <span class="token keyword">let</span> p2 <span class="token operator">=</span> <span class="token class-name">Point</span> <span class="token punctuation">{</span> x<span class="token punctuation">:</span> <span class="token string">"Hello"</span><span class="token punctuation">,</span> y<span class="token punctuation">:</span> <span class="token char">'c'</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>    <span class="token keyword">let</span> p3 <span class="token operator">=</span> p1<span class="token punctuation">.</span><span class="token function">mixup</span><span class="token punctuation">(</span>p2<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token macro property">println!</span><span class="token punctuation">(</span><span class="token string">"p3.x = {}, p3.y = {}"</span><span class="token punctuation">,</span> p3<span class="token punctuation">.</span>x<span class="token punctuation">,</span> p3<span class="token punctuation">.</span>y<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p></p><h4 id="9-2、trait：定义共享的行为"><a href="#9-2、trait：定义共享的行为" class="headerlink" title="9.2、trait：定义共享的行为"></a>9.2、trait：定义共享的行为</h4><p><strong>trait</strong> 告诉 Rust 编译器某个特定类型拥有可能与其他类型共享的功能。可以通过 trait 以一种抽象的方式定义共享的行为。可以使用 trait bounds 指定泛型是任何拥有特定行为的类型。<br><strong><font color="red">注意</font></strong>：trait 类似于其他语言中的常被称为 接口（interfaces）的功能，虽然有一些不同。  </p><ol><li><strong>trait</strong> 的定义和实现</li></ol><ul><li><strong>trait 定义</strong>：是一种将方法签名组合起来的方法，目的是定义一个实现某些目的所必需的行为的集合。trait体中可以有多个方法：一行一个方法签名且都以分号结尾。<pre class="line-numbers language-rust" data-language="rust"><code class="language-rust"><span class="token keyword">pub</span> <span class="token keyword">trait</span> <span class="token type-definition class-name">Summary</span> <span class="token punctuation">{</span>    <span class="token keyword">fn</span> <span class="token function-definition function">summarize</span><span class="token punctuation">(</span><span class="token operator">&amp;</span><span class="token keyword">self</span><span class="token punctuation">)</span> <span class="token punctuation">-&gt;</span> <span class="token class-name">String</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre></li><li><strong>trait 实现</strong>：在类型上实现 trait 类似于实现与 trait 无关的方法。区别在于 impl 关键字之后，我们提供需要实现 trait 的名称，接着是 for 和需要实现 trait 的类型的名称。<pre class="line-numbers language-rust" data-language="rust"><code class="language-rust"><span class="token keyword">pub</span> <span class="token keyword">trait</span> <span class="token type-definition class-name">Summary</span> <span class="token punctuation">{</span>    <span class="token keyword">fn</span> <span class="token function-definition function">summarize</span><span class="token punctuation">(</span><span class="token operator">&amp;</span><span class="token keyword">self</span><span class="token punctuation">)</span> <span class="token punctuation">-&gt;</span> <span class="token class-name">String</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment">// 默认实现</span><span class="token comment">// pub trait Summary {</span><span class="token comment">//     fn summarize(&amp;self) -&gt; String {</span><span class="token comment">//         String::from("(Read more...)")</span><span class="token comment">//     }</span><span class="token comment">// }</span><span class="token keyword">pub</span> <span class="token keyword">struct</span> <span class="token type-definition class-name">NewsArticle</span> <span class="token punctuation">{</span>    <span class="token keyword">pub</span> headline<span class="token punctuation">:</span> <span class="token class-name">String</span><span class="token punctuation">,</span>    <span class="token keyword">pub</span> location<span class="token punctuation">:</span> <span class="token class-name">String</span><span class="token punctuation">,</span>    <span class="token keyword">pub</span> author<span class="token punctuation">:</span> <span class="token class-name">String</span><span class="token punctuation">,</span>    <span class="token keyword">pub</span> content<span class="token punctuation">:</span> <span class="token class-name">String</span><span class="token punctuation">,</span><span class="token punctuation">}</span><span class="token keyword">impl</span> <span class="token class-name">Summary</span> <span class="token keyword">for</span> <span class="token class-name">NewsArticle</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token keyword">pub</span> <span class="token keyword">struct</span> <span class="token type-definition class-name">Tweet</span> <span class="token punctuation">{</span>    <span class="token keyword">pub</span> username<span class="token punctuation">:</span> <span class="token class-name">String</span><span class="token punctuation">,</span>    <span class="token keyword">pub</span> content<span class="token punctuation">:</span> <span class="token class-name">String</span><span class="token punctuation">,</span>    <span class="token keyword">pub</span> reply<span class="token punctuation">:</span> <span class="token keyword">bool</span><span class="token punctuation">,</span>    <span class="token keyword">pub</span> retweet<span class="token punctuation">:</span> <span class="token keyword">bool</span><span class="token punctuation">,</span><span class="token punctuation">}</span><span class="token keyword">impl</span> <span class="token class-name">Summary</span> <span class="token keyword">for</span> <span class="token class-name">Tweet</span> <span class="token punctuation">{</span>    <span class="token keyword">fn</span> <span class="token function-definition function">summarize</span><span class="token punctuation">(</span><span class="token operator">&amp;</span><span class="token keyword">self</span><span class="token punctuation">)</span> <span class="token punctuation">-&gt;</span> <span class="token class-name">String</span> <span class="token punctuation">{</span>        <span class="token macro property">format!</span><span class="token punctuation">(</span><span class="token string">"{}: {}"</span><span class="token punctuation">,</span> <span class="token keyword">self</span><span class="token punctuation">.</span>username<span class="token punctuation">,</span> <span class="token keyword">self</span><span class="token punctuation">.</span>content<span class="token punctuation">)</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">pub</span> <span class="token keyword">struct</span> <span class="token type-definition class-name">NewsArticle</span> <span class="token punctuation">{</span>    <span class="token keyword">pub</span> headline<span class="token punctuation">:</span> <span class="token class-name">String</span><span class="token punctuation">,</span>    <span class="token keyword">pub</span> location<span class="token punctuation">:</span> <span class="token class-name">String</span><span class="token punctuation">,</span>    <span class="token keyword">pub</span> author<span class="token punctuation">:</span> <span class="token class-name">String</span><span class="token punctuation">,</span>    <span class="token keyword">pub</span> content<span class="token punctuation">:</span> <span class="token class-name">String</span><span class="token punctuation">,</span><span class="token punctuation">}</span><span class="token keyword">impl</span> <span class="token class-name">Summary</span> <span class="token keyword">for</span> <span class="token class-name">NewsArticle</span> <span class="token punctuation">{</span>    <span class="token keyword">fn</span> <span class="token function-definition function">summarize</span><span class="token punctuation">(</span><span class="token operator">&amp;</span><span class="token keyword">self</span><span class="token punctuation">)</span> <span class="token punctuation">-&gt;</span> <span class="token class-name">String</span> <span class="token punctuation">{</span>        <span class="token macro property">format!</span><span class="token punctuation">(</span><span class="token string">"{}, by {} ({})"</span><span class="token punctuation">,</span> <span class="token keyword">self</span><span class="token punctuation">.</span>headline<span class="token punctuation">,</span> <span class="token keyword">self</span><span class="token punctuation">.</span>author<span class="token punctuation">,</span> <span class="token keyword">self</span><span class="token punctuation">.</span>location<span class="token punctuation">)</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">pub</span> <span class="token keyword">struct</span> <span class="token type-definition class-name">Tweet</span> <span class="token punctuation">{</span>    <span class="token keyword">pub</span> username<span class="token punctuation">:</span> <span class="token class-name">String</span><span class="token punctuation">,</span>    <span class="token keyword">pub</span> content<span class="token punctuation">:</span> <span class="token class-name">String</span><span class="token punctuation">,</span>    <span class="token keyword">pub</span> reply<span class="token punctuation">:</span> <span class="token keyword">bool</span><span class="token punctuation">,</span>    <span class="token keyword">pub</span> retweet<span class="token punctuation">:</span> <span class="token keyword">bool</span><span class="token punctuation">,</span><span class="token punctuation">}</span><span class="token keyword">impl</span> <span class="token class-name">Summary</span> <span class="token keyword">for</span> <span class="token class-name">Tweet</span> <span class="token punctuation">{</span>    <span class="token keyword">fn</span> <span class="token function-definition function">summarize</span><span class="token punctuation">(</span><span class="token operator">&amp;</span><span class="token keyword">self</span><span class="token punctuation">)</span> <span class="token punctuation">-&gt;</span> <span class="token class-name">String</span> <span class="token punctuation">{</span>        <span class="token macro property">format!</span><span class="token punctuation">(</span><span class="token string">"{}: {}"</span><span class="token punctuation">,</span> <span class="token keyword">self</span><span class="token punctuation">.</span>username<span class="token punctuation">,</span> <span class="token keyword">self</span><span class="token punctuation">.</span>content<span class="token punctuation">)</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ul><ol><li><strong>trait</strong> 作为参数<pre class="line-numbers language-rust" data-language="rust"><code class="language-rust"><span class="token keyword">pub</span> <span class="token keyword">fn</span> <span class="token function-definition function">notify</span><span class="token punctuation">(</span>item<span class="token punctuation">:</span> <span class="token operator">&amp;</span><span class="token keyword">impl</span> <span class="token class-name">Summary</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token macro property">println!</span><span class="token punctuation">(</span><span class="token string">"Breaking news! {}"</span><span class="token punctuation">,</span> item<span class="token punctuation">.</span><span class="token function">summarize</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment">// Trait Bound 语法</span><span class="token keyword">pub</span> <span class="token keyword">fn</span> <span class="token function-definition function">notify</span><span class="token operator">&lt;</span><span class="token class-name">T</span><span class="token punctuation">:</span> <span class="token class-name">Summary</span><span class="token operator">&gt;</span><span class="token punctuation">(</span>item<span class="token punctuation">:</span> <span class="token operator">&amp;</span><span class="token class-name">T</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token macro property">println!</span><span class="token punctuation">(</span><span class="token string">"Breaking news! {}"</span><span class="token punctuation">,</span> item<span class="token punctuation">.</span><span class="token function">summarize</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment">// 通过 + 指定多个 trait bound</span><span class="token keyword">pub</span> <span class="token keyword">fn</span> <span class="token function-definition function">notify</span><span class="token punctuation">(</span>item<span class="token punctuation">:</span> <span class="token operator">&amp;</span><span class="token punctuation">(</span><span class="token keyword">impl</span> <span class="token class-name">Summary</span> <span class="token operator">+</span> <span class="token class-name">Display</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token keyword">pub</span> <span class="token keyword">fn</span> <span class="token function-definition function">notify</span><span class="token operator">&lt;</span><span class="token class-name">T</span><span class="token punctuation">:</span> <span class="token class-name">Summary</span> <span class="token operator">+</span> <span class="token class-name">Display</span><span class="token operator">&gt;</span><span class="token punctuation">(</span>item<span class="token punctuation">:</span> <span class="token operator">&amp;</span><span class="token class-name">T</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token comment">// 通过 where 简化 trait bound</span><span class="token keyword">fn</span> <span class="token function-definition function">some_function</span><span class="token operator">&lt;</span><span class="token class-name">T</span><span class="token punctuation">:</span> <span class="token class-name">Display</span> <span class="token operator">+</span> <span class="token class-name">Clone</span><span class="token punctuation">,</span> <span class="token class-name">U</span><span class="token punctuation">:</span> <span class="token class-name">Clone</span> <span class="token operator">+</span> <span class="token class-name">Debug</span><span class="token operator">&gt;</span><span class="token punctuation">(</span>t<span class="token punctuation">:</span> <span class="token operator">&amp;</span><span class="token class-name">T</span><span class="token punctuation">,</span> u<span class="token punctuation">:</span> <span class="token operator">&amp;</span><span class="token class-name">U</span><span class="token punctuation">)</span> <span class="token punctuation">-&gt;</span> <span class="token keyword">i32</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token keyword">fn</span> <span class="token function-definition function">some_function</span><span class="token operator">&lt;</span><span class="token class-name">T</span><span class="token punctuation">,</span> <span class="token class-name">U</span><span class="token operator">&gt;</span><span class="token punctuation">(</span>t<span class="token punctuation">:</span> <span class="token operator">&amp;</span><span class="token class-name">T</span><span class="token punctuation">,</span> u<span class="token punctuation">:</span> <span class="token operator">&amp;</span><span class="token class-name">U</span><span class="token punctuation">)</span> <span class="token punctuation">-&gt;</span> <span class="token keyword">i32</span>    <span class="token keyword">where</span> <span class="token class-name">T</span><span class="token punctuation">:</span> <span class="token class-name">Display</span> <span class="token operator">+</span> <span class="token class-name">Clone</span><span class="token punctuation">,</span>          <span class="token class-name">U</span><span class="token punctuation">:</span> <span class="token class-name">Clone</span> <span class="token operator">+</span> <span class="token class-name">Debug</span><span class="token punctuation">{</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ol><h4 id="9-3、生命周期与引用有效性"><a href="#9-3、生命周期与引用有效性" class="headerlink" title="9.3、生命周期与引用有效性"></a>9.3、生命周期与引用有效性</h4><p><strong>生命周期（lifetime）</strong>：也就是引用保持有效的作用域。</p><ol><li><p><strong>悬垂引用</strong>：</p><pre class="line-numbers language-rust" data-language="rust"><code class="language-rust"><span class="token keyword">fn</span> <span class="token function-definition function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token punctuation">{</span>        <span class="token keyword">let</span> r<span class="token punctuation">;</span>        <span class="token punctuation">{</span>            <span class="token keyword">let</span> x <span class="token operator">=</span> <span class="token number">5</span><span class="token punctuation">;</span>            r <span class="token operator">=</span> <span class="token operator">&amp;</span>x<span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token macro property">println!</span><span class="token punctuation">(</span><span class="token string">"r: {}"</span><span class="token punctuation">,</span> r<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token comment">// 生命周期展示</span><span class="token keyword">fn</span> <span class="token function-definition function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token punctuation">{</span>        <span class="token keyword">let</span> r<span class="token punctuation">;</span>                <span class="token comment">// ---------+-- 'a</span>        <span class="token punctuation">{</span>                     <span class="token comment">//          |</span>            <span class="token keyword">let</span> x <span class="token operator">=</span> <span class="token number">5</span><span class="token punctuation">;</span>        <span class="token comment">// -+-- 'b  |</span>            r <span class="token operator">=</span> <span class="token operator">&amp;</span>x<span class="token punctuation">;</span>           <span class="token comment">//  |       |</span>        <span class="token punctuation">}</span>                     <span class="token comment">// -+       |</span>        <span class="token macro property">println!</span><span class="token punctuation">(</span><span class="token string">"r: {}"</span><span class="token punctuation">,</span> r<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//          |</span>    <span class="token punctuation">}</span>                         <span class="token comment">// ---------+</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>外部作用域声明了一个没有初值的变量 r，而内部作用域声明了一个初值为 5 的变量x。在内部作用域中，我们尝试将 r 的值设置为一个 x 的引用。接着在内部作用域结束后，尝试打印出 r 的值。这段代码不能编译因为 r 引用的值在尝试使用之前就离开了作用域。</p></li><li><p><strong>生命周期注解语法</strong><br><strong>生命周期注解</strong>：一个不太常见的语法：生命周期参数名称必须以撇号（<strong>‘</strong>）开头，其名称通常全是小写，类似于泛型其名称非常短。<strong>‘a</strong> 是大多数人默认使用的名称。生命周期参数注解位于引用的 &amp; 之后，并有一个<strong>空格</strong>来将引用类型与生命周期注解分隔开。</p><pre class="line-numbers language-rust" data-language="rust"><code class="language-rust"><span class="token operator">&amp;</span><span class="token keyword">i32</span>        <span class="token comment">// 引用</span><span class="token operator">&amp;</span><span class="token lifetime-annotation symbol">'a</span> <span class="token keyword">i32</span>     <span class="token comment">// 带有显式生命周期的引用</span><span class="token operator">&amp;</span><span class="token lifetime-annotation symbol">'a</span> <span class="token keyword">mut</span> <span class="token keyword">i32</span> <span class="token comment">// 带有显式生命周期的可变引用</span><span class="token comment">// 函数中的使用</span><span class="token keyword">fn</span> <span class="token function-definition function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">let</span> string1 <span class="token operator">=</span> <span class="token class-name">String</span><span class="token punctuation">::</span><span class="token function">from</span><span class="token punctuation">(</span><span class="token string">"abcd"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">let</span> string2 <span class="token operator">=</span> <span class="token string">"xyz"</span><span class="token punctuation">;</span>    <span class="token keyword">let</span> result <span class="token operator">=</span> <span class="token function">longest</span><span class="token punctuation">(</span>string1<span class="token punctuation">.</span><span class="token function">as_str</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> string2<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token macro property">println!</span><span class="token punctuation">(</span><span class="token string">"The longest string is {}"</span><span class="token punctuation">,</span> result<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment">// 现在函数签名表明对于某些生命周期 'a，函数会获取两个参数，他们都是与生命周期 'a 存在的一样长的字符串 slice。</span><span class="token keyword">fn</span> <span class="token function-definition function">longest</span><span class="token operator">&lt;</span><span class="token lifetime-annotation symbol">'a</span><span class="token operator">&gt;</span><span class="token punctuation">(</span>x<span class="token punctuation">:</span> <span class="token operator">&amp;</span><span class="token lifetime-annotation symbol">'a</span> <span class="token keyword">str</span><span class="token punctuation">,</span> y<span class="token punctuation">:</span> <span class="token operator">&amp;</span><span class="token lifetime-annotation symbol">'a</span> <span class="token keyword">str</span><span class="token punctuation">)</span> <span class="token punctuation">-&gt;</span> <span class="token operator">&amp;</span><span class="token lifetime-annotation symbol">'a</span> <span class="token keyword">str</span> <span class="token punctuation">{</span>    <span class="token keyword">if</span> x<span class="token punctuation">.</span><span class="token function">len</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&gt;</span> y<span class="token punctuation">.</span><span class="token function">len</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        x    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>        y    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p><strong>生命周期省略（Lifetime Elision）</strong></p></li></ol><ul><li><strong>生命周期省略（Lifetime Elision）</strong>：针对一些可预测的并且遵循几个明确的模式的场景，Rust 团队就把这些模式编码进了 Rust 编译器中，如此借用检查器在这些情况下就能推断出生命周期而不再强制程序员显式的增加注解。</li><li><strong>输入生命周期（input lifetimes）</strong>：函数或方法的参数的生命周期。</li><li><strong>输出生命周期（output lifetimes）</strong>：返回值的生命周期。</li><li><strong>生命周期省略规则（lifetime elision rules）</strong>：即编码进 Rust 引用分析的模式。这并不是需要程序员遵守的规则；这些规则是一系列特定的场景，此时编译器会考虑，如果代码符合这些场景，就无需明确指定生命周期。省略规则适用于 fn 定义，以及 impl 块。<ul><li>规则一：每一个是引用的参数都有它自己的生命周期参数。换句话说就是，有一个引用参数的函数有一个生命周期参数：fn foo&lt;’a&gt;(x: &amp;’a i32)，有两个引用参数的函数有两个不同的生命周期参数，fn foo&lt;’a, ‘b&gt;(x: &amp;’a i32, y: &amp;’b i32)，依此类推。</li><li>规则二：如果只有一个输入生命周期参数，那么它被赋予所有输出生命周期参数：fn foo&lt;’a&gt;(x: &amp;’a i32) -&gt; &amp;’a i32。</li><li>规则三：如果方法有多个输入生命周期参数并且其中一个参数是 &amp;self 或 &amp;mut self，说明是个对象的方法(method), 那么所有输出生命周期参数被赋予 self 的生命周期。</li></ul></li></ul><ol><li><p><strong>静态生命周期</strong><br>这里有一种特殊的生命周期值得讨论：<strong>‘static</strong>，其生命周期能够存活于整个程序期间。所有的字符串字面值都拥有 ‘static 生命周期，我们也可以选择像下面这样标注出来：</p><pre class="line-numbers language-rust" data-language="rust"><code class="language-rust"><span class="token attribute attr-name">#![allow(unused)]</span><span class="token keyword">fn</span> <span class="token function-definition function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token keyword">let</span> s<span class="token punctuation">:</span> <span class="token operator">&amp;</span><span class="token lifetime-annotation symbol">'static</span> <span class="token keyword">str</span> <span class="token operator">=</span> <span class="token string">"I have a static lifetime."</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>结合泛型类型参数、trait bounds 和生命周期</p><pre class="line-numbers language-rust" data-language="rust"><code class="language-rust"><span class="token keyword">fn</span> <span class="token function-definition function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">let</span> string1 <span class="token operator">=</span> <span class="token class-name">String</span><span class="token punctuation">::</span><span class="token function">from</span><span class="token punctuation">(</span><span class="token string">"abcd"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">let</span> string2 <span class="token operator">=</span> <span class="token string">"xyz"</span><span class="token punctuation">;</span>    <span class="token keyword">let</span> result <span class="token operator">=</span> <span class="token function">longest_with_an_announcement</span><span class="token punctuation">(</span>        string1<span class="token punctuation">.</span><span class="token function">as_str</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>        string2<span class="token punctuation">,</span>        <span class="token string">"Today is someone's birthday!"</span><span class="token punctuation">,</span>    <span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token macro property">println!</span><span class="token punctuation">(</span><span class="token string">"The longest string is {}"</span><span class="token punctuation">,</span> result<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">use</span> <span class="token namespace">std<span class="token punctuation">::</span>fmt<span class="token punctuation">::</span></span><span class="token class-name">Display</span><span class="token punctuation">;</span><span class="token keyword">fn</span> <span class="token function-definition function">longest_with_an_announcement</span><span class="token operator">&lt;</span><span class="token lifetime-annotation symbol">'a</span><span class="token punctuation">,</span> <span class="token class-name">T</span><span class="token operator">&gt;</span><span class="token punctuation">(</span>    x<span class="token punctuation">:</span> <span class="token operator">&amp;</span><span class="token lifetime-annotation symbol">'a</span> <span class="token keyword">str</span><span class="token punctuation">,</span>    y<span class="token punctuation">:</span> <span class="token operator">&amp;</span><span class="token lifetime-annotation symbol">'a</span> <span class="token keyword">str</span><span class="token punctuation">,</span>    ann<span class="token punctuation">:</span> <span class="token class-name">T</span><span class="token punctuation">,</span><span class="token punctuation">)</span> <span class="token punctuation">-&gt;</span> <span class="token operator">&amp;</span><span class="token lifetime-annotation symbol">'a</span> <span class="token keyword">str</span><span class="token keyword">where</span>    <span class="token class-name">T</span><span class="token punctuation">:</span> <span class="token class-name">Display</span><span class="token punctuation">,</span><span class="token punctuation">{</span>    <span class="token macro property">println!</span><span class="token punctuation">(</span><span class="token string">"Announcement! {}"</span><span class="token punctuation">,</span> ann<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> x<span class="token punctuation">.</span><span class="token function">len</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&gt;</span> y<span class="token punctuation">.</span><span class="token function">len</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        x    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>        y    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ol><h3 id="十、Rust-中的函数式语言功能"><a href="#十、Rust-中的函数式语言功能" class="headerlink" title="十、Rust 中的函数式语言功能"></a>十、Rust 中的函数式语言功能</h3><p>Rust 的设计灵感来源于很多现存的语言和技术。其中一个显著的影响就是 <strong>函数式编程（functional programming）</strong>。函数式编程风格通常包含将函数作为参数值或其他函数的返回值、将函数赋值给变量以供之后执行等等。</p><ul><li><strong>闭包（Closures）</strong>：一个可以储存在变量里的类似函数的结构。</li><li><strong>迭代器（Iterators）</strong>：一种处理元素序列的方式。</li></ul><h4 id="10-1、闭包（Closures）"><a href="#10-1、闭包（Closures）" class="headerlink" title="10.1、闭包（Closures）"></a>10.1、闭包（Closures）</h4><p>Rust 的 闭包（closures）是可以保存进变量或作为参数传递给其他函数的匿名函数。可以在一个地方创建闭包，然后在不同的上下文中执行闭包运算。不同于函数，闭包允许捕获调用者作用域中的值。</p><ol><li><p>闭包的定义</p><pre class="line-numbers language-rust" data-language="rust"><code class="language-rust"><span class="token comment">// 示例</span><span class="token keyword">fn</span> <span class="token function-definition function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">let</span> expensive_closure <span class="token operator">=</span> <span class="token closure-params"><span class="token closure-punctuation punctuation">|</span>num<span class="token closure-punctuation punctuation">|</span></span> <span class="token punctuation">{</span>        <span class="token macro property">println!</span><span class="token punctuation">(</span><span class="token string">"calculating slowly..."</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token namespace">thread<span class="token punctuation">::</span></span><span class="token function">sleep</span><span class="token punctuation">(</span><span class="token class-name">Duration</span><span class="token punctuation">::</span><span class="token function">from_secs</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        num    <span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment">// 类比函数和闭包的可允许规则</span><span class="token keyword">fn</span>  <span class="token function-definition function">add_one_v1</span>   <span class="token punctuation">(</span>x<span class="token punctuation">:</span> <span class="token keyword">u32</span><span class="token punctuation">)</span> <span class="token punctuation">-&gt;</span> <span class="token keyword">u32</span> <span class="token punctuation">{</span> x <span class="token operator">+</span> <span class="token number">1</span> <span class="token punctuation">}</span><span class="token keyword">let</span> add_one_v2 <span class="token operator">=</span> <span class="token closure-params"><span class="token closure-punctuation punctuation">|</span>x<span class="token punctuation">:</span> <span class="token keyword">u32</span><span class="token closure-punctuation punctuation">|</span></span> <span class="token punctuation">-&gt;</span> <span class="token keyword">u32</span> <span class="token punctuation">{</span> x <span class="token operator">+</span> <span class="token number">1</span> <span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">let</span> add_one_v3 <span class="token operator">=</span> <span class="token closure-params"><span class="token closure-punctuation punctuation">|</span>x<span class="token closure-punctuation punctuation">|</span></span>             <span class="token punctuation">{</span> x <span class="token operator">+</span> <span class="token number">1</span> <span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">let</span> add_one_v4 <span class="token operator">=</span> <span class="token closure-params"><span class="token closure-punctuation punctuation">|</span>x<span class="token closure-punctuation punctuation">|</span></span>               x <span class="token operator">+</span> <span class="token number">1</span>  <span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>规则</strong>：闭包定义是 expensive_closure 赋值的 <strong>=</strong> 之后的部分。闭包的定义以一对竖线（<strong>|</strong>）开始，在竖线中指定闭包的参数；之所以选择这个语法是因为它与 Smalltalk 和 Ruby 的闭包定义类似。这个闭包有一个参数 num；如果有多于一个参数，可以使用逗号分隔，比如 <strong>|param1, param2|</strong>。</p></li><li><p>闭包会捕获其环境<br>闭包还有另一个函数所没有的功能：他们可以捕获其环境并访问其被定义的作用域的变量。</p><pre class="line-numbers language-rust" data-language="rust"><code class="language-rust"><span class="token comment">// 这里，即便 x 并不是 equal_to_x 的一个参数，equal_to_x 闭包也被允许使用变量 x，因为它与 equal_to_x 定义于相同的作用域。</span><span class="token keyword">fn</span> <span class="token function-definition function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">let</span> x <span class="token operator">=</span> <span class="token number">4</span><span class="token punctuation">;</span>    <span class="token keyword">let</span> equal_to_x <span class="token operator">=</span> <span class="token closure-params"><span class="token closure-punctuation punctuation">|</span>z<span class="token closure-punctuation punctuation">|</span></span> z <span class="token operator">==</span> x<span class="token punctuation">;</span>    <span class="token keyword">let</span> y <span class="token operator">=</span> <span class="token number">4</span><span class="token punctuation">;</span>    <span class="token macro property">assert!</span><span class="token punctuation">(</span><span class="token function">equal_to_x</span><span class="token punctuation">(</span>y<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment">// 编译报错，编译器甚至会提示我们这只能用于闭包！</span><span class="token keyword">fn</span> <span class="token function-definition function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">let</span> x <span class="token operator">=</span> <span class="token number">4</span><span class="token punctuation">;</span>    <span class="token keyword">fn</span> <span class="token function-definition function">equal_to_x</span><span class="token punctuation">(</span>z<span class="token punctuation">:</span> <span class="token keyword">i32</span><span class="token punctuation">)</span> <span class="token punctuation">-&gt;</span> <span class="token keyword">bool</span> <span class="token punctuation">{</span>        z <span class="token operator">==</span> x    <span class="token punctuation">}</span>    <span class="token keyword">let</span> y <span class="token operator">=</span> <span class="token number">4</span><span class="token punctuation">;</span>    <span class="token macro property">assert!</span><span class="token punctuation">(</span><span class="token function">equal_to_x</span><span class="token punctuation">(</span>y<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>当闭包从环境中捕获一个值，闭包会在闭包体中储存这个值以供使用。这会使用内存并产生额外的开销，在更一般的场景中，当我们不需要闭包来捕获环境时，我们不希望产生这些开销。因为函数从未允许捕获环境，定义和使用函数也就从不会有这些额外开销。</p></li></ol><p>闭包可以通过三种方式捕获其环境，他们直接对应函数的三种获取参数的方式：<strong>获取所有权</strong>，<strong>可变借用</strong>和<strong>不可变借用</strong>。这三种捕获值的方式被编码为如下三个 Fn trait：</p><ul><li><strong>FnOnce</strong>： 消费从周围作用域捕获的变量，闭包周围的作用域被称为其 <strong>环境（environment）</strong>。为了消费捕获到的变量，闭包必须获取其所有权并在定义闭包时将其移动进闭包。其名称的 <strong>Once</strong> 部分代表了闭包不能多次获取相同变量的所有权的事实，所以它只能被调用一次。</li><li><strong>FnMut</strong>： 获取可变的借用值所以可以改变其环境。</li><li><strong>Fn</strong>： 从其环境获取不可变的借用值。</li></ul><h4 id="10-2、迭代器"><a href="#10-2、迭代器" class="headerlink" title="10.2、迭代器"></a>10.2、迭代器</h4><p><strong>迭代器模式</strong>：允许你对一个序列的项进行某些处理。<strong>迭代器（iterator）</strong> 负责遍历序列中的每一项和决定序列何时结束的逻辑。当使用迭代器时，我们无需重新实现这些逻辑。在 Rust 中，迭代器是 惰性的（lazy），这意味着在调用方法使用迭代器之前它都不会有效果。</p><h3 id="十一、智能指针"><a href="#十一、智能指针" class="headerlink" title="十一、智能指针"></a>十一、智能指针</h3><p><strong>指针 （pointer）</strong>：是一个包含内存地址的变量的通用概念。<br><strong>智能指针（smart pointers）</strong>：是一类数据结构，他们的表现类似指针，但是也拥有额外的元数据和功能。<br>在 Rust 中，普通引用和智能指针的一个额外的区别是引用是一类只借用数据的指针；相反，在大部分情况下，智能指针 <strong>拥有</strong> 他们指向的数据。如 <strong>String</strong> 和 <strong>Vec<t></t></strong> 。</p><h4 id="10-1、Deref-trait"><a href="#10-1、Deref-trait" class="headerlink" title="10.1、Deref trait"></a>10.1、Deref trait</h4><ol><li><p><strong>通过解引用运算符追踪指针的值</strong><br>实现 <strong>Deref trait</strong> 允许我们重载 <strong>解引用运算符（dereference operator）*</strong>（与乘法运算符或通配符相区别）。通过这种方式实现 Deref trait 的智能指针可以被当作常规引用来对待，可以编写操作引用的代码并用于智能指针。</p><pre class="line-numbers language-rust" data-language="rust"><code class="language-rust"><span class="token keyword">fn</span> <span class="token function-definition function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">let</span> x <span class="token operator">=</span> <span class="token number">5</span><span class="token punctuation">;</span>    <span class="token keyword">let</span> y <span class="token operator">=</span> <span class="token operator">&amp;</span>x<span class="token punctuation">;</span>    <span class="token macro property">assert_eq!</span><span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">,</span> x<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token macro property">assert_eq!</span><span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">,</span> <span class="token operator">*</span>y<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//编译通过</span>    <span class="token macro property">assert_eq!</span><span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">,</span> y<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//编译异常  </span>    <span class="token comment">// assert_eq!(5, y);</span>    <span class="token comment">// ^^^^^^^^^^^^^^^^ no implementation for `{integer} == &amp;{integer}`</span>     <span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p><strong>通过实现 Deref trait 将某类型像引用一样处理</strong><br>为了实现 trait，需要提供 trait 所需的方法实现。<strong>Deref trait</strong> 由标准库提供，要求实现名为 deref 的方法，其借用 self 并返回一个内部数据的引用。</p><pre class="line-numbers language-rust" data-language="rust"><code class="language-rust"><span class="token keyword">use</span> <span class="token namespace">std<span class="token punctuation">::</span>ops<span class="token punctuation">::</span></span><span class="token class-name">Deref</span><span class="token punctuation">;</span><span class="token keyword">impl</span><span class="token operator">&lt;</span><span class="token class-name">T</span><span class="token operator">&gt;</span> <span class="token class-name">Deref</span> <span class="token keyword">for</span> <span class="token class-name">MyBox</span><span class="token operator">&lt;</span><span class="token class-name">T</span><span class="token operator">&gt;</span> <span class="token punctuation">{</span>    <span class="token comment">// 语法定义了用于此 trait 的关联类型。关联类型是一个稍有不同的定义泛型参数的方式，</span>    <span class="token keyword">type</span> <span class="token type-definition class-name">Target</span> <span class="token operator">=</span> <span class="token class-name">T</span><span class="token punctuation">;</span>    <span class="token keyword">fn</span> <span class="token function-definition function">deref</span><span class="token punctuation">(</span><span class="token operator">&amp;</span><span class="token keyword">self</span><span class="token punctuation">)</span> <span class="token punctuation">-&gt;</span> <span class="token operator">&amp;</span><span class="token keyword">Self</span><span class="token punctuation">::</span><span class="token class-name">Target</span> <span class="token punctuation">{</span>        <span class="token operator">&amp;</span><span class="token keyword">self</span><span class="token punctuation">.</span><span class="token number">0</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>没有 Deref trait 的话，*只会解引用 &amp; 引用类型。deref 方法向编译器提供了获取任何实现了 Deref trait 的类型的值，并且调用这个类型的 deref 方法来获取一个它知道如何解引用的 &amp; 引用的能力。</p><pre class="line-numbers language-rust" data-language="rust"><code class="language-rust"><span class="token keyword">fn</span> <span class="token function-definition function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">let</span> x <span class="token operator">=</span> <span class="token number">5</span><span class="token punctuation">;</span>    <span class="token keyword">let</span> y <span class="token operator">=</span> <span class="token class-name">MyBox</span><span class="token punctuation">::</span><span class="token function">new</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token macro property">assert_eq!</span><span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">,</span> x<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token macro property">assert_eq!</span><span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">,</span> <span class="token operator">*</span>y<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//*y 等价于： *(y.deref())</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p><strong>函数和方法的隐式 Deref 强制转换</strong><br><strong>Deref 强制转换（deref coercions）：</strong> 是 Rust 在函数或方法传参上的一种便利。Deref 强制转换只能作用于实现了 Deref trait 的类型。</p><pre class="line-numbers language-rust" data-language="rust"><code class="language-rust"><span class="token keyword">fn</span> <span class="token function-definition function">hello</span><span class="token punctuation">(</span>name<span class="token punctuation">:</span> <span class="token operator">&amp;</span><span class="token keyword">str</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token macro property">println!</span><span class="token punctuation">(</span><span class="token string">"Hello, {}!"</span><span class="token punctuation">,</span> name<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">fn</span> <span class="token function-definition function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">let</span> m <span class="token operator">=</span> <span class="token class-name">MyBox</span><span class="token punctuation">::</span><span class="token function">new</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">::</span><span class="token function">from</span><span class="token punctuation">(</span><span class="token string">"Rust"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// 隐式强制转换</span>    <span class="token function">hello</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>m<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// 如果没有隐式强制转换</span>    <span class="token comment">// hello(&amp;(*m)[..]);</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>&amp;m</strong> 调用 hello 函数过程：    </p></li></ol><ul><li>m 为 MyBox<string> 值的引用，在 MyBox<t> 上实现了 Deref trait，Rust 可以通过 deref 调用将 &amp;MyBox<string> 变为 &amp;String。</string></t></string></li><li>标准库中提供了 String 上的 Deref 实现，其会返回字符串 slice，这可以在 Deref 的 API 文档中看到。Rust 再次调用 deref 将 &amp;String 变为 &amp;str，这就符合 hello 函数的定义了。</li></ul><h4 id="10-2、Drop-trait清理代码"><a href="#10-2、Drop-trait清理代码" class="headerlink" title="10.2、Drop trait清理代码"></a>10.2、Drop trait清理代码</h4><p><strong>Drop trait：</strong> 指定在值离开作用域时应该执行的代码的方式是实现。<br><strong>Drop trait：</strong> 要求实现一个叫做 drop 的方法，它获取一个 self 的可变引用。</p><ol><li><p>实现<strong>Drop trait</strong>来清理代码</p><pre class="line-numbers language-rust" data-language="rust"><code class="language-rust"><span class="token keyword">struct</span> <span class="token type-definition class-name">CustomSmartPointer</span> <span class="token punctuation">{</span>    data<span class="token punctuation">:</span> <span class="token class-name">String</span><span class="token punctuation">,</span><span class="token punctuation">}</span><span class="token keyword">impl</span> <span class="token class-name">Drop</span> <span class="token keyword">for</span> <span class="token class-name">CustomSmartPointer</span> <span class="token punctuation">{</span>    <span class="token keyword">fn</span> <span class="token function-definition function">drop</span><span class="token punctuation">(</span><span class="token operator">&amp;</span><span class="token keyword">mut</span> <span class="token keyword">self</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token macro property">println!</span><span class="token punctuation">(</span><span class="token string">"Dropping CustomSmartPointer with data `{}`!"</span><span class="token punctuation">,</span> <span class="token keyword">self</span><span class="token punctuation">.</span>data<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">fn</span> <span class="token function-definition function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">let</span> c <span class="token operator">=</span> <span class="token class-name">CustomSmartPointer</span> <span class="token punctuation">{</span>        data<span class="token punctuation">:</span> <span class="token class-name">String</span><span class="token punctuation">::</span><span class="token function">from</span><span class="token punctuation">(</span><span class="token string">"my stuff"</span><span class="token punctuation">)</span><span class="token punctuation">,</span>    <span class="token punctuation">}</span><span class="token punctuation">;</span>    <span class="token keyword">let</span> d <span class="token operator">=</span> <span class="token class-name">CustomSmartPointer</span> <span class="token punctuation">{</span>        data<span class="token punctuation">:</span> <span class="token class-name">String</span><span class="token punctuation">::</span><span class="token function">from</span><span class="token punctuation">(</span><span class="token string">"other stuff"</span><span class="token punctuation">)</span><span class="token punctuation">,</span>    <span class="token punctuation">}</span><span class="token punctuation">;</span>    <span class="token macro property">println!</span><span class="token punctuation">(</span><span class="token string">"CustomSmartPointers created."</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment">// 运行结果：</span><span class="token comment">// $ cargo run。。。</span><span class="token comment">// CustomSmartPointers created.</span><span class="token comment">// Dropping CustomSmartPointer with data `other stuff`!</span><span class="token comment">// Dropping CustomSmartPointer with data `my stuff`!</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>变量以被创建时相反的顺序被丢弃，所以 d 在 c 之前被丢弃</p></li><li><p>通过 <strong>std::mem::drop</strong> 提早丢弃值</p><pre class="line-numbers language-rust" data-language="rust"><code class="language-rust"><span class="token keyword">fn</span> <span class="token function-definition function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">let</span> c <span class="token operator">=</span> <span class="token class-name">CustomSmartPointer</span> <span class="token punctuation">{</span>        data<span class="token punctuation">:</span> <span class="token class-name">String</span><span class="token punctuation">::</span><span class="token function">from</span><span class="token punctuation">(</span><span class="token string">"some data"</span><span class="token punctuation">)</span><span class="token punctuation">,</span>    <span class="token punctuation">}</span><span class="token punctuation">;</span>    <span class="token macro property">println!</span><span class="token punctuation">(</span><span class="token string">"CustomSmartPointer created."</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">drop</span><span class="token punctuation">(</span>c<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token macro property">println!</span><span class="token punctuation">(</span><span class="token string">"CustomSmartPointer dropped before the end of main."</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment">// 运行结果：</span><span class="token comment">// $ cargo run。。。</span><span class="token comment">// CustomSmartPointer created.</span><span class="token comment">// Dropping CustomSmartPointer with data `some data`!</span><span class="token comment">// CustomSmartPointer dropped before the end of main.</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ol><h4 id="10-3、Rc-引用计数智能指针"><a href="#10-3、Rc-引用计数智能指针" class="headerlink" title="10.3、Rc\ 引用计数智能指针"></a>10.3、Rc\<t> 引用计数智能指针</t></h4><p><strong>Rc\<t></t></strong> ：为 <strong>引用计数（reference counting）</strong> 的缩写。引用计数意味着记录一个值引用的数量来知晓这个值是否仍在被使用。如果某个值有零个引用，就代表没有任何有效引用并可以被清理。<br><strong>Rc\<t></t></strong>: 允许在程序的多个部分之间只读地共享数据。如果 Rc 也允许多个可变引用，则会违反借用规则之一：相同位置的多个可变借用可能造成数据竞争和不一致。  </p><p><font size="5%">总结其特性：</font></p><ul><li>使用 <strong>Rc\<t></t></strong> 共享数据</li><li>克隆 <strong>Rc\<t></t></strong> 会增加引用计数</li><li><strong>Rc\<t></t></strong> 只能用于单线程场景。多线程场景需要使用Arc\<t>（原子引用计数（atomically reference counted）类型）。</t></li><li>通过 <strong>Rc\<t></t></strong> 获取的引用为不可变引用</li></ul><pre class="line-numbers language-rust" data-language="rust"><code class="language-rust"><span class="token keyword">enum</span> <span class="token type-definition class-name">List</span> <span class="token punctuation">{</span>    <span class="token class-name">Cons</span><span class="token punctuation">(</span><span class="token keyword">i32</span><span class="token punctuation">,</span> <span class="token class-name">Box</span><span class="token operator">&lt;</span><span class="token class-name">List</span><span class="token operator">&gt;</span><span class="token punctuation">)</span><span class="token punctuation">,</span>    <span class="token class-name">Nil</span><span class="token punctuation">,</span><span class="token punctuation">}</span><span class="token keyword">use</span> <span class="token keyword">crate</span><span class="token punctuation">::</span><span class="token class-name">List</span><span class="token punctuation">::</span><span class="token punctuation">{</span><span class="token class-name">Cons</span><span class="token punctuation">,</span> <span class="token class-name">Nil</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">fn</span> <span class="token function-definition function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">let</span> a <span class="token operator">=</span> <span class="token class-name">Cons</span><span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">,</span> <span class="token class-name">Box</span><span class="token punctuation">::</span><span class="token function">new</span><span class="token punctuation">(</span><span class="token class-name">Cons</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">,</span> <span class="token class-name">Box</span><span class="token punctuation">::</span><span class="token function">new</span><span class="token punctuation">(</span><span class="token class-name">Nil</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">let</span> b <span class="token operator">=</span> <span class="token class-name">Cons</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">,</span> <span class="token class-name">Box</span><span class="token punctuation">::</span><span class="token function">new</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">let</span> c <span class="token operator">=</span> <span class="token class-name">Cons</span><span class="token punctuation">(</span><span class="token number">4</span><span class="token punctuation">,</span> <span class="token class-name">Box</span><span class="token punctuation">::</span><span class="token function">new</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment">// 运行结果</span><span class="token comment">// error[E0382]: use of moved value: `a`</span><span class="token comment">//   --&gt; src/main.rs:11:30</span><span class="token comment">//    |</span><span class="token comment">// 9  |     let a = Cons(5, Box::new(Cons(10, Box::new(Nil))));</span><span class="token comment">//    |         - move occurs because `a` has type `List`, which does not implement the `Copy` trait</span><span class="token comment">// 10 |     let b = Cons(3, Box::new(a));</span><span class="token comment">//    |                              - value moved here</span><span class="token comment">// 11 |     let c = Cons(4, Box::new(a));</span><span class="token comment">//    |                              ^ value used here after move</span><span class="token comment">// For more information about this error, try `rustc --explain E0382`.</span><span class="token comment">// error: could not compile `cons-list` due to previous error</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>Cons 成员拥有其储存的数据，所以当创建 b 列表时，a 被移动进了 b 这样 b 就拥有了 a。接着当再次尝试使用 a 创建 c 时，这不被允许，因为 a 的所有权已经被移动。<br>此种情况下，必须实现 <strong>a</strong> 同时被 <strong>b</strong> 和 <strong>c</strong> 引用。则可以使用 Rc<t> 代替 Box<t>。如下：<br></t></t></p><pre class="line-numbers language-rust" data-language="rust"><code class="language-rust"><span class="token keyword">enum</span> <span class="token type-definition class-name">List</span> <span class="token punctuation">{</span>    <span class="token class-name">Cons</span><span class="token punctuation">(</span><span class="token keyword">i32</span><span class="token punctuation">,</span> <span class="token class-name">Rc</span><span class="token operator">&lt;</span><span class="token class-name">List</span><span class="token operator">&gt;</span><span class="token punctuation">)</span><span class="token punctuation">,</span>    <span class="token class-name">Nil</span><span class="token punctuation">,</span><span class="token punctuation">}</span><span class="token keyword">use</span> <span class="token keyword">crate</span><span class="token punctuation">::</span><span class="token class-name">List</span><span class="token punctuation">::</span><span class="token punctuation">{</span><span class="token class-name">Cons</span><span class="token punctuation">,</span> <span class="token class-name">Nil</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">use</span> <span class="token namespace">std<span class="token punctuation">::</span>rc<span class="token punctuation">::</span></span><span class="token class-name">Rc</span><span class="token punctuation">;</span><span class="token keyword">fn</span> <span class="token function-definition function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">let</span> a <span class="token operator">=</span> <span class="token class-name">Rc</span><span class="token punctuation">::</span><span class="token function">new</span><span class="token punctuation">(</span><span class="token class-name">Cons</span><span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">,</span> <span class="token class-name">Rc</span><span class="token punctuation">::</span><span class="token function">new</span><span class="token punctuation">(</span><span class="token class-name">Cons</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">,</span> <span class="token class-name">Rc</span><span class="token punctuation">::</span><span class="token function">new</span><span class="token punctuation">(</span><span class="token class-name">Nil</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">let</span> b <span class="token operator">=</span> <span class="token class-name">Cons</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">,</span> <span class="token class-name">Rc</span><span class="token punctuation">::</span><span class="token function">clone</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>a<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">let</span> c <span class="token operator">=</span> <span class="token class-name">Cons</span><span class="token punctuation">(</span><span class="token number">4</span><span class="token punctuation">,</span> <span class="token class-name">Rc</span><span class="token punctuation">::</span><span class="token function">clone</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>a<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><br>现在每一个 Cons 变量都包含一个值和一个指向 List 的 Rc<t>。当创建 b 时，不同于获取 a 的所有权，这里会克隆 a 所包含的 Rc<list>，这会将引用计数从 1 增加到 2 并允许 a 和 b 共享 Rc<list> 中数据的所有权。创建 c 时也会克隆 a，这会将引用计数从 2 增加为 3。每次调用 Rc::clone，Rc<list> 中数据的引用计数都会增加，直到有零个引用之前其数据都不会被清理。<p></p><h4 id="10-4、RefCell-和内部可变性模式"><a href="#10-4、RefCell-和内部可变性模式" class="headerlink" title="10.4、RefCell\ 和内部可变性模式"></a>10.4、RefCell\<t> 和内部可变性模式</t></h4><p><strong>内部可变性（Interior mutability）</strong> ：是 Rust 中的一个设计模式，它允许你即使在有不可变引用时也可以改变数据，即：<strong>在不可变值内部改变值</strong>。这通常是借用规则所不允许的。该模式在数据结构中使用 unsafe 代码来模糊 Rust 通常的可变性和借用规则。当可以确保代码在运行时会遵守借用规则，即使编译器不能保证的情况，可以选择使用那些运用内部可变性模式的类型。所涉及的 unsafe 代码将被封装进安全的 API 中，而外部类型仍然是不可变的。</p><ol><li><strong>RefCell\<t></t></strong><br><strong>RefCell\<t></t></strong>：就是内部可变性模式的实现类型之一。与 <strong>Rc\<t></t></strong> 不同的事，它具备数据的唯一所有权。  </li></ol><p>如下为选择 Box<t>，Rc<t> 或 RefCell<t> 的理由：</t></t></t></p><ul><li>Rc<t> 允许相同数据有多个所有者；Box<t> 和 RefCell<t> 有单一所有者。</t></t></t></li><li>Box<t> 允许在编译时执行不可变或可变借用检查；Rc<t>仅允许在编译时执行不可变借用检查；<em> </em> RefCell<t> 允许在运行时执行不可变或可变借用检查。</t></t></t></li><li>因为 RefCell<t> 允许在运行时执行可变借用检查，所以我们可以在即便 RefCell<t> 自身是不可变的情况下修改其内部的值。</t></t></li></ul><pre class="line-numbers language-rust" data-language="rust"><code class="language-rust"><span class="token keyword">pub</span> <span class="token keyword">trait</span> <span class="token type-definition class-name">Messenger</span> <span class="token punctuation">{</span>    <span class="token keyword">fn</span> <span class="token function-definition function">send</span><span class="token punctuation">(</span><span class="token operator">&amp;</span><span class="token keyword">self</span><span class="token punctuation">,</span> msg<span class="token punctuation">:</span> <span class="token operator">&amp;</span><span class="token keyword">str</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">pub</span> <span class="token keyword">struct</span> <span class="token type-definition class-name">LimitTracker</span><span class="token operator">&lt;</span><span class="token lifetime-annotation symbol">'a</span><span class="token punctuation">,</span> <span class="token class-name">T</span><span class="token punctuation">:</span> <span class="token class-name">Messenger</span><span class="token operator">&gt;</span> <span class="token punctuation">{</span>    messenger<span class="token punctuation">:</span> <span class="token operator">&amp;</span><span class="token lifetime-annotation symbol">'a</span> <span class="token class-name">T</span><span class="token punctuation">,</span>    value<span class="token punctuation">:</span> <span class="token keyword">usize</span><span class="token punctuation">,</span>    max<span class="token punctuation">:</span> <span class="token keyword">usize</span><span class="token punctuation">,</span><span class="token punctuation">}</span><span class="token keyword">impl</span><span class="token operator">&lt;</span><span class="token lifetime-annotation symbol">'a</span><span class="token punctuation">,</span> <span class="token class-name">T</span><span class="token operator">&gt;</span> <span class="token class-name">LimitTracker</span><span class="token operator">&lt;</span><span class="token lifetime-annotation symbol">'a</span><span class="token punctuation">,</span> <span class="token class-name">T</span><span class="token operator">&gt;</span><span class="token keyword">where</span>    <span class="token class-name">T</span><span class="token punctuation">:</span> <span class="token class-name">Messenger</span><span class="token punctuation">,</span><span class="token punctuation">{</span>    <span class="token keyword">pub</span> <span class="token keyword">fn</span> <span class="token function-definition function">new</span><span class="token punctuation">(</span>messenger<span class="token punctuation">:</span> <span class="token operator">&amp;</span><span class="token class-name">T</span><span class="token punctuation">,</span> max<span class="token punctuation">:</span> <span class="token keyword">usize</span><span class="token punctuation">)</span> <span class="token punctuation">-&gt;</span> <span class="token class-name">LimitTracker</span><span class="token operator">&lt;</span><span class="token class-name">T</span><span class="token operator">&gt;</span> <span class="token punctuation">{</span>        <span class="token class-name">LimitTracker</span> <span class="token punctuation">{</span>            messenger<span class="token punctuation">,</span>            value<span class="token punctuation">:</span> <span class="token number">0</span><span class="token punctuation">,</span>            max<span class="token punctuation">,</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token keyword">pub</span> <span class="token keyword">fn</span> <span class="token function-definition function">set_value</span><span class="token punctuation">(</span><span class="token operator">&amp;</span><span class="token keyword">mut</span> <span class="token keyword">self</span><span class="token punctuation">,</span> value<span class="token punctuation">:</span> <span class="token keyword">usize</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">self</span><span class="token punctuation">.</span>value <span class="token operator">=</span> value<span class="token punctuation">;</span>        <span class="token keyword">let</span> percentage_of_max <span class="token operator">=</span> <span class="token keyword">self</span><span class="token punctuation">.</span>value <span class="token keyword">as</span> <span class="token keyword">f64</span> <span class="token operator">/</span> <span class="token keyword">self</span><span class="token punctuation">.</span>max <span class="token keyword">as</span> <span class="token keyword">f64</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> percentage_of_max <span class="token operator">&gt;=</span> <span class="token number">1.0</span> <span class="token punctuation">{</span>            <span class="token keyword">self</span><span class="token punctuation">.</span>messenger<span class="token punctuation">.</span><span class="token function">send</span><span class="token punctuation">(</span><span class="token string">"Error: You are over your quota!"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> percentage_of_max <span class="token operator">&gt;=</span> <span class="token number">0.9</span> <span class="token punctuation">{</span>            <span class="token keyword">self</span><span class="token punctuation">.</span>messenger                <span class="token punctuation">.</span><span class="token function">send</span><span class="token punctuation">(</span><span class="token string">"Urgent warning: You've used up over 90% of your quota!"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> percentage_of_max <span class="token operator">&gt;=</span> <span class="token number">0.75</span> <span class="token punctuation">{</span>            <span class="token keyword">self</span><span class="token punctuation">.</span>messenger                <span class="token punctuation">.</span><span class="token function">send</span><span class="token punctuation">(</span><span class="token string">"Warning: You've used up over 75% of your quota!"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token attribute attr-name">#[cfg(test)]</span><span class="token keyword">mod</span> <span class="token module-declaration namespace">tests</span> <span class="token punctuation">{</span>    <span class="token keyword">use</span> <span class="token keyword">super</span><span class="token punctuation">::</span><span class="token operator">*</span><span class="token punctuation">;</span>    <span class="token keyword">use</span> <span class="token namespace">std<span class="token punctuation">::</span>cell<span class="token punctuation">::</span></span><span class="token class-name">RefCell</span><span class="token punctuation">;</span>    <span class="token keyword">struct</span> <span class="token type-definition class-name">MockMessenger</span> <span class="token punctuation">{</span>        sent_messages<span class="token punctuation">:</span> <span class="token class-name">RefCell</span><span class="token operator">&lt;</span><span class="token class-name">Vec</span><span class="token operator">&lt;</span><span class="token class-name">String</span><span class="token operator">&gt;&gt;</span><span class="token punctuation">,</span>    <span class="token punctuation">}</span>    <span class="token keyword">impl</span> <span class="token class-name">MockMessenger</span> <span class="token punctuation">{</span>        <span class="token keyword">fn</span> <span class="token function-definition function">new</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">-&gt;</span> <span class="token class-name">MockMessenger</span> <span class="token punctuation">{</span>            <span class="token class-name">MockMessenger</span> <span class="token punctuation">{</span>                sent_messages<span class="token punctuation">:</span> <span class="token class-name">RefCell</span><span class="token punctuation">::</span><span class="token function">new</span><span class="token punctuation">(</span><span class="token macro property">vec!</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">,</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token keyword">impl</span> <span class="token class-name">Messenger</span> <span class="token keyword">for</span> <span class="token class-name">MockMessenger</span> <span class="token punctuation">{</span>        <span class="token keyword">fn</span> <span class="token function-definition function">send</span><span class="token punctuation">(</span><span class="token operator">&amp;</span><span class="token keyword">self</span><span class="token punctuation">,</span> message<span class="token punctuation">:</span> <span class="token operator">&amp;</span><span class="token keyword">str</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">self</span><span class="token punctuation">.</span>sent_messages<span class="token punctuation">.</span><span class="token function">borrow_mut</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">::</span><span class="token function">from</span><span class="token punctuation">(</span>message<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token attribute attr-name">#[test]</span>    <span class="token keyword">fn</span> <span class="token function-definition function">it_sends_an_over_75_percent_warning_message</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment">// --snip--</span>        <span class="token keyword">let</span> mock_messenger <span class="token operator">=</span> <span class="token class-name">MockMessenger</span><span class="token punctuation">::</span><span class="token function">new</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">let</span> <span class="token keyword">mut</span> limit_tracker <span class="token operator">=</span> <span class="token class-name">LimitTracker</span><span class="token punctuation">::</span><span class="token function">new</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>mock_messenger<span class="token punctuation">,</span> <span class="token number">100</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        limit_tracker<span class="token punctuation">.</span><span class="token function">set_value</span><span class="token punctuation">(</span><span class="token number">80</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token macro property">assert_eq!</span><span class="token punctuation">(</span>mock_messenger<span class="token punctuation">.</span>sent_messages<span class="token punctuation">.</span><span class="token function">borrow</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">len</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>对于 send 方法的实现，第一个参数仍为 self 的不可变借用，这是符合方法定义的。我们调用 self.sent_messages 中 RefCell 的 borrow_mut 方法来获取 RefCell 中值的可变引用，这是一个 vector。接着可以对 vector 的可变引用调用 push 以便记录测试过程中看到的消息。</p><ol><li><strong>RefCell 在运行时记录借用</strong><br>当创建不可变和可变引用时，我们分别使用 &amp; 和 &amp;mut 语法。对于 RefCell<t> 来说，则是 <strong>borrow</strong> 和 <strong>borrow_mut</strong> 方法，这属于 RefCell<t> 安全 API 的一部分。</t></t></li></ol><ul><li>borrow：返回 <strong>Ref<t>（实现了 Deref）</t></strong>。每次调用 borrow，RefCell<t> 将活动的不可变借用计数加一。当 Ref<t> 值离开作用域时，不可变借用计数减一。</t></t></li><li>borrow_mut：方法返回 <strong>RefMut<t>（实现了 Deref）</t></strong>。RefCell<t> 在任何时候只允许有多个不可变借用或一个可变借用。</t></li></ul><ol><li>结合 Rc<t> 和 RefCell<t> 来拥有多个可变数据所有者<br>如果有一个储存了 RefCell<t> 的 Rc<t> 的话，就可以得到有多个所有者 并且 可以修改的值了！<pre class="line-numbers language-rust" data-language="rust"><code class="language-rust"><span class="token attribute attr-name">#[derive(Debug)]</span><span class="token keyword">enum</span> <span class="token type-definition class-name">List</span> <span class="token punctuation">{</span>    <span class="token class-name">Cons</span><span class="token punctuation">(</span><span class="token class-name">Rc</span><span class="token operator">&lt;</span><span class="token class-name">RefCell</span><span class="token operator">&lt;</span><span class="token keyword">i32</span><span class="token operator">&gt;&gt;</span><span class="token punctuation">,</span> <span class="token class-name">Rc</span><span class="token operator">&lt;</span><span class="token class-name">List</span><span class="token operator">&gt;</span><span class="token punctuation">)</span><span class="token punctuation">,</span>    <span class="token class-name">Nil</span><span class="token punctuation">,</span><span class="token punctuation">}</span><span class="token keyword">use</span> <span class="token keyword">crate</span><span class="token punctuation">::</span><span class="token class-name">List</span><span class="token punctuation">::</span><span class="token punctuation">{</span><span class="token class-name">Cons</span><span class="token punctuation">,</span> <span class="token class-name">Nil</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">use</span> <span class="token namespace">std<span class="token punctuation">::</span>cell<span class="token punctuation">::</span></span><span class="token class-name">RefCell</span><span class="token punctuation">;</span><span class="token keyword">use</span> <span class="token namespace">std<span class="token punctuation">::</span>rc<span class="token punctuation">::</span></span><span class="token class-name">Rc</span><span class="token punctuation">;</span><span class="token keyword">fn</span> <span class="token function-definition function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">let</span> value <span class="token operator">=</span> <span class="token class-name">Rc</span><span class="token punctuation">::</span><span class="token function">new</span><span class="token punctuation">(</span><span class="token class-name">RefCell</span><span class="token punctuation">::</span><span class="token function">new</span><span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">let</span> a <span class="token operator">=</span> <span class="token class-name">Rc</span><span class="token punctuation">::</span><span class="token function">new</span><span class="token punctuation">(</span><span class="token class-name">Cons</span><span class="token punctuation">(</span><span class="token class-name">Rc</span><span class="token punctuation">::</span><span class="token function">clone</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>value<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token class-name">Rc</span><span class="token punctuation">::</span><span class="token function">new</span><span class="token punctuation">(</span><span class="token class-name">Nil</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">let</span> b <span class="token operator">=</span> <span class="token class-name">Cons</span><span class="token punctuation">(</span><span class="token class-name">Rc</span><span class="token punctuation">::</span><span class="token function">new</span><span class="token punctuation">(</span><span class="token class-name">RefCell</span><span class="token punctuation">::</span><span class="token function">new</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token class-name">Rc</span><span class="token punctuation">::</span><span class="token function">clone</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>a<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">let</span> c <span class="token operator">=</span> <span class="token class-name">Cons</span><span class="token punctuation">(</span><span class="token class-name">Rc</span><span class="token punctuation">::</span><span class="token function">new</span><span class="token punctuation">(</span><span class="token class-name">RefCell</span><span class="token punctuation">::</span><span class="token function">new</span><span class="token punctuation">(</span><span class="token number">4</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token class-name">Rc</span><span class="token punctuation">::</span><span class="token function">clone</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>a<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token operator">*</span>value<span class="token punctuation">.</span><span class="token function">borrow_mut</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+=</span> <span class="token number">10</span><span class="token punctuation">;</span>    <span class="token macro property">println!</span><span class="token punctuation">(</span><span class="token string">"a after = {:?}"</span><span class="token punctuation">,</span> a<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token macro property">println!</span><span class="token punctuation">(</span><span class="token string">"b after = {:?}"</span><span class="token punctuation">,</span> b<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token macro property">println!</span><span class="token punctuation">(</span><span class="token string">"c after = {:?}"</span><span class="token punctuation">,</span> c<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></t></t></t></t></li></ol><h4 id="10-4、Weak"><a href="#10-4、Weak" class="headerlink" title="10.4、Weak\"></a>10.4、Weak\<t></t></h4><p><strong>Weak\<t></t></strong>：即 <strong>弱引用（weak reference）</strong> 。调用 Rc::downgrade 时会得到 Weak<t> 类型的智能指针。不同于将 Rc<t> 实例的 strong_count 加 1，调用 Rc::downgrade 会将 weak_count 加 1。Rc<t> 类型使用 weak_count 来记录其存在多少个 Weak<t> 引用，类似于 strong_count。其区别在于 weak_count 无需计数为 0 就能使 Rc<t> 实例被清理。</t></t></t></t></t></p><p>强引用代表如何共享 Rc<t> 实例的所有权，但弱引用并不属于所有权关系。他们不会造成引用循环，因为任何弱引用的循环会在其相关的强引用计数为 0 时被打断。</t></p></list></list></list></t>]]></content>
      
      
      <categories>
          
          <category> rust </category>
          
      </categories>
      
      
        <tags>
            
            <tag> rust </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>redis持久化</title>
      <link href="/2019/08/12/redis/redis-chi-jiu-hua/"/>
      <url>/2019/08/12/redis/redis-chi-jiu-hua/</url>
      
        <content type="html"><![CDATA[<h1 id="Redis"><a href="#Redis" class="headerlink" title="Redis"></a>Redis</h1><ul><li>Redis作为一个键值对内存数据库(Nosql)，它的强大性能很大程度上是因为所有数据都存储在内存当中，很显然<br>如果服务器重启(各种因素导致)，内存中存储的所有数据都会丢失，而且不光是重启，守护进程退出，数据一样会<br>丢失，现在Redis用作存储的业务场景变多，数据丢失对业务是致命的影响，如：<ol><li>缓存的应用场景，如果大量缓存数据丢失，往往导致后端存储组件”打死“，应用程序雪崩的情况。</li><li>Redis存储的应用场景，数据丢失是不能接受的;</li></ol></li></ul><h1 id="Redis持久化方案"><a href="#Redis持久化方案" class="headerlink" title="Redis持久化方案"></a>Redis持久化方案</h1><h3 id="redis提供了两种持久化的方案，分别是RDB和AOF"><a href="#redis提供了两种持久化的方案，分别是RDB和AOF" class="headerlink" title="redis提供了两种持久化的方案，分别是RDB和AOF"></a>redis提供了两种持久化的方案，分别是RDB和AOF</h3><h2 id="RDB："><a href="#RDB：" class="headerlink" title="RDB："></a>RDB：</h2><h5 id="RDB是一种快照存储持久化方式，将Redis内存中的数据保存到硬盘的文件中，生产的RDB文件是一个经过压缩的二进制文件，默认保存的文件名为dump-rdb，redis启动时会自动载入。"><a href="#RDB是一种快照存储持久化方式，将Redis内存中的数据保存到硬盘的文件中，生产的RDB文件是一个经过压缩的二进制文件，默认保存的文件名为dump-rdb，redis启动时会自动载入。" class="headerlink" title="RDB是一种快照存储持久化方式，将Redis内存中的数据保存到硬盘的文件中，生产的RDB文件是一个经过压缩的二进制文件，默认保存的文件名为dump.rdb，redis启动时会自动载入。"></a>RDB是一种快照存储持久化方式，将Redis内存中的数据保存到硬盘的文件中，生产的RDB文件是一个经过压缩的二进制文件，默认保存的文件名为dump.rdb，redis启动时会自动载入。</h5><h6 id="RDB实现方式有两种，手动执行和服务器配置定期执行"><a href="#RDB实现方式有两种，手动执行和服务器配置定期执行" class="headerlink" title="RDB实现方式有两种，手动执行和服务器配置定期执行"></a>RDB实现方式有两种，手动执行和服务器配置定期执行</h6><ul><li>手动执行有两个命令可用于生成RDB文件，SAVE和BGSAVE<ol><li>SAVE命令，但SAVE命令会阻塞服务进程，阻塞其它命令，直到RDB文件创建完成，才执行。如若数据量较大不建议使用该命令。</li><li>BGSAVE命令，与SAVE不同，BGSAVE是通过派生子进程来实现的，主进程依旧可以接收命令，但派生子进程是同步的，所以派生子进程过程较长(一版很快)也会出现阻塞的情况。</li></ol></li><li>BGSAVE命令执行过程中，无法同时执行SAVE和BESAVE，避免产生竞争条件。</li><li>服务器配置定时执行<pre class="line-numbers language-none"><code class="language-none">save 900 1      // 900内,有1条写入,则产生快照 save 300 1000   // 如果300秒内有1000次写入,则产生快照save 60 10000  // 如果60秒内有10000次写入,则产生快照<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>通过配置文件进行触发，如上所示，根据操作次数进行触发，redis服务器的周期性函数serverCorn会每一百毫秒进行一次，它的工作之前就是判断是否满足配置参数条件，如果满足就执行BGSAVE命令。<br>RDB其它相关配置<pre class="line-numbers language-none"><code class="language-none">stop-writes-on-bgsave-error yes  // 后台备份进程出错时,主进程停不停止写入?   rdbcompression yes    // 导出的rdb文件是否压缩   Rdbchecksum   yes //  导入rbd恢复时数据时,要不要检验rdb的完整性   dbfilename dump.rdb  //导出来的rdb文件名   dir ./  //rdb的放置路径<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ul><h2 id="AOF"><a href="#AOF" class="headerlink" title="AOF"></a>AOF</h2><h5 id="AOF-Append-Only-File-，与RDB某个时刻的快照不同，AOF持久化会记录每次操作，形成后缀为aof的文件，类似mysql的binlog。在重启后会通过运行aof文件，以达到回复文件的目的。相较而言会对redis性能有些影响，但大部分情况是可接受的"><a href="#AOF-Append-Only-File-，与RDB某个时刻的快照不同，AOF持久化会记录每次操作，形成后缀为aof的文件，类似mysql的binlog。在重启后会通过运行aof文件，以达到回复文件的目的。相较而言会对redis性能有些影响，但大部分情况是可接受的" class="headerlink" title="AOF(Append-Only File)，与RDB某个时刻的快照不同，AOF持久化会记录每次操作，形成后缀为aof的文件，类似mysql的binlog。在重启后会通过运行aof文件，以达到回复文件的目的。相较而言会对redis性能有些影响，但大部分情况是可接受的."></a>AOF(Append-Only File)，与RDB某个时刻的快照不同，AOF持久化会记录每次操作，形成后缀为aof的文件，类似mysql的binlog。在重启后会通过运行aof文件，以达到回复文件的目的。相较而言会对redis性能有些影响，但大部分情况是可接受的.</h5><ul><li>Redis默认不开启AOF持久化方式，我们可以在配置文件中开启  <pre class="line-numbers language-none"><code class="language-none">appendonly no # 是否打开 aof日志功能<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li><p>AOF持久化的实现可分为三步，追加(append)、文件写入、文件同步(sync)</p><ol><li>命令追加，服务器每次操作都会以redis的协议方式形成二进制文件，追加到aof_buf缓冲区的末尾。<pre class="line-numbers language-none"><code class="language-none">struct redisServer{    sds aof_buf;/* AOF buffer, written before entering the event loop */}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre></li><li><p>文件写入与同步<br>redis服务器进程就是一个事件循环函数，每次循环结束前，都会调用<br>flushAppendOnlyFile()，考虑是否将aof缓冲区中的内容写入到aof文件当中，flushAppendOnlyFile()函数的行为由配置appendfsync参数控制，一共如下三种策略，缺省情况下默认为everysec策略。<br>缓冲区确实提高了效率，但也存在一定安全问题，如果发生停机，那么缓冲区的数据也会丢失，为此redis提供了两个同步函数，fsync和fdatasync，强制将缓冲区的数据写入到硬盘文件。</p><pre class="line-numbers language-none"><code class="language-none">appendfsync always   # 每1个命令,都立即同步到aof. 安全,速度慢appendfsync everysec # 折衷方案,每秒写1次appendfsync no #写入工作交给操作系统,由操作系统判断缓冲区大小,统一写入到aof. 同步频率低,速度快<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre></li><li><p>AOF文件载入与还原<br>aof文件已经包含所有操作命令，所以数据还原其实就是再次执行一次aof中的命令。步骤：<br>1) 创建一个不带网络伪客户端，因为redis命令只能在客户端执行，并且执行命令来源于aof文件。<br>2) 从aof文件中读取一条命令<br>3) 在伪客户端执行<br>4) 反复执行二三步，直至aof文件中的命令执行完毕</p></li></ol></li><li><p>AOF重写</p><ol><li><p>因为aof会把每一步操作都记录到文件，aof文件会越来越大，数据还原时间会越来越长。<br>如下命令操作为了记录list键的状态，aof文件就保存了五条命令，为了解决aof文件膨胀的问题，redis提供了重写(rewrite)机制，通过重写aof，可以生成一个恢复当前redis中数据的最少命令集，比如上面五条就可以合为一条。虽然功能命名为”aof文件重写”，但实际不会对aof文件进行分析处理，而是根据数据库状态来实现的。</p><pre class="line-numbers language-none"><code class="language-none">RPUSH enlist "A" "B"RPUSH enlist "C" "V"RPUSH enlist "D" "G"LPOP enlist "G"LPOP list "A"<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>重写策略<br>2.1配置文件方式：<br>默认情况下是不开启重写的,打开后每次fsync都会进行rewrite</p><pre class="line-numbers language-none"><code class="language-none">no-appendfsync-on-rewrite no<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>当然单独配置会比较影响服务器性能，所以可以与另外两个参数一起配置，三个参数一起配置就可以控制rewrite的运行时机，此逻辑也是通过serverCron()函数进行判断控制的</p><pre class="line-numbers language-none"><code class="language-none">auto-aof-rewrite-percentage 100 #aof文件大小比起上次重写时的大小                                增长率100%时,重写auto-aof-rewrite-min-size 64mb #aof文件,至少超过64M时,重写<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>2.2 手动触发<br>客户端向服务器发送BGREWRITEAOF命令，也可以让服务器进行AOF重写。并且是异步进行<br>注：BGREWRITEAOF正在执行，客户端发送BGSAVE命令会被服务器拒绝，BGSAVE正在执行，客户端发送BGREWRITEAOF，两者在操作上没有冲突，只是都是由子进程进行工作，不能同时执行只是性能方面的考虑——并发两个线程，并且都是大量磁盘写入工作。</p></li></ol></li><li>AOF文件破损<br>因服务宕机会造成aof文件格式紊乱，这种情况下服务会拒绝加载aof文件，出现文件损坏的情况可以通过以下命令进行修复  <pre class="line-numbers language-none"><code class="language-none">$ redis-check-aof -fix file.aof<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>  重启服务后可重新载入aof文件进行数据恢复。<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2></li><li>RDB<ol><li>RDB相较AOF而言，恢复数据快，数据紧凑</li><li>SAVE命令容易阻塞服务器，影响性能，BGSAVE虽然由子进行进行工作，但数据量较大时，也会有影响</li><li>容易造成某时间段数据丢失</li></ol></li><li>AOF<ol><li>AOF为追加操作记录形式，对服务器影响小，速度快</li><li>数据量大时，AOF文件体积太大，恢复慢，即使通过重写，文件体积依然较大。</li></ol></li><li>具体选择哪种方式就需要根据具体场景需求进行选择，当然也可以两种方式配合进行，但redis会优先使用AOF文件方式恢复数据，因为AOF文件保存数据比较完整。</li></ul><p><img src="https://user-gold-cdn.xitu.io/2019/6/26/16b918cd860b0ffd?imageslim" alt="Alt"></p><hr><h3 id="源码资料"><a href="#源码资料" class="headerlink" title="源码资料"></a>源码资料</h3><p><a href="https://github.com/huangz1990/redis-3.0-annotated.git">https://github.com/huangz1990/redis-3.0-annotated.git</a></p><h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><p><a href="https://juejin.im/post/5d09a9ff51882577eb133aa9#heading-7">https://juejin.im/post/5d09a9ff51882577eb133aa9#heading-7</a></p>]]></content>
      
      
      <categories>
          
          <category> Redis </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Redis </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
